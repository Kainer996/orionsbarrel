<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Orion's Barrel - Space Bar Manager</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Bangers&family=Nunito:wght@400;700;900&display=swap');
        
        * { margin: 0; padding: 0; box-sizing: border-box; -webkit-tap-highlight-color: transparent; }
        
        body {
            font-family: 'Nunito', Arial, sans-serif;
            background: #0a0e27;
            overflow: hidden;
            touch-action: none;
            user-select: none;
        }

        #game-container {
            width: 100vw; height: 100vh;
            position: relative;
            overflow: hidden;
        }

        #game-canvas {
            position: absolute; top: 0; left: 0;
            width: 100%; height: 100%;
            cursor: grab; z-index: 1;
        }
        #game-canvas:active { cursor: grabbing; }

        /* ===== HUD ===== */
        #hud {
            position: absolute; top: 0; left: 0; right: 0;
            padding: 10px 15px;
            background: linear-gradient(180deg, rgba(8,15,30,0.95) 0%, rgba(8,15,30,0.6) 100%);
            display: flex; justify-content: space-between; align-items: center;
            z-index: 100;
            border-bottom: 2px solid rgba(0,255,136,0.4);
        }
        .hud-left { display: flex; gap: 8px; flex-wrap: wrap; }
        .hud-stat {
            display: flex; align-items: center; gap: 6px;
            background: rgba(0,60,80,0.9);
            padding: 5px 12px; border-radius: 20px;
            border: 2px solid #00ff88;
            box-shadow: 0 0 10px rgba(0,255,136,0.3);
            font-size: 14px; color: #fff;
        }
        .hud-stat strong { color: #ffd700; font-size: 16px; }
        .hud-icon { font-size: 18px; }
        .hud-right { display: flex; gap: 6px; align-items: center; }
        
        .ctrl-btn {
            width: 34px; height: 34px;
            background: rgba(0,80,100,0.9);
            border: 2px solid #00ff88; border-radius: 8px;
            color: #fff; font-size: 18px; cursor: pointer;
            display: flex; align-items: center; justify-content: center;
            transition: all 0.15s;
        }
        .ctrl-btn:hover { background: rgba(0,140,160,0.9); transform: scale(1.1); }
        .ctrl-btn:active { transform: scale(0.9); }

        /* ===== DAILY SPECIAL PULSE ===== */
        @keyframes specialPulse {
            0%, 100% { box-shadow: 0 0 8px rgba(255,215,0,0.3); }
            50% { box-shadow: 0 0 16px rgba(255,215,0,0.7); }
        }
        .daily-special { animation: specialPulse 2s ease-in-out infinite; }

        /* ===== REPUTATION BAR ===== */
        #rep-bar-wrap {
            position: absolute; top: 58px; left: 50%; transform: translateX(-50%);
            z-index: 100; width: 280px;
        }
        #rep-bar-label { color: #aaa; font-size: 11px; text-align: center; margin-bottom: 2px; }
        #rep-bar-outer {
            height: 8px; background: rgba(0,0,0,0.6);
            border-radius: 4px; overflow: hidden;
            border: 1px solid rgba(0,255,136,0.3);
        }
        #rep-bar-inner {
            height: 100%; width: 50%;
            background: linear-gradient(90deg, #ff4444, #ffaa00, #00ff88);
            transition: width 0.5s;
            border-radius: 4px;
        }

        /* ===== BOTTOM BAR ===== */
        #bottom-bar {
            position: absolute; bottom: 0; left: 0; right: 0;
            height: 70px;
            background: linear-gradient(0deg, rgba(8,15,30,0.95) 0%, rgba(8,15,30,0.6) 100%);
            border-top: 2px solid rgba(0,255,136,0.3);
            z-index: 100;
            display: flex; align-items: center; justify-content: center; gap: 10px;
            padding: 0 10px;
        }
        .bottom-btn {
            padding: 8px 16px; border-radius: 12px;
            background: rgba(0,80,100,0.9);
            border: 2px solid #00ff88;
            color: #fff; font-family: 'Bangers', cursive;
            font-size: 16px; letter-spacing: 1px;
            cursor: pointer; transition: all 0.15s;
            box-shadow: 0 0 10px rgba(0,255,136,0.2);
        }
        .bottom-btn:hover { background: rgba(0,140,160,0.9); transform: scale(1.05); }
        .bottom-btn:active { transform: scale(0.95); }
        .bottom-btn.active { background: rgba(0,200,100,0.4); border-color: #ffd700; }

        /* ===== SPACE NEWS TICKER ===== */
        #news-ticker {
            position: absolute; bottom: 70px; left: 0; right: 0;
            height: 26px; z-index: 99;
            background: linear-gradient(90deg, rgba(8,15,40,0.95) 0%, rgba(15,20,50,0.9) 50%, rgba(8,15,40,0.95) 100%);
            border-top: 1px solid rgba(0,255,136,0.2);
            border-bottom: 1px solid rgba(0,255,136,0.15);
            display: flex; align-items: center;
            overflow: hidden;
        }
        .ticker-label {
            background: rgba(0,255,136,0.15);
            color: #00ff88; font-family: 'Bangers', cursive;
            font-size: 11px; letter-spacing: 1px;
            padding: 2px 10px; white-space: nowrap;
            border-right: 1px solid rgba(0,255,136,0.3);
            flex-shrink: 0;
        }
        .ticker-scroll {
            flex: 1; overflow: hidden; position: relative; height: 100%;
            display: flex; align-items: center;
        }
        #ticker-text {
            white-space: nowrap; color: #aaddff;
            font-size: 12px; font-family: 'Nunito', sans-serif;
            position: absolute; padding-left: 100%;
            animation: tickerScroll 22s linear infinite;
            will-change: transform;
        }
        @keyframes tickerScroll {
            0% { transform: translateX(0); }
            100% { transform: translateX(-200%); }
        }

        /* ===== SHOP PANEL ===== */
        #shop-panel {
            position: absolute; bottom: -400px; left: 0; right: 0;
            height: 400px;
            background: linear-gradient(180deg, rgba(10,25,40,0.98) 0%, rgba(5,12,20,0.98) 100%);
            border-top: 3px solid #00ff88;
            box-shadow: 0 -5px 30px rgba(0,255,136,0.4);
            transition: bottom 0.3s ease;
            z-index: 200; overflow-y: auto; padding: 15px;
        }
        #shop-panel.open { bottom: 70px; }
        .shop-tabs { display: flex; gap: 8px; margin-bottom: 12px; }
        .shop-tab {
            padding: 6px 16px; border-radius: 8px;
            background: rgba(0,60,80,0.6); border: 2px solid #006688;
            color: #88ccdd; cursor: pointer; font-weight: bold; font-size: 13px;
        }
        .shop-tab.active { background: rgba(0,100,120,0.8); border-color: #00ff88; color: #fff; }
        .shop-grid {
            display: grid; grid-template-columns: repeat(auto-fill, minmax(130px, 1fr));
            gap: 10px;
        }
        .shop-item {
            background: rgba(0,60,80,0.5); border: 2px solid #006688;
            border-radius: 10px; padding: 10px; text-align: center;
            cursor: pointer; transition: all 0.2s;
        }
        .shop-item:hover { background: rgba(0,100,120,0.7); border-color: #00ff88; transform: scale(1.03); }
        .shop-item.locked { opacity: 0.4; cursor: not-allowed; }
        .shop-item .item-icon { font-size: 28px; margin-bottom: 4px; }
        .shop-item .item-name { color: #ffd700; font-size: 12px; font-weight: bold; }
        .shop-item .item-price { color: #00ff88; font-size: 13px; margin-top: 2px; }
        .shop-item .item-lock { color: #ff6666; font-size: 11px; }

        /* ===== INVENTORY PANEL ===== */
        #inv-panel {
            position: absolute; bottom: -400px; left: 0; right: 0;
            height: 400px;
            background: linear-gradient(180deg, rgba(10,25,40,0.98) 0%, rgba(5,12,20,0.98) 100%);
            border-top: 3px solid #ffd700;
            box-shadow: 0 -5px 30px rgba(255,215,0,0.4);
            transition: bottom 0.3s ease;
            z-index: 200; overflow-y: auto; padding: 15px;
        }
        #inv-panel.open { bottom: 70px; }
        #inv-panel h3 { color: #ffd700; font-family: 'Bangers', cursive; font-size: 22px; margin-bottom: 12px; letter-spacing: 2px; }
        .inv-grid {
            display: grid; grid-template-columns: repeat(auto-fill, minmax(110px, 1fr));
            gap: 10px;
        }
        .inv-item {
            background: rgba(0,60,80,0.5); border: 2px solid #006688;
            border-radius: 10px; padding: 10px; text-align: center;
            cursor: pointer; transition: all 0.2s; position: relative;
        }
        .inv-item:hover { background: rgba(0,100,120,0.7); border-color: #ffd700; transform: scale(1.05); }
        .inv-item .inv-icon { font-size: 28px; margin-bottom: 4px; }
        .inv-item .inv-name { color: #ffd700; font-size: 11px; font-weight: bold; }
        .inv-item .inv-qty {
            position: absolute; top: 4px; right: 6px;
            background: #00ff88; color: #000; font-size: 11px; font-weight: 900;
            border-radius: 10px; padding: 1px 6px; min-width: 18px;
        }
        .inv-empty { color: #556; font-size: 14px; text-align: center; padding: 40px; }

        /* ===== PLACEMENT MODE BANNER ===== */
        #placement-banner {
            position: absolute; top: 58px; left: 50%; transform: translateX(-50%);
            z-index: 300; display: none;
            background: rgba(0,0,0,0.9); border: 2px solid #ffd700; border-radius: 10px;
            padding: 8px 20px; color: #ffd700; font-weight: bold; font-size: 14px;
            text-align: center; pointer-events: none;
            box-shadow: 0 0 20px rgba(255,215,0,0.5);
        }
        #placement-banner.show { display: block; }

        /* ===== DRINK MENU (when clicking customer) ===== */
        #drink-menu {
            position: absolute; display: none;
            z-index: 300; min-width: 200px;
            background: rgba(10,25,40,0.97);
            border: 3px solid #ffd700; border-radius: 12px;
            padding: 10px; box-shadow: 0 0 30px rgba(255,215,0,0.4);
        }
        #drink-menu h4 { color: #ffd700; font-family: 'Bangers', cursive; font-size: 18px; margin-bottom: 8px; text-align: center; }
        .drink-option {
            display: flex; align-items: center; gap: 8px;
            padding: 6px 8px; border-radius: 6px; cursor: pointer;
            transition: background 0.15s; margin-bottom: 4px;
        }
        .drink-option:hover { background: rgba(0,100,120,0.5); }
        .drink-option .drink-dot { width: 12px; height: 12px; border-radius: 50%; }
        .drink-option .drink-name { color: #fff; font-size: 13px; flex: 1; }
        .drink-option .drink-info { color: #88ccdd; font-size: 11px; }

        /* ===== NOTIFICATION ===== */
        #notification {
            position: absolute; top: 75px; left: 50%; transform: translateX(-50%);
            background: rgba(0,0,0,0.92); color: #00ff88;
            padding: 10px 22px; border-radius: 10px;
            border: 2px solid #00ff88; font-size: 15px; font-weight: bold;
            z-index: 300; display: none;
            box-shadow: 0 0 25px rgba(0,255,136,0.6);
            max-width: 90%; text-align: center;
            pointer-events: none;
        }
        #notification.show { display: block; animation: notifIn 0.3s ease; }
        @keyframes notifIn { from { opacity: 0; top: 55px; } to { opacity: 1; top: 75px; } }

        /* ===== TUTORIAL ===== */
        #tutorial {
            position: absolute; top: 0; left: 0; right: 0; bottom: 0;
            background: rgba(0,0,0,0.88); z-index: 500;
            display: flex; align-items: flex-start; justify-content: center; padding: 10px;
            overflow-y: auto; -webkit-overflow-scrolling: touch;
        }
        #tutorial.hidden { display: none; }
        .tut-box {
            background: linear-gradient(135deg, #152535 0%, #0d1a28 100%);
            border: 4px solid #00ff88; border-radius: 18px;
            padding: 20px; max-width: 480px; text-align: center;
            box-shadow: 0 0 60px rgba(0,255,136,0.4);
            margin: auto;
        }
        .tut-box h1 { color: #ffd700; font-family: 'Bangers', cursive; font-size: 28px; letter-spacing: 3px; margin-bottom: 5px; }
        .tut-box .subtitle { color: #00ff88; font-size: 13px; margin-bottom: 12px; font-style: italic; }
        .tut-box p { color: #aaddff; font-size: 13px; line-height: 1.5; margin-bottom: 6px; }
        .tut-box .chars { display: flex; justify-content: center; gap: 10px; margin: 10px 0; }
        .tut-box .char-preview { width: 50px; height: 62px; object-fit: contain; border-radius: 8px; }
        @media (max-height: 450px) {
            .tut-box { padding: 12px; }
            .tut-box h1 { font-size: 22px; }
            .tut-box p { font-size: 11px; line-height: 1.3; margin-bottom: 3px; }
            .tut-box .chars { margin: 6px 0; gap: 6px; }
            .tut-box .char-preview { width: 36px; height: 45px; }
            .tut-btn { padding: 8px 24px; font-size: 18px; }
        }
        .tut-btn {
            background: linear-gradient(135deg, #00ff88 0%, #00aa66 100%);
            border: 3px solid #ffd700; color: #000;
            font-family: 'Bangers', cursive; font-size: 22px; letter-spacing: 2px;
            padding: 12px 40px; border-radius: 10px; cursor: pointer;
            margin-top: 15px; transition: transform 0.15s;
        }
        .tut-btn:active { transform: scale(0.95); }

        /* ===== LOADING ===== */
        #loading {
            position: absolute; top: 0; left: 0; right: 0; bottom: 0;
            background: #0a0e27 url('assets/new/map-exterior.png') center center / cover no-repeat;
            z-index: 600;
            display: flex; flex-direction: column; align-items: center; justify-content: center;
        }
        #loading::before {
            content: ''; position: absolute; top: 0; left: 0; right: 0; bottom: 0;
            background: rgba(5, 10, 25, 0.72);
            z-index: 0;
        }
        #loading h1, #loading .tagline, #loading .load-bar, #loading .load-text {
            position: relative; z-index: 1;
        }
        #loading h1 { font-family: 'Bangers', cursive; font-size: 38px; color: #ffd700; letter-spacing: 4px; margin-bottom: 10px; text-shadow: 0 0 20px rgba(255,215,0,0.6); }
        #loading .tagline { color: #00ff88; font-size: 14px; margin-bottom: 20px; }
        .load-bar { width: 260px; height: 20px; background: rgba(0,60,80,0.4); border: 2px solid #00ff88; border-radius: 10px; overflow: hidden; }
        .load-fill { height: 100%; width: 0%; background: linear-gradient(90deg, #00ff88, #00aa66); transition: width 0.3s; box-shadow: 0 0 10px rgba(0,255,136,0.6); }
        .load-text { color: #88ccdd; font-size: 12px; margin-top: 8px; }

        /* ===== EVENT LOG ===== */
        #event-log {
            position: absolute; bottom: 80px; left: 10px;
            width: 260px; max-height: 150px;
            z-index: 90; overflow: hidden;
            pointer-events: none;
        }
        .log-entry {
            color: #88ccdd; font-size: 12px;
            padding: 2px 8px; margin-bottom: 2px;
            background: rgba(0,0,0,0.5);
            border-radius: 4px;
            animation: logFade 8s ease forwards;
        }
        .log-entry.tip { color: #ffd700; }
        .log-entry.earn { color: #00ff88; }
        .log-entry.bad { color: #ff6666; }
        @keyframes logFade { 0% { opacity: 1; } 70% { opacity: 1; } 100% { opacity: 0; } }

        /* ===== FLOATING EMOJIS ===== */
        .float-emoji {
            position: absolute; z-index: 150; pointer-events: none;
            font-size: 28px; animation: floatUp 1.5s ease-out forwards;
        }
        @keyframes floatUp {
            0% { opacity: 1; transform: translateY(0) scale(1); }
            100% { opacity: 0; transform: translateY(-80px) scale(1.5); }
        }

        /* ===== FLOATING NUMBERS ===== */
        .float-number {
            position: absolute; z-index: 150; pointer-events: none;
            font-family: 'Bangers', cursive; font-size: 20px;
            animation: floatUpNumber 1.2s ease-out forwards;
            text-shadow: 0 0 8px rgba(0,0,0,0.8);
        }
        .float-number.credits { color: #ffd700; }
        .float-number.xp { color: #00ff88; }
        .float-number.combo { color: #ff00ff; font-size: 28px; }
        @keyframes floatUpNumber {
            0% { opacity: 1; transform: translateY(0) scale(0.5); }
            20% { transform: translateY(-10px) scale(1.2); }
            100% { opacity: 0; transform: translateY(-60px) scale(0.8); }
        }

        /* ===== PARTICLE EFFECTS ===== */
        .particle {
            position: absolute; z-index: 140; pointer-events: none;
            width: 8px; height: 8px; border-radius: 50%;
            animation: particleBurst 0.8s ease-out forwards;
        }
        @keyframes particleBurst {
            0% { opacity: 1; transform: translate(0, 0) scale(1); }
            100% { opacity: 0; transform: translate(var(--px), var(--py)) scale(0); }
        }

        /* ===== SPARKLE EFFECT ===== */
        .sparkle {
            position: absolute; z-index: 145; pointer-events: none;
            font-size: 16px; animation: sparkleAnim 0.6s ease-out forwards;
        }
        @keyframes sparkleAnim {
            0% { opacity: 0; transform: scale(0) rotate(0deg); }
            50% { opacity: 1; transform: scale(1.5) rotate(180deg); }
            100% { opacity: 0; transform: scale(0) rotate(360deg); }
        }

        /* ===== SCREEN SHAKE ===== */
        @keyframes screenShake {
            0%, 100% { transform: translate(0, 0); }
            10% { transform: translate(-4px, 2px); }
            20% { transform: translate(4px, -2px); }
            30% { transform: translate(-3px, 3px); }
            40% { transform: translate(3px, -3px); }
            50% { transform: translate(-2px, 2px); }
            60% { transform: translate(2px, -2px); }
            70% { transform: translate(-1px, 1px); }
            80% { transform: translate(1px, -1px); }
            90% { transform: translate(0, 0); }
        }
        .shake { animation: screenShake 0.4s ease-in-out; }

        /* ===== NEON GLOW PULSE ===== */
        .hud-stat { animation: neonPulse 3s ease-in-out infinite alternate; }
        @keyframes neonPulse {
            0% { box-shadow: 0 0 8px rgba(0,255,136,0.2); }
            100% { box-shadow: 0 0 16px rgba(0,255,136,0.5); }
        }
        .bottom-btn { animation: btnGlow 4s ease-in-out infinite alternate; }
        @keyframes btnGlow {
            0% { box-shadow: 0 0 8px rgba(0,255,136,0.15); }
            100% { box-shadow: 0 0 20px rgba(0,255,136,0.4); }
        }

        /* ===== SAVE INDICATOR ===== */
        #save-indicator {
            position: absolute; top: 62px; right: 12px; z-index: 100;
            color: #00ff88; font-size: 11px; opacity: 0;
            transition: opacity 0.3s;
        }
        #save-indicator.show { opacity: 1; }

        /* ===== SPACE JUKEBOX ===== */
        #jukebox-btn {
            position: absolute; top: 62px; left: 12px; z-index: 100;
            background: rgba(0,60,80,0.8); border: 1px solid #00ff88;
            border-radius: 6px; padding: 3px 8px; color: #88ccdd;
            font-size: 11px; cursor: pointer;
        }
        #jukebox-btn:hover { color: #fff; }
        #jukebox-btn.playing { color: #00ff88; border-color: #ffd700; animation: jukeGlow 2s ease-in-out infinite; }
        @keyframes jukeGlow { 0%,100% { box-shadow: 0 0 5px rgba(255,215,0,0.3); } 50% { box-shadow: 0 0 15px rgba(255,215,0,0.6); } }
        #jukebox-panel {
            position: absolute; top: 82px; left: 12px; z-index: 200;
            background: rgba(8,15,30,0.95); border: 2px solid #00ff88;
            border-radius: 12px; padding: 12px; width: 240px;
            display: none; box-shadow: 0 0 30px rgba(0,255,136,0.2);
        }
        #jukebox-panel.open { display: block; }
        #jukebox-panel h4 { color: #ffd700; font-family: 'Bangers', cursive; font-size: 18px; margin-bottom: 8px; letter-spacing: 2px; text-align: center; }
        .juke-station {
            display: flex; align-items: center; gap: 8px; padding: 6px 8px;
            border-radius: 8px; cursor: pointer; transition: all 0.15s;
            border: 1px solid transparent; margin-bottom: 4px;
        }
        .juke-station:hover { background: rgba(0,255,136,0.1); }
        .juke-station.active { background: rgba(0,255,136,0.15); border-color: #00ff88; }
        .juke-station .juke-icon { font-size: 20px; }
        .juke-station .juke-info { flex: 1; }
        .juke-station .juke-name { color: #fff; font-size: 12px; font-weight: 700; }
        .juke-station .juke-buff { color: #88ccdd; font-size: 10px; }
        .juke-station .juke-eq { display: flex; gap: 2px; align-items: flex-end; height: 14px; }
        .juke-station.active .juke-eq span { display: inline-block; width: 3px; background: #00ff88; border-radius: 1px; animation: eqBar 0.6s ease-in-out infinite alternate; }
        .juke-station.active .juke-eq span:nth-child(2) { animation-delay: 0.15s; }
        .juke-station.active .juke-eq span:nth-child(3) { animation-delay: 0.3s; }
        .juke-station.active .juke-eq span:nth-child(4) { animation-delay: 0.45s; }
        @keyframes eqBar { from { height: 3px; } to { height: 14px; } }
        #jukebox-vol { width: 100%; margin-top: 6px; accent-color: #00ff88; }
        .juke-off-btn { text-align: center; color: #ff6666; font-size: 11px; cursor: pointer; margin-top: 4px; }
        .juke-off-btn:hover { color: #ff8888; }

        /* ===== COMBO INDICATOR ===== */
        #combo-display {
            position: absolute; top: 90px; right: 12px; z-index: 100;
            color: #ffd700; font-family: 'Bangers', cursive;
            font-size: 0px; opacity: 0; transition: all 0.3s;
            text-shadow: 0 0 10px rgba(255,215,0,0.6);
        }
        #combo-display.show { font-size: 22px; opacity: 1; }

        /* ===== DAY/NIGHT OVERLAY ===== */
        #daynight-overlay {
            position: absolute; top: 0; left: 0; right: 0; bottom: 0;
            pointer-events: none; z-index: 2;
            transition: background 2s ease;
        }
        #time-display {
            position: absolute; top: 62px; left: 50%; transform: translateX(-50%);
            z-index: 100; color: #88ccdd; font-size: 12px;
            background: rgba(0,0,0,0.5); padding: 2px 10px; border-radius: 8px;
            white-space: nowrap;
        }

        /* ===== DRINK MASTERY PANEL ===== */
        #mastery-panel {
            position: absolute; top: 80px; left: 50%; transform: translateX(-50%);
            width: 420px; max-width: 95vw; max-height: 70vh;
            background: linear-gradient(135deg, rgba(10,14,39,0.98), rgba(20,10,50,0.98));
            border: 2px solid #ff8800; border-radius: 16px;
            padding: 20px; z-index: 500; overflow-y: auto;
            display: none; box-shadow: 0 0 40px rgba(255,136,0,0.3);
        }
        #mastery-panel.open { display: block; }
        #mastery-panel h3 { color: #ff8800; font-family: 'Bangers', cursive; font-size: 22px; margin-bottom: 4px; letter-spacing: 2px; text-align: center; }
        #mastery-subtitle { color: #aaa; font-size: 12px; text-align: center; margin-bottom: 12px; }
        .mastery-item {
            background: rgba(255,136,0,0.08); border: 1px solid rgba(255,136,0,0.2);
            border-radius: 10px; padding: 10px 12px; margin-bottom: 8px;
            display: flex; align-items: center; gap: 10px;
            transition: all 0.2s;
        }
        .mastery-item:hover { border-color: #ff8800; background: rgba(255,136,0,0.15); }
        .mastery-item.locked { opacity: 0.35; filter: grayscale(0.6); }
        .mastery-item.max-level { border-color: #ffd700; box-shadow: 0 0 10px rgba(255,215,0,0.2); }
        .mastery-icon { font-size: 28px; width: 36px; text-align: center; }
        .mastery-info { flex: 1; min-width: 0; }
        .mastery-name { font-weight: 900; color: #fff; font-size: 13px; }
        .mastery-rank { font-size: 11px; margin-left: 6px; }
        .mastery-rank.novice { color: #888; }
        .mastery-rank.apprentice { color: #44aaff; }
        .mastery-rank.skilled { color: #00ff88; }
        .mastery-rank.expert { color: #ff8800; }
        .mastery-rank.master { color: #ff44ff; }
        .mastery-rank.legendary { color: #ffd700; text-shadow: 0 0 6px rgba(255,215,0,0.5); }
        .mastery-bonus { font-size: 10px; color: #aaa; margin-top: 2px; }
        .mastery-progress { height: 6px; background: rgba(0,0,0,0.4); border-radius: 3px; margin-top: 4px; overflow: hidden; }
        .mastery-progress-inner { height: 100%; border-radius: 3px; transition: width 0.3s; background: linear-gradient(90deg, #ff6600, #ff8800, #ffaa00); }
        .mastery-item.max-level .mastery-progress-inner { background: linear-gradient(90deg, #ff44ff, #ffd700, #ff44ff); }
        .mastery-count { font-size: 11px; color: #aaa; text-align: right; min-width: 50px; }
        #mastery-close-btn {
            display: block; margin: 12px auto 0; padding: 8px 24px;
            background: rgba(255,136,0,0.2); border: 1px solid #ff8800;
            border-radius: 8px; color: #ff8800; cursor: pointer; font-size: 14px;
            font-family: 'Bangers', cursive; letter-spacing: 1px;
        }
        #mastery-close-btn:hover { background: rgba(255,136,0,0.4); }
        #mastery-total-summary { text-align: center; margin-bottom: 12px; padding: 8px; background: rgba(255,136,0,0.1); border-radius: 8px; }
        #mastery-total-summary span { color: #ffd700; font-weight: bold; }

        /* ===== ACHIEVEMENTS PANEL ===== */
        #achievements-panel {
            position: absolute; top: 0; left: -320px; bottom: 0; width: 310px;
            background: linear-gradient(90deg, rgba(10,25,40,0.98) 0%, rgba(5,12,20,0.95) 100%);
            border-right: 3px solid #ffd700;
            box-shadow: 5px 0 30px rgba(255,215,0,0.3);
            z-index: 250; overflow-y: auto; padding: 15px;
            transition: left 0.3s ease;
        }
        #achievements-panel.open { left: 0; }
        #achievements-panel h3 { color: #ffd700; font-family: 'Bangers', cursive; font-size: 22px; margin-bottom: 12px; letter-spacing: 2px; }
        .ach-item {
            display: flex; align-items: center; gap: 10px;
            background: rgba(0,40,60,0.6); border: 2px solid #555;
            border-radius: 12px; padding: 12px; margin-bottom: 10px;
            transition: all 0.2s;
        }
        .ach-item.unlocked {
            background: rgba(0,60,40,0.8); border-color: #ffd700;
            box-shadow: 0 0 15px rgba(255,215,0,0.3);
        }
        .ach-item .ach-icon { font-size: 32px; min-width: 40px; text-align: center; flex-shrink: 0; }
        .ach-item .ach-info { flex: 1; }
        .ach-item .ach-name { color: #fff; font-size: 14px; font-weight: bold; margin-bottom: 4px; }
        .ach-item .ach-desc { color: #aaa; font-size: 12px; margin-bottom: 6px; }
        .ach-item .ach-rewards { display: flex; gap: 8px; flex-wrap: wrap; }
        .ach-reward {
            background: rgba(255,215,0,0.2); border: 1px solid #ffd700;
            border-radius: 6px; padding: 2px 8px;
            font-size: 11px; color: #ffd700;
        }
        .ach-item .ach-check { font-size: 24px; flex-shrink: 0; }
        .ach-item .ach-desc { color: #88aacc; font-size: 11px; }
        .ach-item.locked .ach-icon { filter: grayscale(1) brightness(0.4); }
        .ach-item.locked .ach-name { color: #556; }

        /* ===== LEADERBOARD PANEL ===== */
        #leaderboard-panel {
            position: absolute; top: 0; right: -320px; bottom: 0; width: 310px;
            background: linear-gradient(270deg, rgba(10,25,40,0.98) 0%, rgba(5,12,20,0.95) 100%);
            border-left: 3px solid #00ff88;
            box-shadow: -5px 0 30px rgba(0,255,136,0.3);
            z-index: 250; overflow-y: auto; padding: 15px;
            transition: right 0.3s ease;
        }
        #leaderboard-panel.open { right: 0; }
        #leaderboard-panel h3 { color: #00ff88; font-family: 'Bangers', cursive; font-size: 22px; margin-bottom: 12px; letter-spacing: 2px; }
        .lb-entry {
            display: flex; align-items: center; gap: 10px;
            background: rgba(0,60,80,0.4); border: 2px solid #006688;
            border-radius: 10px; padding: 8px 10px; margin-bottom: 6px;
        }
        .lb-entry.current { border-color: #ffd700; background: rgba(80,60,0,0.4); }
        .lb-rank { color: #ffd700; font-family: 'Bangers', cursive; font-size: 20px; min-width: 30px; text-align: center; }
        .lb-info { flex: 1; }
        .lb-name { color: #fff; font-size: 13px; font-weight: bold; }
        .lb-score { color: #00ff88; font-size: 12px; }

        /* ===== RANDOM EVENT BANNER ===== */
        #event-banner {
            position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);
            z-index: 400; display: none;
            background: rgba(0,0,0,0.95); border: 3px solid #ff6600;
            border-radius: 16px; padding: 20px 30px;
            text-align: center; max-width: 360px;
            box-shadow: 0 0 40px rgba(255,100,0,0.6);
            animation: eventPop 0.4s ease;
        }
        @keyframes eventPop { from { transform: translate(-50%,-50%) scale(0.5); opacity: 0; } to { transform: translate(-50%,-50%) scale(1); opacity: 1; } }
        #event-banner .event-icon { font-size: 48px; margin-bottom: 8px; }
        #event-banner .event-title { color: #ffd700; font-family: 'Bangers', cursive; font-size: 24px; letter-spacing: 2px; }
        #event-banner .event-desc { color: #aaddff; font-size: 14px; margin-top: 6px; }

        /* ===== VIP GLOW ===== */
        .vip-glow {
            animation: vipPulse 1.5s ease-in-out infinite alternate;
        }
        @keyframes vipPulse {
            0% { box-shadow: 0 0 5px rgba(255,215,0,0.3); }
            100% { box-shadow: 0 0 20px rgba(255,215,0,0.8); }
        }

        /* ===== DAILY CHALLENGES PANEL ===== */
        #daily-panel {
            position: absolute; top: -450px; left: 50%; transform: translateX(-50%);
            width: min(450px, 90vw);
            background: linear-gradient(180deg, rgba(10,25,40,0.98) 0%, rgba(5,12,20,0.98) 100%);
            border: 3px solid #ff00ff;
            border-radius: 16px;
            box-shadow: 0 0 40px rgba(255,0,255,0.5);
            z-index: 300; padding: 20px;
            transition: top 0.4s ease;
        }
        #daily-panel.open { top: 80px; }
        #daily-panel h3 {
            color: #ff00ff; font-family: 'Bangers', cursive;
            font-size: 26px; margin-bottom: 8px; letter-spacing: 2px;
            text-align: center;
        }
        #daily-subtitle {
            color: #aaddff; font-size: 12px; text-align: center;
            margin-bottom: 15px;
        }
        .challenge-item {
            background: rgba(0,60,80,0.4);
            border: 2px solid #006688;
            border-radius: 12px;
            padding: 12px;
            margin-bottom: 12px;
            transition: all 0.3s;
        }
        .challenge-item.completed {
            border-color: #00ff88;
            background: rgba(0,80,60,0.5);
        }
        .challenge-header {
            display: flex;
            align-items: center;
            gap: 10px;
            margin-bottom: 8px;
        }
        .challenge-icon {
            font-size: 32px;
            min-width: 40px;
            text-align: center;
        }
        .challenge-info { flex: 1; }
        .challenge-name {
            color: #ffd700;
            font-size: 15px;
            font-weight: bold;
        }
        .challenge-desc {
            color: #88aacc;
            font-size: 12px;
            margin-top: 2px;
        }
        .challenge-reward {
            color: #00ff88;
            font-size: 11px;
            font-weight: bold;
        }
        .challenge-progress {
            margin-top: 8px;
        }
        .progress-bar-outer {
            height: 12px;
            background: rgba(0,0,0,0.5);
            border-radius: 6px;
            overflow: hidden;
            border: 1px solid rgba(0,255,136,0.3);
        }
        .progress-bar-inner {
            height: 100%;
            background: linear-gradient(90deg, #ff00ff, #ff66ff);
            transition: width 0.5s ease;
            border-radius: 6px;
        }
        .challenge-item.completed .progress-bar-inner {
            background: linear-gradient(90deg, #00ff88, #00aa66);
        }
        .progress-text {
            color: #aaddff;
            font-size: 11px;
            text-align: center;
            margin-top: 4px;
        }
        .challenge-complete-badge {
            color: #00ff88;
            font-size: 13px;
            font-weight: bold;
            text-align: center;
            margin-top: 4px;
        }
        .daily-rewards {
            background: rgba(255,0,255,0.1);
            border: 2px solid #ff00ff;
            border-radius: 10px;
            padding: 10px;
            text-align: center;
            margin-top: 15px;
        }
        .daily-rewards-title {
            color: #ff00ff;
            font-size: 13px;
            font-weight: bold;
            margin-bottom: 5px;
        }
        .daily-rewards-text {
            color: #aaddff;
            font-size: 12px;
        }
        #daily-close-btn {
            background: rgba(100,0,100,0.6);
            border: 2px solid #ff00ff;
            color: #fff;
            font-family: 'Bangers', cursive;
            font-size: 16px;
            padding: 8px 20px;
            border-radius: 10px;
            cursor: pointer;
            margin-top: 12px;
            width: 100%;
            transition: all 0.2s;
        }
        #daily-close-btn:hover {
            background: rgba(150,0,150,0.8);
            transform: scale(1.03);
        }

        /* ===== STORY QUESTS PANEL ===== */
        #quests-panel {
            position: absolute; top: -500px; left: 50%; transform: translateX(-50%);
            width: min(500px, 90vw); max-height: 80vh;
            background: linear-gradient(180deg, rgba(10,25,40,0.98) 0%, rgba(5,12,20,0.98) 100%);
            border: 3px solid #ffd700;
            border-radius: 16px;
            box-shadow: 0 0 40px rgba(255,215,0,0.5);
            z-index: 300; padding: 20px;
            transition: top 0.4s ease;
            overflow-y: auto;
        }
        #quests-panel.open { top: 80px; }
        #quests-panel h3 {
            color: #ffd700; font-family: 'Bangers', cursive;
            font-size: 26px; margin-bottom: 8px; letter-spacing: 2px;
            text-align: center;
        }
        #quest-subtitle {
            color: #aaddff; font-size: 12px; text-align: center;
            margin-bottom: 15px; font-style: italic;
        }
        .quest-item {
            background: rgba(0,60,80,0.4);
            border: 2px solid #006688;
            border-radius: 12px;
            padding: 14px;
            margin-bottom: 14px;
            transition: all 0.3s;
        }
        .quest-item.completed {
            border-color: #00ff88;
            background: rgba(0,80,60,0.5);
            opacity: 0.7;
        }
        .quest-item.active {
            border-color: #ffd700;
            box-shadow: 0 0 15px rgba(255,215,0,0.3);
        }
        .quest-item.locked {
            opacity: 0.5;
            cursor: not-allowed;
        }
        .quest-header {
            display: flex;
            align-items: flex-start;
            gap: 12px;
            margin-bottom: 10px;
        }
        .quest-icon {
            font-size: 36px;
            min-width: 44px;
            text-align: center;
        }
        .quest-info { flex: 1; }
        .quest-title {
            color: #ffd700;
            font-size: 16px;
            font-weight: bold;
            margin-bottom: 4px;
        }
        .quest-giver {
            color: #ff66ff;
            font-size: 11px;
            font-style: italic;
            margin-bottom: 6px;
        }
        .quest-story {
            color: #aaddff;
            font-size: 13px;
            line-height: 1.5;
            margin-bottom: 8px;
        }
        .quest-objective {
            background: rgba(0,0,0,0.3);
            border-left: 3px solid #ffd700;
            padding: 6px 10px;
            margin-top: 8px;
            border-radius: 4px;
        }
        .quest-objective-text {
            color: #88ccdd;
            font-size: 12px;
        }
        .quest-rewards {
            display: flex;
            gap: 12px;
            margin-top: 10px;
            flex-wrap: wrap;
        }
        .quest-reward-item {
            background: rgba(255,215,0,0.1);
            border: 1px solid #ffd700;
            border-radius: 6px;
            padding: 4px 10px;
            color: #00ff88;
            font-size: 11px;
            font-weight: bold;
        }
        .quest-status {
            margin-top: 10px;
            text-align: center;
            font-size: 12px;
            font-weight: bold;
        }
        .quest-status.locked { color: #ff6666; }
        .quest-status.active { color: #ffd700; }
        .quest-status.completed { color: #00ff88; }
        #quests-close-btn {
            background: rgba(100,80,0,0.6);
            border: 2px solid #ffd700;
            color: #fff;
            font-family: 'Bangers', cursive;
            font-size: 16px;
            padding: 8px 20px;
            border-radius: 10px;
            cursor: pointer;
            margin-top: 12px;
            width: 100%;
            transition: all 0.2s;
        }
        #quests-close-btn:hover {
            background: rgba(150,120,0,0.8);
            transform: scale(1.03);
        }

        /* ===== CHARACTER GUIDE PANEL ===== */
        #char-panel {
            position: absolute; right: -350px; top: 70px; bottom: 80px;
            width: 330px;
            background: linear-gradient(135deg, rgba(60,15,40,0.98) 0%, rgba(30,8,20,0.98) 100%);
            border-left: 3px solid #ff66ff;
            box-shadow: -5px 0 30px rgba(255,102,255,0.4);
            transition: right 0.3s ease;
            z-index: 200; overflow-y: auto; padding: 15px;
        }
        #char-panel.open { right: 0; }
        #char-panel h3 {
            color: #ff66ff; font-family: 'Bangers', cursive;
            font-size: 24px; margin-bottom: 5px; letter-spacing: 2px;
            text-align: center; text-shadow: 0 0 10px rgba(255,102,255,0.6);
        }
        .char-subtitle {
            color: #aaddff; font-size: 11px; text-align: center;
            margin-bottom: 15px; line-height: 1.3;
        }
        .char-card {
            background: rgba(100,30,60,0.4); border: 2px solid #cc44aa;
            border-radius: 12px; padding: 12px; margin-bottom: 12px;
            transition: all 0.2s;
        }
        .char-card:hover { background: rgba(120,40,80,0.6); border-color: #ff66ff; }
        .char-card-header {
            display: flex; align-items: center; gap: 10px;
            margin-bottom: 8px;
        }
        .char-card-emoji {
            font-size: 32px; line-height: 1;
        }
        .char-card-name {
            color: #ffd700; font-weight: bold; font-size: 16px;
            font-family: 'Bangers', cursive; letter-spacing: 1px;
        }
        .char-card-favs {
            background: rgba(0,0,0,0.3); border-radius: 8px;
            padding: 8px; margin-top: 6px;
        }
        .char-card-favs-title {
            color: #ff66ff; font-size: 11px; font-weight: bold;
            margin-bottom: 4px;
        }
        .char-fav-drink {
            color: #aaddff; font-size: 12px; padding: 2px 0;
            display: flex; align-items: center; gap: 5px;
        }
        #char-close-btn {
            background: rgba(100,30,60,0.6);
            border: 2px solid #ff66ff;
            color: #fff;
            font-family: 'Bangers', cursive;
            font-size: 16px;
            padding: 8px 20px;
            border-radius: 10px;
            cursor: pointer;
            margin-top: 12px;
            width: 100%;
            transition: all 0.2s;
        }
        #char-close-btn:hover {
            background: rgba(140,50,90,0.8);
            transform: scale(1.05);
        }

        /* ===== ABILITY BAR ===== */
        #ability-bar {
            position: absolute; bottom: 76px; left: 50%; transform: translateX(-50%);
            z-index: 100; display: flex; gap: 8px;
        }
        .ability-slot {
            width: 56px; height: 56px; position: relative;
            background: rgba(0,40,60,0.9); border: 2px solid #00aaff;
            border-radius: 12px; cursor: pointer; transition: all 0.15s;
            display: flex; flex-direction: column; align-items: center; justify-content: center;
            overflow: hidden;
        }
        .ability-slot:hover { border-color: #00ffff; transform: scale(1.1); box-shadow: 0 0 15px rgba(0,255,255,0.4); }
        .ability-slot:active { transform: scale(0.95); }
        .ability-slot.on-cooldown { opacity: 0.6; cursor: not-allowed; border-color: #555; }
        .ability-slot.on-cooldown:hover { transform: none; box-shadow: none; }
        .ability-slot.active-ability { border-color: #ffd700; box-shadow: 0 0 20px rgba(255,215,0,0.6); animation: abilityPulse 0.5s ease infinite; }
        @keyframes abilityPulse { 0%,100% { box-shadow: 0 0 15px rgba(255,215,0,0.4); } 50% { box-shadow: 0 0 25px rgba(255,215,0,0.8); } }
        .ability-icon { font-size: 22px; line-height: 1; }
        .ability-key {
            position: absolute; top: 2px; right: 4px;
            font-size: 9px; color: #88ccdd; font-weight: bold; font-family: 'Nunito', sans-serif;
        }
        .ability-cooldown-overlay {
            position: absolute; bottom: 0; left: 0; right: 0;
            background: rgba(0,0,0,0.7); height: 0%; transition: height 0.1s linear;
            pointer-events: none;
        }
        .ability-name { font-size: 8px; color: #88ccdd; margin-top: 1px; white-space: nowrap; }
        .ability-slot.locked { display: none; }

        /* ===== ACHIEVEMENT TOAST ===== */
        #ach-toast {
            position: absolute; top: -80px; left: 50%; transform: translateX(-50%);
            z-index: 400; background: rgba(0,0,0,0.95);
            border: 2px solid #ffd700; border-radius: 12px;
            padding: 10px 20px; display: flex; align-items: center; gap: 10px;
            transition: top 0.5s ease; white-space: nowrap;
            box-shadow: 0 0 30px rgba(255,215,0,0.5);
        }
        #ach-toast.show { top: 100px; }
        #ach-toast .toast-icon { font-size: 30px; }
        #ach-toast .toast-text { color: #ffd700; font-family: 'Bangers', cursive; font-size: 18px; letter-spacing: 1px; }

        /* ===== STREAK PANEL ===== */
        #streak-panel {
            position: absolute; right: -350px; top: 70px; bottom: 80px;
            width: 330px;
            background: linear-gradient(135deg, rgba(40,15,60,0.98) 0%, rgba(20,8,30,0.98) 100%);
            border-left: 3px solid #ff00ff;
            box-shadow: -5px 0 30px rgba(255,0,255,0.4);
            transition: right 0.3s ease;
            z-index: 200; overflow-y: auto; padding: 15px;
        }
        #streak-panel.open { right: 0; }
        #streak-panel h3 {
            color: #ff00ff; font-family: 'Bangers', cursive;
            font-size: 24px; margin-bottom: 10px; letter-spacing: 2px;
            text-align: center; text-shadow: 0 0 10px rgba(255,0,255,0.6);
        }
        .streak-card {
            background: rgba(80,20,100,0.4); border: 2px solid #aa00aa;
            border-radius: 12px; padding: 12px; margin-bottom: 12px;
            transition: all 0.2s;
        }
        .streak-card:hover { background: rgba(100,30,130,0.6); border-color: #ff00ff; }
        .streak-card-header {
            display: flex; justify-content: space-between; align-items: center;
            margin-bottom: 8px;
        }
        .streak-card-icon { font-size: 32px; }
        .streak-card-count {
            font-family: 'Bangers', cursive; font-size: 28px;
            color: #ff00ff; text-shadow: 0 0 10px rgba(255,0,255,0.6);
        }
        .streak-card-title {
            color: #ffd700; font-weight: bold; font-size: 14px;
            margin-bottom: 4px;
        }
        .streak-card-desc {
            color: #aaddff; font-size: 12px; line-height: 1.4;
            margin-bottom: 8px;
        }
        .streak-card-progress {
            background: rgba(0,0,0,0.4); border-radius: 8px;
            padding: 4px 8px; font-size: 11px; color: #88ccdd;
        }
        .streak-reward-banner {
            background: linear-gradient(135deg, #ff00ff 0%, #ff0088 100%);
            border: 2px solid #ffd700; border-radius: 10px;
            padding: 10px; text-align: center; margin-bottom: 12px;
            box-shadow: 0 0 20px rgba(255,0,255,0.5);
        }
        .streak-reward-banner .srb-title {
            font-family: 'Bangers', cursive; font-size: 16px;
            color: #ffd700; letter-spacing: 1px; margin-bottom: 4px;
        }
        .streak-reward-banner .srb-amount {
            font-family: 'Bangers', cursive; font-size: 20px;
            color: #fff; text-shadow: 0 0 10px rgba(0,0,0,0.8);
        }
        .streak-milestone {
            display: flex; justify-content: space-between; align-items: center;
            background: rgba(0,0,0,0.3); border-radius: 6px;
            padding: 6px 10px; margin-bottom: 6px; font-size: 12px;
        }
        .streak-milestone.achieved { background: rgba(0,255,136,0.2); border: 1px solid #00ff88; }
        .streak-milestone.achieved .sm-day { color: #00ff88; }
        .streak-milestone .sm-day { color: #ff00ff; font-weight: bold; }
        .streak-milestone .sm-reward { color: #ffd700; }
        #streak-close-btn {
            background: rgba(80,20,100,0.6);
            border: 2px solid #ff00ff;
            color: #fff;
            font-family: 'Bangers', cursive;
            font-size: 16px;
            padding: 8px 20px;
            border-radius: 10px;
            cursor: pointer;
            margin-top: 12px;
            width: 100%;
            transition: all 0.2s;
        }
        #streak-close-btn:hover {
            background: rgba(120,40,150,0.8);
            transform: scale(1.03);
        }
        .streak-hud-badge {
            background: linear-gradient(135deg, #ff00ff 0%, #aa00ff 100%);
            border: 2px solid #ffd700;
            border-radius: 20px;
            padding: 3px 10px;
            font-size: 13px;
            font-weight: bold;
            color: #fff;
            text-shadow: 0 0 8px rgba(0,0,0,0.8);
            box-shadow: 0 0 10px rgba(255,0,255,0.5);
            cursor: pointer;
            transition: transform 0.15s;
        }
        .streak-hud-badge:hover { transform: scale(1.1); }
        .streak-hud-badge:active { transform: scale(0.95); }
        
        /* ===== ACTIVE BONUSES PANEL ===== */
        #active-bonuses {
            position: absolute; bottom: 80px; right: 10px;
            max-width: 220px; z-index: 90;
            background: rgba(10,25,40,0.92);
            border: 2px solid #00ff88;
            border-radius: 10px; padding: 8px 10px;
            box-shadow: 0 0 15px rgba(0,255,136,0.3);
            display: none;
        }
        #active-bonuses.show { display: block; }
        #active-bonuses h4 {
            color: #00ff88; font-size: 11px; font-weight: bold;
            margin-bottom: 5px; text-align: center; letter-spacing: 1px;
        }
        .bonus-item {
            display: flex; align-items: center; gap: 5px;
            padding: 3px 0; font-size: 10px; color: #aaddff;
        }
        .bonus-item .bonus-icon { font-size: 14px; }
        
        /* ===== MINI-GAME OVERLAY ===== */
        #minigame-overlay {
            position: fixed; top: 0; left: 0; right: 0; bottom: 0;
            background: rgba(0,0,0,0.85); z-index: 500;
            display: none; align-items: center; justify-content: center;
        }
        #minigame-overlay.show { display: flex; }
        #minigame-container {
            background: linear-gradient(135deg, #1a0033 0%, #000011 100%);
            border: 4px solid #00ff88; border-radius: 20px;
            padding: 30px; max-width: 500px; width: 90%;
            box-shadow: 0 0 50px rgba(0,255,136,0.6);
        }
        #minigame-container h2 {
            font-family: 'Bangers', cursive; font-size: 32px;
            color: #00ff88; text-align: center; margin-bottom: 10px;
            letter-spacing: 2px; text-shadow: 0 0 15px rgba(0,255,136,0.8);
        }
        #minigame-desc {
            color: #aaddff; text-align: center; margin-bottom: 20px;
            font-size: 14px; line-height: 1.5;
        }
        #minigame-stage {
            background: rgba(0,0,0,0.6); border: 2px solid #00ff88;
            border-radius: 12px; padding: 20px; margin-bottom: 15px;
            min-height: 150px; display: flex; flex-direction: column;
            align-items: center; justify-content: center;
        }
        .sequence-display {
            display: flex; gap: 8px; margin-bottom: 20px;
        }
        .sequence-btn {
            width: 60px; height: 60px; border-radius: 12px;
            font-size: 28px; display: flex; align-items: center;
            justify-content: center; border: 3px solid transparent;
            cursor: pointer; transition: all 0.1s;
            background: rgba(255,255,255,0.1);
        }
        .sequence-btn.red { background: rgba(255,0,0,0.3); border-color: #ff0000; }
        .sequence-btn.blue { background: rgba(0,100,255,0.3); border-color: #0066ff; }
        .sequence-btn.green { background: rgba(0,255,0,0.3); border-color: #00ff00; }
        .sequence-btn.yellow { background: rgba(255,255,0,0.3); border-color: #ffff00; }
        .sequence-btn.active {
            transform: scale(1.2); box-shadow: 0 0 20px currentColor;
        }
        .sequence-btn:hover { transform: scale(1.1); }
        .sequence-btn:active { transform: scale(0.95); }
        #minigame-timer {
            font-family: 'Bangers', cursive; font-size: 24px;
            color: #ffd700; text-align: center; margin-bottom: 10px;
        }
        #minigame-score {
            font-size: 18px; color: #00ff88; text-align: center;
            font-weight: bold; margin-top: 10px;
        }
        .minigame-btn {
            background: linear-gradient(135deg, #00ff88 0%, #00aa66 100%);
            border: 2px solid #00ff88; border-radius: 12px;
            padding: 12px 30px; font-family: 'Bangers', cursive;
            font-size: 20px; color: #000; cursor: pointer;
            transition: all 0.2s; letter-spacing: 1px;
            box-shadow: 0 5px 15px rgba(0,255,136,0.3);
        }
        .minigame-btn:hover {
            transform: translateY(-3px);
            box-shadow: 0 8px 20px rgba(0,255,136,0.5);
        }
        .minigame-btn:active { transform: translateY(-1px); }
        .minigame-btn.cancel {
            background: linear-gradient(135deg, #ff4444 0%, #aa0000 100%);
            border-color: #ff4444; color: #fff;
            margin-left: 10px;
        }
        .minigame-btns {
            display: flex; justify-content: center; gap: 10px;
        }

        /* ===== PET SYSTEM ===== */
        #pet-panel {
            position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);
            z-index: 450; display: none;
            background: linear-gradient(135deg, #0a1a2a 0%, #051525 100%);
            border: 4px solid #ff88cc;
            border-radius: 20px;
            width: 420px; max-width: 90vw; max-height: 80vh;
            overflow-y: auto; padding: 20px;
            box-shadow: 0 0 40px rgba(255,136,204,0.3);
        }
        #pet-panel.show { display: block; }
        #pet-panel h2 {
            color: #ff88cc; font-family: 'Bangers', cursive; font-size: 26px;
            text-align: center; letter-spacing: 3px; margin-bottom: 5px;
        }
        #pet-panel .pet-subtitle {
            color: #aa7799; font-size: 12px; text-align: center; margin-bottom: 15px;
        }
        .pet-card {
            background: rgba(255,136,204,0.08); border: 2px solid rgba(255,136,204,0.3);
            border-radius: 12px; padding: 12px; margin-bottom: 10px;
            display: flex; align-items: center; gap: 12px;
            transition: all 0.2s;
        }
        .pet-card:hover { border-color: #ff88cc; background: rgba(255,136,204,0.15); }
        .pet-card.owned { border-color: #00ff88; background: rgba(0,255,136,0.08); }
        .pet-card.active { border-color: #ffd700; background: rgba(255,215,0,0.1); box-shadow: 0 0 15px rgba(255,215,0,0.2); }
        .pet-icon { font-size: 40px; min-width: 50px; text-align: center; }
        .pet-info { flex: 1; }
        .pet-name { color: #fff; font-weight: bold; font-size: 15px; }
        .pet-desc { color: #aaa; font-size: 11px; margin: 2px 0; }
        .pet-bonus { color: #ffd700; font-size: 12px; font-weight: bold; }
        .pet-btn {
            padding: 6px 14px; border-radius: 8px; cursor: pointer;
            font-weight: bold; font-size: 12px; border: 2px solid;
            transition: all 0.15s; white-space: nowrap;
        }
        .pet-btn:hover { transform: scale(1.05); }
        .pet-btn.buy { background: rgba(255,136,204,0.3); border-color: #ff88cc; color: #ff88cc; }
        .pet-btn.equip { background: rgba(0,255,136,0.3); border-color: #00ff88; color: #00ff88; }
        .pet-btn.active { background: rgba(255,215,0,0.3); border-color: #ffd700; color: #ffd700; }
        .pet-btn.locked { background: rgba(100,100,100,0.2); border-color: #555; color: #555; cursor: not-allowed; }
        .pet-close-btn {
            display: block; margin: 12px auto 0; padding: 8px 24px;
            background: rgba(255,136,204,0.3); border: 2px solid #ff88cc;
            border-radius: 8px; color: #ff88cc; cursor: pointer; font-weight: bold;
        }

        /* ===== LOYALTY / VIP REGULARS SYSTEM ===== */
        #loyalty-panel {
            position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);
            z-index: 450; display: none;
            background: linear-gradient(135deg, #0a1a2a 0%, #0d0820 100%);
            border: 4px solid #aa66ff;
            border-radius: 20px;
            width: 440px; max-width: 90vw; max-height: 80vh;
            overflow-y: auto; padding: 20px;
            box-shadow: 0 0 40px rgba(170,102,255,0.3);
        }
        #loyalty-panel.show { display: block; }
        #loyalty-panel h2 {
            color: #aa66ff; font-family: 'Bangers', cursive; font-size: 26px;
            text-align: center; letter-spacing: 3px; margin-bottom: 5px;
        }
        .loyalty-subtitle { color: #8866aa; font-size: 12px; text-align: center; margin-bottom: 12px; }
        #loyalty-summary {
            background: rgba(170,102,255,0.1); border: 1px solid rgba(170,102,255,0.3);
            border-radius: 10px; padding: 10px; margin-bottom: 12px; text-align: center;
        }
        .loyalty-total-stat { color: #ddd; font-size: 13px; margin: 3px 0; }
        .loyalty-total-stat strong { color: #ffd700; }
        .loyalty-card {
            background: rgba(170,102,255,0.06); border: 2px solid rgba(170,102,255,0.2);
            border-radius: 12px; padding: 12px; margin-bottom: 8px;
            display: flex; align-items: center; gap: 12px; transition: all 0.2s;
        }
        .loyalty-card:hover { border-color: #aa66ff; background: rgba(170,102,255,0.12); }
        .loyalty-card.tier-bronze { border-left: 4px solid #cd7f32; }
        .loyalty-card.tier-silver { border-left: 4px solid #c0c0c0; }
        .loyalty-card.tier-gold { border-left: 4px solid #ffd700; box-shadow: 0 0 10px rgba(255,215,0,0.15); }
        .loyalty-card.tier-platinum { border-left: 4px solid #e5e4e2; box-shadow: 0 0 15px rgba(229,228,226,0.2); }
        .loyalty-card.tier-diamond { border-left: 4px solid #b9f2ff; box-shadow: 0 0 20px rgba(185,242,255,0.25); }
        .loyalty-char { font-size: 36px; min-width: 46px; text-align: center; }
        .loyalty-info { flex: 1; }
        .loyalty-name { color: #fff; font-weight: bold; font-size: 14px; }
        .loyalty-tier { font-size: 11px; font-weight: bold; margin-left: 6px; }
        .loyalty-tier.bronze { color: #cd7f32; }
        .loyalty-tier.silver { color: #c0c0c0; }
        .loyalty-tier.gold { color: #ffd700; }
        .loyalty-tier.platinum { color: #e5e4e2; }
        .loyalty-tier.diamond { color: #b9f2ff; }
        .loyalty-visits { color: #aaa; font-size: 11px; }
        .loyalty-bonus { color: #00ff88; font-size: 11px; font-weight: bold; }
        .loyalty-progress-outer {
            height: 6px; background: rgba(255,255,255,0.1); border-radius: 3px;
            margin-top: 4px; overflow: hidden;
        }
        .loyalty-progress-inner { height: 100%; border-radius: 3px; transition: width 0.3s; }
        .loyalty-progress-inner.bronze { background: #cd7f32; }
        .loyalty-progress-inner.silver { background: #c0c0c0; }
        .loyalty-progress-inner.gold { background: #ffd700; }
        .loyalty-progress-inner.platinum { background: #e5e4e2; }
        .loyalty-progress-inner.diamond { background: #b9f2ff; }
        .loyalty-close-btn {
            display: block; margin: 12px auto 0; padding: 8px 24px;
            background: rgba(170,102,255,0.3); border: 2px solid #aa66ff;
            border-radius: 8px; color: #aa66ff; cursor: pointer; font-weight: bold;
        }
        @keyframes loyaltyGlow { 0%,100% { text-shadow: 0 0 4px currentColor; } 50% { text-shadow: 0 0 12px currentColor; } }

        /* ===== PRESTIGE SYSTEM ===== */
        #prestige-panel {
            position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);
            z-index: 450; display: none;
            background: linear-gradient(135deg, #1a0a2a 0%, #0a0515 100%);
            border: 4px solid #ffaa00;
            border-radius: 20px;
            padding: 25px 30px;
            max-width: 450px; width: 90%;
            box-shadow: 0 0 60px rgba(255,170,0,0.5);
            animation: prestigeIn 0.4s ease;
        }
        #prestige-panel.show { display: block; }
        @keyframes prestigeIn { from { transform: translate(-50%,-50%) scale(0.6); opacity: 0; } to { transform: translate(-50%,-50%) scale(1); opacity: 1; } }
        #prestige-panel h2 {
            font-family: 'Bangers', cursive; font-size: 32px;
            color: #ffaa00; text-align: center; margin-bottom: 8px;
            letter-spacing: 3px; text-shadow: 0 0 20px rgba(255,170,0,0.8);
        }
        #prestige-desc {
            color: #aaddff; text-align: center; font-size: 13px;
            line-height: 1.5; margin-bottom: 15px;
        }
        .prestige-stats {
            background: rgba(0,0,0,0.5); border-radius: 12px;
            padding: 15px; margin-bottom: 15px;
            border: 2px solid rgba(255,170,0,0.3);
        }
        .prestige-stats h4 {
            color: #ffd700; font-size: 14px; margin-bottom: 10px;
            text-align: center; font-weight: bold;
        }
        .prestige-stat-row {
            display: flex; justify-content: space-between;
            padding: 5px 0; font-size: 13px;
            border-bottom: 1px solid rgba(255,170,0,0.2);
        }
        .prestige-stat-row:last-child { border-bottom: none; }
        .prestige-stat-row .label { color: #88ccdd; }
        .prestige-stat-row .value { color: #00ff88; font-weight: bold; }
        .prestige-bonuses {
            background: linear-gradient(135deg, rgba(255,170,0,0.2) 0%, rgba(255,100,0,0.1) 100%);
            border: 2px solid #ffaa00; border-radius: 12px;
            padding: 15px; margin-bottom: 15px;
        }
        .prestige-bonuses h4 {
            color: #ffaa00; font-size: 14px; margin-bottom: 8px;
            text-align: center;
        }
        .prestige-bonus-item {
            display: flex; align-items: center; gap: 8px;
            padding: 5px 0; font-size: 12px; color: #ffd700;
        }
        .prestige-bonus-item .icon { font-size: 16px; }
        .prestige-earned {
            background: rgba(0,255,136,0.2); border: 2px solid #00ff88;
            border-radius: 12px; padding: 15px; margin-bottom: 15px;
            text-align: center;
        }
        .prestige-earned h4 {
            color: #00ff88; font-size: 14px; margin-bottom: 5px;
        }
        .prestige-earned .amount {
            font-family: 'Bangers', cursive; font-size: 36px;
            color: #ffd700; text-shadow: 0 0 15px rgba(255,215,0,0.6);
        }
        .prestige-earned .formula {
            font-size: 11px; color: #88ccdd; margin-top: 5px;
        }
        .prestige-req {
            color: #ff6666; font-size: 12px; text-align: center;
            margin-bottom: 15px; font-weight: bold;
        }
        .prestige-buttons {
            display: flex; justify-content: center; gap: 12px;
        }
        .prestige-btn {
            padding: 12px 24px; border-radius: 12px;
            font-family: 'Bangers', cursive; font-size: 18px;
            cursor: pointer; transition: all 0.2s;
            border: 2px solid; letter-spacing: 1px;
        }
        .prestige-btn.confirm {
            background: linear-gradient(135deg, #ffaa00 0%, #ff6600 100%);
            border-color: #ffaa00; color: #000;
            box-shadow: 0 5px 20px rgba(255,170,0,0.4);
        }
        .prestige-btn.confirm:hover { transform: translateY(-3px); box-shadow: 0 8px 25px rgba(255,170,0,0.6); }
        .prestige-btn.confirm:disabled { opacity: 0.4; cursor: not-allowed; transform: none; }
        .prestige-btn.cancel {
            background: rgba(80,80,80,0.8);
            border-color: #666; color: #aaa;
        }
        .prestige-btn.cancel:hover { background: rgba(100,100,100,0.9); }
        .prestige-hud-badge {
            background: linear-gradient(135deg, #ffaa00 0%, #ff6600 100%);
            border: 2px solid #ffd700;
            border-radius: 20px;
            padding: 3px 10px;
            font-size: 13px;
            font-weight: bold;
            color: #000;
            box-shadow: 0 0 10px rgba(255,170,0,0.5);
            cursor: pointer;
            transition: transform 0.15s;
        }
        .prestige-hud-badge:hover { transform: scale(1.1); }
        .prestige-hud-badge:active { transform: scale(0.95); }

        /* ===== ENHANCED PATIENCE INDICATOR ===== */
        @keyframes urgentPulse {
            0%, 100% { opacity: 1; transform: scale(1); }
            50% { opacity: 0.6; transform: scale(1.1); }
        }
        .patience-warning {
            position: absolute; pointer-events: none; z-index: 160;
            font-size: 24px; animation: urgentPulse 0.5s ease-in-out infinite;
        }

        /* ===== STATISTICS DASHBOARD ===== */
        #stats-panel {
            position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);
            z-index: 450; display: none;
            background: linear-gradient(135deg, #0a1a2a 0%, #051525 100%);
            border: 4px solid #00ccff;
            border-radius: 20px;
            padding: 20px 25px;
            max-width: 520px; width: 95%;
            max-height: 80vh;
            overflow-y: auto;
            box-shadow: 0 0 60px rgba(0,200,255,0.4);
            animation: statsIn 0.4s ease;
        }
        #stats-panel.show { display: block; }
        @keyframes statsIn { from { transform: translate(-50%,-50%) scale(0.6); opacity: 0; } to { transform: translate(-50%,-50%) scale(1); opacity: 1; } }
        #stats-panel h2 {
            font-family: 'Bangers', cursive; font-size: 28px;
            color: #00ccff; text-align: center; margin-bottom: 15px;
            letter-spacing: 3px; text-shadow: 0 0 15px rgba(0,200,255,0.6);
        }
        .stats-section {
            background: rgba(0,50,80,0.4); border: 2px solid rgba(0,200,255,0.3);
            border-radius: 12px; padding: 12px; margin-bottom: 12px;
        }
        .stats-section h4 {
            color: #00ccff; font-size: 14px; font-weight: bold;
            margin-bottom: 8px; display: flex; align-items: center; gap: 6px;
        }
        .stats-grid {
            display: grid; grid-template-columns: repeat(2, 1fr); gap: 8px;
        }
        .stat-card {
            background: rgba(0,0,0,0.4); border-radius: 8px;
            padding: 10px; text-align: center;
        }
        .stat-card .stat-value {
            font-family: 'Bangers', cursive; font-size: 22px;
            color: #00ff88; text-shadow: 0 0 8px rgba(0,255,136,0.5);
        }
        .stat-card .stat-label {
            font-size: 11px; color: #88ccdd; margin-top: 2px;
        }
        .stat-card.gold .stat-value { color: #ffd700; text-shadow: 0 0 8px rgba(255,215,0,0.5); }
        .stat-card.purple .stat-value { color: #ff00ff; text-shadow: 0 0 8px rgba(255,0,255,0.5); }
        .records-list {
            display: flex; flex-direction: column; gap: 6px;
        }
        .record-row {
            display: flex; justify-content: space-between; align-items: center;
            padding: 6px 10px; background: rgba(0,0,0,0.3); border-radius: 6px;
        }
        .record-row .record-label { color: #88ccdd; font-size: 12px; }
        .record-row .record-value { color: #ffd700; font-weight: bold; font-size: 13px; }
        .stats-close-btn {
            background: rgba(0,100,150,0.6); border: 2px solid #00ccff;
            color: #fff; font-family: 'Bangers', cursive; font-size: 16px;
            padding: 10px 25px; border-radius: 10px; cursor: pointer;
            width: 100%; margin-top: 10px; transition: all 0.2s;
        }
        .stats-close-btn:hover { background: rgba(0,150,200,0.8); transform: scale(1.02); }

        /* ===== SETTINGS MENU ===== */
        #settings-panel {
            position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);
            z-index: 450; display: none;
            background: linear-gradient(135deg, #1a1a2a 0%, #0a0a15 100%);
            border: 4px solid #888;
            border-radius: 20px;
            padding: 20px 25px;
            max-width: 400px; width: 90%;
            box-shadow: 0 0 50px rgba(100,100,100,0.4);
            animation: settingsIn 0.4s ease;
        }
        #settings-panel.show { display: block; }
        @keyframes settingsIn { from { transform: translate(-50%,-50%) scale(0.6); opacity: 0; } to { transform: translate(-50%,-50%) scale(1); opacity: 1; } }
        #settings-panel h2 {
            font-family: 'Bangers', cursive; font-size: 28px;
            color: #aaa; text-align: center; margin-bottom: 15px;
            letter-spacing: 3px;
        }
        .settings-group {
            background: rgba(50,50,60,0.4); border: 1px solid rgba(150,150,150,0.3);
            border-radius: 10px; padding: 12px; margin-bottom: 12px;
        }
        .settings-group h4 {
            color: #aaa; font-size: 13px; font-weight: bold; margin-bottom: 10px;
        }
        .setting-row {
            display: flex; justify-content: space-between; align-items: center;
            padding: 8px 0; border-bottom: 1px solid rgba(100,100,100,0.2);
        }
        .setting-row:last-child { border-bottom: none; }
        .setting-row .setting-label { color: #ccc; font-size: 13px; }
        .setting-row input[type="range"] {
            width: 120px; accent-color: #00ff88;
        }
        .setting-row input[type="checkbox"] {
            width: 20px; height: 20px; accent-color: #00ff88;
        }
        .setting-row select {
            background: rgba(0,0,0,0.5); border: 1px solid #666;
            color: #fff; padding: 5px 10px; border-radius: 5px;
        }
        .settings-buttons {
            display: flex; gap: 10px; margin-top: 15px;
        }
        .settings-btn {
            flex: 1; padding: 10px 15px; border-radius: 10px;
            font-family: 'Bangers', cursive; font-size: 16px;
            cursor: pointer; border: 2px solid; transition: all 0.2s;
        }
        .settings-btn.save {
            background: linear-gradient(135deg, #00ff88 0%, #00aa66 100%);
            border-color: #00ff88; color: #000;
        }
        .settings-btn.save:hover { transform: translateY(-2px); }
        .settings-btn.close {
            background: rgba(80,80,80,0.8); border-color: #666; color: #aaa;
        }
        .settings-btn.close:hover { background: rgba(100,100,100,0.9); }
        .settings-btn.danger {
            background: rgba(150,30,30,0.8); border-color: #ff4444; color: #fff;
        }
        .settings-btn.danger:hover { background: rgba(200,50,50,0.9); }
        .volume-display {
            color: #00ff88; font-size: 12px; min-width: 35px; text-align: right;
        }

        /* ===== TIP JAR SYSTEM ===== */
        #tip-jar {
            position: absolute; bottom: 85px; right: 15px;
            z-index: 95; cursor: pointer;
            background: linear-gradient(135deg, rgba(20,40,60,0.95) 0%, rgba(10,20,30,0.95) 100%);
            border: 3px solid #ffd700;
            border-radius: 15px;
            padding: 10px 15px;
            box-shadow: 0 0 20px rgba(255,215,0,0.3);
            transition: all 0.2s;
            text-align: center;
            min-width: 90px;
        }
        #tip-jar:hover {
            transform: scale(1.05);
            box-shadow: 0 0 30px rgba(255,215,0,0.5);
        }
        #tip-jar.glow {
            animation: jarGlow 0.5s ease-in-out;
        }
        @keyframes jarGlow {
            0%, 100% { box-shadow: 0 0 20px rgba(255,215,0,0.3); }
            50% { box-shadow: 0 0 40px rgba(255,215,0,0.8); }
        }
        #tip-jar .jar-icon { font-size: 28px; }
        #tip-jar .jar-amount {
            font-family: 'Bangers', cursive;
            font-size: 18px;
            color: #ffd700;
            text-shadow: 0 0 8px rgba(255,215,0,0.5);
        }
        #tip-jar .jar-label {
            font-size: 10px;
            color: #aaa;
            margin-top: 2px;
        }
        #tip-jar .jar-fill {
            position: absolute; bottom: 0; left: 0; right: 0;
            background: linear-gradient(0deg, rgba(255,215,0,0.3) 0%, transparent 100%);
            border-radius: 0 0 12px 12px;
            transition: height 0.3s;
            pointer-events: none;
        }
        #tip-jar.ready { border-color: #00ff88; }
        #tip-jar.ready .jar-amount { color: #00ff88; }

        /* ===== CUSTOMER REVIEWS ===== */
        #review-popup {
            position: absolute; bottom: 160px; right: 15px;
            z-index: 96;
            background: rgba(10,20,30,0.95);
            border: 2px solid #00ccff;
            border-radius: 12px;
            padding: 10px 15px;
            max-width: 220px;
            box-shadow: 0 0 20px rgba(0,200,255,0.3);
            display: none;
            animation: reviewIn 0.4s ease;
        }
        #review-popup.show { display: block; }
        @keyframes reviewIn {
            from { transform: translateX(50px); opacity: 0; }
            to { transform: translateX(0); opacity: 1; }
        }
        #review-popup .review-header {
            display: flex; align-items: center; gap: 8px;
            margin-bottom: 6px;
        }
        #review-popup .review-char { font-size: 24px; }
        #review-popup .review-name {
            font-weight: bold; color: #ffd700; font-size: 13px;
        }
        #review-popup .review-stars {
            font-size: 14px; margin-bottom: 4px;
        }
        #review-popup .review-text {
            color: #aaddff; font-size: 12px; font-style: italic;
            line-height: 1.4;
        }
        #review-popup .review-stars.great { color: #00ff88; }
        #review-popup .review-stars.okay { color: #ffaa00; }
        #review-popup .review-stars.bad { color: #ff4444; }

        /* ===== BAR RATING DISPLAY ===== */
        #bar-rating {
            position: absolute; top: 95px; right: 15px;
            z-index: 95;
            background: rgba(10,20,30,0.9);
            border: 2px solid #ffd700;
            border-radius: 10px;
            padding: 6px 12px;
            text-align: center;
        }
        #bar-rating .rating-stars {
            font-size: 16px;
            letter-spacing: 2px;
        }
        #bar-rating .rating-label {
            font-size: 10px;
            color: #aaa;
        }
        #bar-rating .rating-count {
            font-size: 11px;
            color: #88ccdd;
        }

        /* ===== HAPPY HOUR BANNER ===== */
        #happy-hour-banner {
            position: absolute; top: 58px; left: 50%; transform: translateX(-50%);
            z-index: 200;
            background: linear-gradient(135deg, #ff6600 0%, #ffaa00 50%, #ff6600 100%);
            background-size: 200% 100%;
            animation: happyHourShimmer 2s linear infinite;
            border: 3px solid #ffd700;
            border-radius: 25px;
            padding: 8px 20px;
            display: none;
            box-shadow: 0 0 30px rgba(255,170,0,0.6);
        }
        #happy-hour-banner.show { display: flex; align-items: center; gap: 10px; }
        @keyframes happyHourShimmer {
            0% { background-position: 200% 0; }
            100% { background-position: -200% 0; }
        }
        #happy-hour-banner .hh-icon { font-size: 24px; animation: bounce 0.5s ease-in-out infinite alternate; }
        @keyframes bounce {
            0% { transform: translateY(0); }
            100% { transform: translateY(-3px); }
        }
        #happy-hour-banner .hh-text {
            font-family: 'Bangers', cursive;
            font-size: 18px;
            color: #000;
            letter-spacing: 2px;
            text-shadow: 0 0 5px rgba(255,255,255,0.5);
        }
        #happy-hour-banner .hh-timer {
            font-family: 'Bangers', cursive;
            font-size: 16px;
            color: #fff;
            background: rgba(0,0,0,0.5);
            padding: 2px 10px;
            border-radius: 10px;
        }
        #happy-hour-banner .hh-bonus {
            font-size: 12px;
            color: #000;
            font-weight: bold;
        }

        /* ===== TOOLTIPS ===== */
        .game-tooltip {
            position: absolute;
            z-index: 500;
            background: rgba(10,20,30,0.95);
            border: 2px solid #00ff88;
            border-radius: 8px;
            padding: 8px 12px;
            max-width: 200px;
            pointer-events: none;
            opacity: 0;
            transform: translateY(5px);
            transition: opacity 0.2s, transform 0.2s;
            box-shadow: 0 0 15px rgba(0,255,136,0.3);
        }
        .game-tooltip.show {
            opacity: 1;
            transform: translateY(0);
        }
        .game-tooltip .tooltip-title {
            font-family: 'Bangers', cursive;
            font-size: 14px;
            color: #ffd700;
            margin-bottom: 4px;
        }
        .game-tooltip .tooltip-desc {
            font-size: 11px;
            color: #aaddff;
            line-height: 1.4;
        }
        .game-tooltip .tooltip-shortcut {
            font-size: 10px;
            color: #888;
            margin-top: 4px;
            font-style: italic;
        }

        /* ===== DIALOGUE OVERLAY ===== */
        #dialogue-overlay {
            position: absolute; bottom: 0; left: 0; right: 0; height: 180px;
            background: linear-gradient(180deg, rgba(10,15,30,0.95) 0%, rgba(5,10,20,0.98) 100%);
            border-top: 3px solid #ffd700;
            box-shadow: 0 -5px 30px rgba(0,0,0,0.8);
            z-index: 600; display: none;
            padding: 15px 20px;
            animation: slideUp 0.3s ease-out;
        }
        #dialogue-overlay.show { display: flex; gap: 20px; align-items: flex-start; }
        @keyframes slideUp { from { transform: translateY(100%); } to { transform: translateY(0); } }
        
        .dialogue-portrait {
            width: 120px; height: 140px;
            background: rgba(0,0,0,0.3);
            border: 2px solid #00ff88; border-radius: 12px;
            overflow: hidden; flex-shrink: 0;
            position: relative;
        }
        .dialogue-portrait img {
            width: 100%; height: 100%; object-fit: cover;
            transition: transform 0.2s;
        }
        .dialogue-portrait.talking img { transform: scale(1.05); }
        
        .dialogue-content { flex: 1; position: relative; height: 100%; display: flex; flex-direction: column; }
        .dialogue-name {
            font-family: 'Bangers', cursive; font-size: 24px; color: #ffd700;
            margin-bottom: 8px; letter-spacing: 1px;
            text-shadow: 2px 2px 0 #000;
        }
        .dialogue-text {
            color: #fff; font-size: 16px; line-height: 1.5;
            margin-bottom: 15px; flex: 1;
            overflow-y: auto;
        }
        .dialogue-choices {
            display: flex; gap: 10px; flex-wrap: wrap;
        }
        .dialogue-choice {
            background: rgba(0,60,80,0.6); border: 2px solid #00ff88;
            border-radius: 8px; padding: 8px 16px;
            color: #fff; font-size: 14px; cursor: pointer;
            transition: all 0.2s;
        }
        .dialogue-choice:hover {
            background: rgba(0,100,120,0.8); transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(0,255,136,0.3);
        }
        .dialogue-continue {
            position: absolute; bottom: 10px; right: 10px;
            color: #ffd700; font-size: 14px;
            animation: blink 1s infinite; cursor: pointer;
        }
        @keyframes blink { 50% { opacity: 0.5; } }

        /* ===== LEVEL UP OVERLAY ===== */
        #levelup-overlay {
            position: absolute; top: 0; left: 0; right: 0; bottom: 0;
            background: rgba(0,0,0,0.85); z-index: 700;
            display: none; align-items: center; justify-content: center;
            animation: fadeIn 0.3s ease;
        }
        #levelup-overlay.show { display: flex; }
        .levelup-box {
            background: linear-gradient(135deg, #2a0a3a 0%, #1a0525 100%);
            border: 4px solid #ffd700; border-radius: 20px;
            padding: 30px 50px; text-align: center;
            box-shadow: 0 0 80px rgba(255,215,0,0.6);
            transform: scale(0.8); animation: popIn 0.4s cubic-bezier(0.175, 0.885, 0.32, 1.275) forwards;
            max-width: 500px; width: 90%;
        }
        .levelup-box h1 {
            font-family: 'Bangers', cursive; font-size: 48px;
            color: #ffd700; letter-spacing: 4px;
            text-shadow: 0 0 20px #ff6600; margin-bottom: 10px;
        }
        .levelup-badge {
            font-family: 'Bangers', cursive; font-size: 80px;
            color: #fff; text-shadow: 0 0 20px #00ff88;
            margin: 10px 0 20px 0;
            animation: pulse 1s infinite;
        }
        .levelup-rewards { margin-bottom: 25px; max-height: 200px; overflow-y: auto; }
        .levelup-rewards h3 { color: #00ff88; font-family: 'Bangers', cursive; letter-spacing: 2px; margin-bottom: 10px; }
        .levelup-item {
            display: flex; align-items: center; justify-content: center; gap: 10px;
            color: #fff; font-size: 16px; margin: 5px 0;
            padding: 8px; background: rgba(255,255,255,0.1); border-radius: 8px;
            border: 1px solid rgba(255,215,0,0.3);
        }
        .levelup-item .icon { font-size: 24px; }
        @keyframes popIn { to { transform: scale(1); } }

        /* ===== FLYING COIN ===== */
        .flying-coin {
            position: absolute; font-size: 24px; z-index: 800; pointer-events: none;
            transition: all 0.8s cubic-bezier(0.25, 0.1, 0.25, 1);
        }

        /* ===== WELCOME BACK POPUP ===== */
        #welcome-back-overlay {
            display: none; position: fixed; top: 0; left: 0; right: 0; bottom: 0;
            background: rgba(0,0,0,0.85); z-index: 10000;
            justify-content: center; align-items: center;
        }
        #welcome-back-overlay.show { display: flex; }
        .welcome-back-box {
            background: linear-gradient(135deg, #0a1628, #1a0a30);
            border: 3px solid #00ff88; border-radius: 20px;
            padding: 30px 40px; text-align: center; max-width: 380px;
            box-shadow: 0 0 40px rgba(0,255,136,0.3), inset 0 0 30px rgba(0,255,136,0.05);
            animation: popIn 0.4s ease-out;
        }
        @keyframes popIn { from { transform: scale(0.5); opacity: 0; } to { transform: scale(1); opacity: 1; } }
        .wb-title { font-family: 'Bangers', cursive; font-size: 28px; color: #ffd700; margin-bottom: 5px; letter-spacing: 2px; }
        .wb-subtitle { color: #aaa; font-size: 13px; margin-bottom: 18px; }
        .wb-earnings { display: flex; flex-direction: column; gap: 10px; margin-bottom: 20px; }
        .wb-row { display: flex; justify-content: space-between; align-items: center; background: rgba(0,255,136,0.08); padding: 10px 16px; border-radius: 10px; border: 1px solid rgba(0,255,136,0.2); }
        .wb-row-label { color: #88ccaa; font-size: 14px; }
        .wb-row-value { color: #ffd700; font-weight: 900; font-size: 18px; }
        .wb-collect-btn {
            padding: 12px 40px; border-radius: 12px; border: 2px solid #ffd700;
            background: linear-gradient(135deg, #4a3000, #2a1a00); color: #ffd700;
            font-family: 'Bangers', cursive; font-size: 20px; cursor: pointer;
            letter-spacing: 2px; transition: all 0.2s;
        }
        .wb-collect-btn:hover { transform: scale(1.05); box-shadow: 0 0 20px rgba(255,215,0,0.4); }

        /* ===== ACTIVE EVENT TIMER ===== */
        #active-event-bar {
            position: absolute; top: 60px; left: 50%; transform: translateX(-50%);
            background: rgba(10,15,30,0.9); border: 2px solid #ffd700;
            border-radius: 10px; padding: 8px 16px; z-index: 300;
            display: none; align-items: center; gap: 10px;
            font-size: 14px; color: #fff;
            box-shadow: 0 0 20px rgba(255,215,0,0.3);
            min-width: 250px;
        }
        #active-event-bar.show { display: flex; }
        .event-timer-name { font-weight: 900; color: #ffd700; font-family: 'Bangers', cursive; letter-spacing: 1px; }
        .event-timer-track { flex: 1; height: 6px; background: rgba(255,255,255,0.2); border-radius: 3px; overflow: hidden; }
        .event-timer-fill { height: 100%; border-radius: 3px; transition: width 0.5s linear; }
        .event-timer-time { font-size: 12px; color: #aaa; min-width: 30px; text-align: right; }

        /* ===== RECIPE BOOK ===== */
        #recipe-book {
            position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);
            width: 650px; max-width: 95vw; max-height: 80vh;
            background: linear-gradient(135deg, #1a0a2e 0%, #0d0520 100%);
            border: 3px solid #ffd700; border-radius: 16px;
            box-shadow: 0 0 60px rgba(255,215,0,0.3);
            z-index: 600; display: none; overflow: hidden;
            animation: popIn 0.3s ease forwards;
        }
        #recipe-book.show { display: block; }
        .recipe-header {
            background: linear-gradient(90deg, #2a1a3e, #1a0a2e);
            padding: 15px 20px; display: flex; justify-content: space-between; align-items: center;
            border-bottom: 2px solid rgba(255,215,0,0.3);
        }
        .recipe-header h2 { font-family: 'Bangers', cursive; color: #ffd700; font-size: 28px; letter-spacing: 2px; }
        .recipe-list {
            overflow-y: auto; max-height: calc(80vh - 70px); padding: 15px;
            display: grid; grid-template-columns: 1fr 1fr; gap: 10px;
        }
        .recipe-card {
            background: rgba(255,255,255,0.05); border: 2px solid rgba(255,255,255,0.1);
            border-radius: 12px; padding: 12px; cursor: pointer;
            transition: all 0.2s;
        }
        .recipe-card:hover { border-color: #ffd700; transform: translateY(-2px); box-shadow: 0 4px 15px rgba(255,215,0,0.2); }
        .recipe-card.locked { opacity: 0.4; filter: grayscale(0.8); }
        .recipe-card.locked:hover { transform: none; border-color: rgba(255,255,255,0.1); }
        .recipe-card-header { display: flex; align-items: center; gap: 10px; margin-bottom: 8px; }
        .recipe-icon { font-size: 32px; }
        .recipe-name { font-weight: 900; color: #fff; font-size: 14px; }
        .recipe-level { font-size: 11px; color: #aaa; }
        .recipe-stats { display: flex; gap: 12px; font-size: 12px; color: #aaa; }
        .recipe-stats span { display: flex; align-items: center; gap: 3px; }
        .recipe-lore { font-size: 12px; color: #88aacc; font-style: italic; margin-top: 6px; line-height: 1.4; }
        .recipe-color-bar { height: 3px; border-radius: 2px; margin-top: 8px; }

        /* ===== SPECIAL EVENT BANNER ===== */
        .event-banner {
            position: absolute;
            top: 0; left: 0; right: 0; bottom: 0;
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 800;
            pointer-events: none;
            opacity: 0;
            transition: opacity 0.3s ease;
        }
        .event-banner.show { opacity: 1; }
        .event-banner-content {
            background: linear-gradient(135deg, rgba(10,15,40,0.95) 0%, rgba(5,10,30,0.98) 100%);
            border: 4px solid #ffd700;
            border-radius: 20px;
            padding: 30px 60px;
            text-align: center;
            box-shadow: 0 0 60px rgba(255,215,0,0.5), inset 0 0 40px rgba(255,255,255,0.05);
            transform: scale(0.5);
            animation: eventPop 0.5s cubic-bezier(0.175, 0.885, 0.32, 1.275) forwards;
        }
        @keyframes eventPop {
            0% { transform: scale(0.5) rotate(-5deg); }
            50% { transform: scale(1.1) rotate(2deg); }
            100% { transform: scale(1) rotate(0deg); }
        }
        .event-name {
            font-family: 'Bangers', cursive;
            font-size: 48px;
            letter-spacing: 3px;
            text-shadow: 0 0 20px currentColor, 3px 3px 0 #000;
            margin-bottom: 10px;
            animation: eventGlow 1s ease infinite alternate;
        }
        @keyframes eventGlow {
            from { filter: brightness(1); }
            to { filter: brightness(1.3); }
        }
        .event-desc {
            font-size: 18px;
            color: #fff;
            text-shadow: 1px 1px 0 #000;
            max-width: 400px;
        }

        /* ===== SKILL TREE ===== */
        #skill-tree-container {
            padding: 10px;
        }
        .skill-tree-header {
            text-align: center; margin-bottom: 12px;
        }
        .skill-tree-header h3 { color: #ffd700; font-family: 'Bangers', cursive; font-size: 22px; letter-spacing: 2px; }
        .skill-tree-header .skill-points { color: #00ff88; font-size: 14px; }
        .skill-branches {
            display: flex; gap: 12px; justify-content: center; flex-wrap: wrap;
        }
        .skill-branch {
            flex: 1; min-width: 200px; max-width: 280px;
            background: rgba(0,30,50,0.7);
            border: 2px solid rgba(0,255,136,0.3);
            border-radius: 12px; padding: 10px;
        }
        .skill-branch-title {
            text-align: center; font-family: 'Bangers', cursive;
            font-size: 16px; letter-spacing: 1px; margin-bottom: 8px;
            padding-bottom: 6px; border-bottom: 1px solid rgba(255,255,255,0.1);
        }
        .skill-branch.speed .skill-branch-title { color: #00ccff; }
        .skill-branch.charm .skill-branch-title { color: #ff66cc; }
        .skill-branch.mixology .skill-branch-title { color: #ffaa00; }
        .skill-node {
            display: flex; align-items: center; gap: 8px;
            padding: 6px 8px; margin: 4px 0;
            border-radius: 8px; cursor: pointer;
            border: 2px solid rgba(255,255,255,0.1);
            background: rgba(0,0,0,0.3);
            transition: all 0.2s;
        }
        .skill-node:hover { border-color: rgba(255,255,255,0.3); background: rgba(0,60,80,0.4); }
        .skill-node.unlocked { border-color: #00ff88; background: rgba(0,100,60,0.3); }
        .skill-node.locked { opacity: 0.5; cursor: not-allowed; }
        .skill-node.available { border-color: #ffd700; animation: skillPulse 2s infinite; }
        @keyframes skillPulse {
            0%, 100% { box-shadow: 0 0 5px rgba(255,215,0,0.2); }
            50% { box-shadow: 0 0 15px rgba(255,215,0,0.5); }
        }
        .skill-icon { font-size: 22px; }
        .skill-info { flex: 1; }
        .skill-name { font-size: 12px; font-weight: bold; color: #fff; }
        .skill-desc { font-size: 10px; color: #aaa; }
        .skill-cost { font-size: 11px; color: #ffd700; white-space: nowrap; }
        .skill-connector {
            width: 2px; height: 8px; background: rgba(255,255,255,0.15);
            margin: 0 auto;
        }
        .skill-connector.active { background: #00ff88; }

        /* ===== RUSH METER ===== */
        #rush-meter {
            position: absolute; top: 72px; left: 15px;
            z-index: 100;
            background: rgba(40,0,0,0.9);
            border: 2px solid #ff4400;
            border-radius: 12px;
            padding: 6px 14px;
            text-align: center;
            box-shadow: 0 0 20px rgba(255,68,0,0.3);
            animation: rush-glow 1s ease infinite;
        }
        @keyframes rush-glow {
            0%, 100% { box-shadow: 0 0 15px rgba(255,68,0,0.3); }
            50% { box-shadow: 0 0 25px rgba(255,68,0,0.6); }
        }
        #rush-label {
            font-family: 'Bangers', cursive;
            font-size: 18px; color: #ff6600;
            letter-spacing: 2px;
        }
        #rush-bar-outer {
            width: 120px; height: 6px;
            background: rgba(0,0,0,0.5);
            border-radius: 3px; overflow: hidden;
            margin: 4px auto;
        }
        #rush-bar-fill {
            height: 100%; width: 0%;
            background: linear-gradient(90deg, #ff4400, #ff8800, #ffcc00);
            transition: width 0.3s;
            border-radius: 3px;
        }
        #rush-bonus {
            font-size: 10px; color: #ffaa66;
        }

        /* ===== SPACE FORECAST WIDGET ===== */
        #space-forecast {
            position: absolute; top: 72px; right: 15px;
            z-index: 100;
            background: rgba(0,20,40,0.9);
            border: 2px solid rgba(0,255,136,0.5);
            border-radius: 12px;
            padding: 6px 14px;
            display: flex; align-items: center; gap: 8px;
            font-size: 13px; color: #fff;
            box-shadow: 0 0 15px rgba(0,255,136,0.15);
            transition: border-color 0.5s, box-shadow 0.5s;
        }
        #space-forecast.solar-flare { border-color: #ff8800; box-shadow: 0 0 20px rgba(255,136,0,0.3); }
        #space-forecast.meteor-shower { border-color: #00ccff; box-shadow: 0 0 20px rgba(0,204,255,0.3); }
        #space-forecast.nebula-storm { border-color: #cc44ff; box-shadow: 0 0 20px rgba(204,68,255,0.3); }
        #space-forecast.ion-storm { border-color: #4488ff; box-shadow: 0 0 20px rgba(68,136,255,0.3); }
        #space-forecast.cosmic-calm { border-color: #44ffaa; box-shadow: 0 0 20px rgba(68,255,170,0.3); }
        #space-forecast.gravity-wave { border-color: #ff44aa; box-shadow: 0 0 20px rgba(255,68,170,0.3); }
        #forecast-icon { font-size: 20px; }
        #forecast-name { font-family: 'Bangers', cursive; letter-spacing: 1px; font-size: 14px; }
        #forecast-effect { font-size: 11px; color: #aaa; }
        #forecast-timer-bar {
            position: absolute; bottom: 0; left: 8px; right: 8px;
            height: 3px; background: rgba(255,255,255,0.1);
            border-radius: 2px; overflow: hidden;
        }
        #forecast-timer-fill {
            height: 100%; width: 100%;
            background: linear-gradient(90deg, #00ff88, #00ccff);
            transition: width 1s linear;
            border-radius: 2px;
        }
        @keyframes forecast-pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.6; }
        }
        #space-forecast .forecast-changing { animation: forecast-pulse 0.3s ease 3; }

        /* ===== BOUNTY BOARD ===== */
        #bounty-panel {
            position: absolute; top: -500px; left: 50%; transform: translateX(-50%);
            width: min(420px, 90vw); max-height: 70vh; overflow-y: auto;
            background: linear-gradient(180deg, rgba(20,10,5,0.98) 0%, rgba(10,5,2,0.98) 100%);
            border: 3px solid #ff8800; border-radius: 16px;
            box-shadow: 0 0 40px rgba(255,136,0,0.5);
            z-index: 300; padding: 20px;
            transition: top 0.4s ease;
        }
        #bounty-panel.open { top: 80px; }
        #bounty-panel h3 {
            color: #ff8800; font-family: 'Bangers', cursive;
            font-size: 26px; margin-bottom: 4px; letter-spacing: 2px; text-align: center;
        }
        .bounty-card {
            background: rgba(80,40,0,0.3); border: 2px solid #664400;
            border-radius: 12px; padding: 14px; margin-bottom: 12px; transition: all 0.3s;
        }
        .bounty-card.active { border-color: #ff8800; box-shadow: 0 0 15px rgba(255,136,0,0.3); }
        .bounty-card.completed { border-color: #00ff88; background: rgba(0,80,40,0.3); }
        .bounty-card.expired { opacity: 0.4; }
        .bounty-title { color: #ffd700; font-size: 16px; font-weight: bold; margin-bottom: 4px; }
        .bounty-desc { color: #ccaa77; font-size: 13px; margin-bottom: 8px; }
        .bounty-reward { color: #00ff88; font-size: 13px; font-weight: bold; }
        .bounty-timer { color: #ff6644; font-size: 11px; float: right; }
        .bounty-progress { height: 6px; background: rgba(0,0,0,0.5); border-radius: 3px; margin-top: 6px; overflow: hidden; }
        .bounty-progress-fill { height: 100%; background: linear-gradient(90deg, #ff8800, #ffd700); border-radius: 3px; transition: width 0.3s; }
        .bounty-accept-btn {
            margin-top: 8px; padding: 6px 16px; background: linear-gradient(180deg, #ff8800, #cc6600);
            border: 2px solid #ffd700; border-radius: 8px; color: #fff; font-weight: bold;
            cursor: pointer; font-size: 13px;
        }
        .bounty-accept-btn:hover { transform: scale(1.05); }
    </style>
</head>
<body>

<!-- LOADING -->
<div id="loading">
    <h1> ORION'S BARREL </h1>
    <div class="tagline">Where hungover heroes drink among the stars</div>
    <div class="load-bar"><div class="load-fill" id="load-fill"></div></div>
    <div class="load-text" id="load-text">Warming up the fusion reactor...</div>
</div>

<!-- GAME -->
<div id="welcome-back-overlay">
    <div class="welcome-back-box">
        <div class="wb-title"> WELCOME BACK!</div>
        <div class="wb-subtitle" id="wb-time-away">You were away for a while...</div>
        <div class="wb-earnings">
            <div class="wb-row"><span class="wb-row-label"> Idle Credits</span><span class="wb-row-value" id="wb-credits">+0</span></div>
            <div class="wb-row"><span class="wb-row-label"> Idle XP</span><span class="wb-row-value" id="wb-xp">+0</span></div>
            <div class="wb-row"><span class="wb-row-label"> Bar Rating</span><span class="wb-row-value" id="wb-rating">-</span></div>
        </div>
        <button class="wb-collect-btn" id="wb-collect"> COLLECT</button>
    </div>
</div>
<div id="game-container" style="display:none">
    <canvas id="game-canvas"></canvas>

    <!-- HUD -->
    <div id="hud">
        <div class="hud-left">
            <div class="hud-stat"><span class="hud-icon"></span><div><strong id="hud-credits">100</strong> Cr</div></div>
            <div class="hud-stat"><span class="hud-icon"></span><div>Lv <strong id="hud-level">1</strong></div></div>
            <div class="hud-stat"><span class="hud-icon"></span><div>XP <strong id="hud-xp">0</strong>/<strong id="hud-xpmax">100</strong></div></div>
            <div class="hud-stat"><span class="hud-icon"></span><div>Rep <strong id="hud-rep">50</strong></div></div>
            <div class="streak-hud-badge" id="streak-badge" title="Click to view streaks!"> <span id="hud-streak">0</span></div>
            <div class="prestige-hud-badge" id="prestige-badge" title="Click to prestige!"> <span id="hud-prestige">0</span></div>
            <div class="hud-stat daily-special-hud" id="daily-special-badge" title="Today's Special Drink  +50% bonus!" style="background:rgba(80,60,0,0.9);border-color:#ffd700;cursor:pointer;animation:specialPulse 2s ease-in-out infinite;" onclick="showDailySpecialInfo()">
                <span class="hud-icon"></span><div><strong id="hud-daily-special">...</strong></div>
            </div>
        </div>
        <div class="hud-right">
            <div class="ctrl-btn" id="btn-zoomout"></div>
            <div class="ctrl-btn" id="btn-zoomin">+</div>
        </div>
    </div>

    <!-- Reputation bar -->
    <div id="rep-bar-wrap">
        <div id="rep-bar-label"> Bar Reputation</div>
        <div id="rep-bar-outer"><div id="rep-bar-inner"></div></div>
    </div>

    <!-- Rush Meter -->
    <div id="rush-meter" style="display:none">
        <div id="rush-label"> RUSH!</div>
        <div id="rush-bar-outer"><div id="rush-bar-fill"></div></div>
        <div id="rush-bonus">Clear all orders for bonus!</div>
    </div>

    <!-- Space Forecast Widget -->
    <div id="space-forecast" title="Current space weather conditions">
        <span id="forecast-icon"></span>
        <span id="forecast-name">Clear Skies</span>
        <span id="forecast-effect"></span>
        <div id="forecast-timer-bar"><div id="forecast-timer-fill"></div></div>
    </div>

    <!-- Space News Ticker -->
    <div id="news-ticker">
        <span class="ticker-label"> SPACE NEWS</span>
        <div class="ticker-scroll">
            <span id="ticker-text"></span>
        </div>
    </div>

    <!-- Ability Bar -->
    <div id="ability-bar">
        <div class="ability-slot" id="ability-0" onclick="activateAbility(0)" title="Hyper Mix [Z]  3x prep speed for 8s">
            <div class="ability-icon"></div>
            <div class="ability-key">Z</div>
            <div class="ability-cooldown-overlay" id="ability-cd-0"></div>
            <div class="ability-name">Hyper Mix</div>
        </div>
        <div class="ability-slot" id="ability-1" onclick="activateAbility(1)" title="Charm Wave [X]  All customers +30 happiness">
            <div class="ability-icon"></div>
            <div class="ability-key">X</div>
            <div class="ability-cooldown-overlay" id="ability-cd-1"></div>
            <div class="ability-name">Charm Wave</div>
        </div>
        <div class="ability-slot" id="ability-2" onclick="activateAbility(2)" title="Gold Rush [V]  Next 5 serves give 3x tips">
            <div class="ability-icon"></div>
            <div class="ability-key">V</div>
            <div class="ability-cooldown-overlay" id="ability-cd-2"></div>
            <div class="ability-name">Gold Rush</div>
        </div>
    </div>

    <!-- Bottom action bar -->
    <div id="bottom-bar">
        <div class="bottom-btn" id="btn-shop"> SHOP</div>
        <div class="bottom-btn" id="btn-inv"> INVENTORY</div>
        <div class="bottom-btn" id="btn-menu"> MENU</div>
        <div class="bottom-btn" id="btn-quests"> QUESTS</div>
        <div class="bottom-btn" id="btn-daily"> DAILY</div>
        <div class="bottom-btn" id="btn-bounty" onclick="toggleBountyBoard()"> BOUNTY</div>
        <div class="bottom-btn" id="btn-chars"> CHARS</div>
        <div class="bottom-btn" id="btn-minigame"> GAME</div>
        <div class="bottom-btn" id="btn-spin" onclick="openSpinWheel()"> SPIN</div>
        <div class="bottom-btn" id="btn-speed"> x1</div>
        <div class="bottom-btn" id="btn-mastery" onclick="toggleMasteryPanel()"></div>
        <div class="bottom-btn" id="btn-recipes" onclick="toggleRecipeBook()"></div>
        <div class="bottom-btn" id="btn-pets" onclick="togglePetPanel()"></div>
        <div class="bottom-btn" id="btn-loyalty" onclick="toggleLoyaltyPanel()"> VIP</div>
        <div class="bottom-btn" id="btn-ach"></div>
        <div class="bottom-btn" id="btn-lb"></div>
        <div class="bottom-btn" id="btn-stats"></div>
        <div class="bottom-btn" id="btn-staff" onclick="toggleStaffPanel()"> STAFF</div>
        <div class="bottom-btn" id="btn-settings"></div>
    </div>

    <!-- Staff Panel -->
    <div id="staff-panel" style="display:none;position:fixed;top:50%;left:50%;transform:translate(-50%,-50%);width:420px;max-height:80vh;background:linear-gradient(135deg,rgba(10,20,50,0.98),rgba(20,10,40,0.98));border:2px solid #00bfff;border-radius:16px;z-index:2000;overflow-y:auto;padding:20px;box-shadow:0 0 40px rgba(0,191,255,0.4);">
        <h2 style="color:#00bfff;font-family:'Bangers',cursive;font-size:28px;text-align:center;letter-spacing:3px;margin-bottom:4px;text-shadow:0 0 15px rgba(0,191,255,0.5);"> HIRE STAFF </h2>
        <p style="color:#88aacc;font-size:12px;text-align:center;margin-bottom:14px;">Staff auto-serve customers & boost your bar!</p>
        <div id="staff-list"></div>
        <button onclick="toggleStaffPanel()" style="display:block;margin:14px auto 0;background:rgba(0,191,255,0.2);border:2px solid #00bfff;color:#fff;padding:8px 28px;border-radius:8px;cursor:pointer;font-size:14px;font-family:'Nunito',sans-serif;">CLOSE</button>
    </div>

    <!-- Tip Jar -->
    <div id="tip-jar" title="Click to collect tips!">
        <div class="jar-fill" id="jar-fill"></div>
        <div class="jar-icon"></div>
        <div class="jar-amount" id="jar-amount">0</div>
        <div class="jar-label">TIP JAR</div>
    </div>

    <!-- Customer Review Popup -->
    <div id="review-popup">
        <div class="review-header">
            <span class="review-char" id="review-char"></span>
            <span class="review-name" id="review-name">Customer</span>
        </div>
        <div class="review-stars" id="review-stars"></div>
        <div class="review-text" id="review-text">"Great service!"</div>
    </div>

    <!-- Bar Rating Display -->
    <div id="bar-rating">
        <div class="rating-stars" id="rating-stars"></div>
        <div class="rating-label">BAR RATING</div>
        <div class="rating-count" id="rating-count">0 reviews</div>
    </div>

    <!-- Happy Hour Banner -->
    <div id="happy-hour-banner">
        <span class="hh-icon"></span>
        <span class="hh-text">HAPPY HOUR!</span>
        <span class="hh-timer" id="hh-timer">2:00</span>
        <span class="hh-bonus">2x Tips & XP</span>
    </div>

    <!-- Tooltip Container -->
    <div class="game-tooltip" id="game-tooltip">
        <div class="tooltip-title" id="tooltip-title">Button</div>
        <div class="tooltip-desc" id="tooltip-desc">Description</div>
        <div class="tooltip-shortcut" id="tooltip-shortcut"></div>
    </div>

    <!-- Shop -->
    <div id="shop-panel">
        <div class="shop-tabs">
            <div class="shop-tab active" data-tab="furniture"> Furniture</div>
            <div class="shop-tab" data-tab="upgrades"> Upgrades</div>
            <div class="shop-tab" data-tab="decorations"> Decor</div>
            <div class="shop-tab" data-tab="skills"> Skills</div>
        </div>
        <div class="shop-grid" id="shop-grid"></div>
        <div id="skill-tree-container" style="display:none"></div>
    </div>

    <!-- Inventory panel -->
    <div id="inv-panel">
        <h3> INVENTORY</h3>
        <div class="inv-grid" id="inv-grid"></div>
    </div>

    <!-- Placement banner -->
    <div id="placement-banner"> Click on the floor to place  ESC to cancel</div>

    <!-- Drink menu popup -->
    <div id="drink-menu">
        <h4> SERVE A DRINK</h4>
        <div id="drink-options"></div>
    </div>

    <!-- Notification -->
    <div id="notification"></div>

    <!-- Event log -->
    <div id="event-log"></div>

    <!-- Save indicator -->
    <div id="save-indicator"> Saved</div>

    <!-- Space Jukebox -->
    <div id="jukebox-btn" onclick="toggleJukebox()"> Jukebox</div>
    <div id="jukebox-panel">
        <h4> SPACE JUKEBOX</h4>
        <div id="jukebox-stations"></div>
        <input type="range" id="jukebox-vol" min="0" max="100" value="40" oninput="setJukeboxVolume(this.value)">
        <div class="juke-off-btn" onclick="stopJukebox()"> Turn Off</div>
    </div>

    <!-- Spin Wheel Overlay -->
    <div id="spin-overlay" style="display:none; position:absolute; top:0; left:0; right:0; bottom:0; z-index:500; background:rgba(0,0,0,0.85); align-items:center; justify-content:center;">
        <div style="text-align:center; position:relative;">
            <h2 style="color:#ffd700; font-family:'Bangers',cursive; font-size:32px; letter-spacing:3px; margin-bottom:10px; text-shadow:0 0 20px rgba(255,215,0,0.6);"> LUCKY SPIN </h2>
            <div id="spin-subtitle" style="color:#88ccdd; font-size:13px; margin-bottom:15px;">Free spin available!</div>
            <div style="position:relative; display:inline-block;">
                <canvas id="spin-canvas" width="320" height="320" style="border-radius:50%; box-shadow:0 0 40px rgba(255,215,0,0.4);"></canvas>
                <div style="position:absolute; top:-5px; left:50%; transform:translateX(-50%); font-size:32px; pointer-events:none; filter:drop-shadow(0 0 8px rgba(255,0,0,0.8)); z-index:10;"></div>
            </div>
            <br>
            <button id="spin-btn" onclick="doSpin()" style="margin-top:15px; padding:12px 40px; font-family:'Bangers',cursive; font-size:22px; letter-spacing:2px; background:linear-gradient(180deg,#ffd700,#ff8800); border:3px solid #fff; border-radius:12px; cursor:pointer; color:#000; box-shadow:0 0 20px rgba(255,215,0,0.5);">SPIN!</button>
            <br>
            <button onclick="closeSpinWheel()" style="margin-top:10px; padding:6px 20px; background:rgba(255,255,255,0.1); border:1px solid #666; border-radius:8px; color:#aaa; cursor:pointer; font-size:13px;">Close</button>
            <div id="spin-result" style="color:#00ff88; font-size:18px; font-weight:bold; margin-top:10px; min-height:24px;"></div>
        </div>
    </div>

    <!-- Drink Mastery Panel -->
    <div id="mastery-panel">
        <h3> DRINK MASTERY</h3>
        <div id="mastery-subtitle">Serve drinks to level up your mastery  faster prep & better tips!</div>
        <div id="mastery-total-summary"></div>
        <div id="mastery-list"></div>
        <button id="mastery-close-btn" onclick="toggleMasteryPanel()">CLOSE</button>
    </div>

    <!-- Combo display -->
    <div id="combo-display"></div>

    <!-- Day/Night overlay -->
    <div id="daynight-overlay"></div>
    <div id="time-display"> Night Shift</div>

    <!-- Achievements panel -->
    <div id="achievements-panel">
        <h3> ACHIEVEMENTS</h3>
        <div id="ach-list"></div>
    </div>

    <!-- Leaderboard panel -->
    <div id="leaderboard-panel">
        <h3> LEADERBOARD</h3>
        <div id="lb-list"></div>
    </div>

    <!-- Daily Challenges Panel -->
    <div id="bounty-panel">
        <h3> BOUNTY BOARD</h3>
        <div style="color:#aa8855; font-size:12px; text-align:center; margin-bottom:12px;">Timed contracts from across the galaxy. Accept & complete for big rewards!</div>
        <div id="bounty-list"></div>
        <button onclick="toggleBountyBoard()" style="display:block; margin:10px auto 0; padding:6px 20px; background:rgba(255,136,0,0.3); border:2px solid #ff8800; border-radius:8px; color:#ff8800; cursor:pointer; font-weight:bold;">CLOSE</button>
    </div>

    <div id="daily-panel">
        <h3> DAILY CHALLENGES</h3>
        <div id="daily-subtitle">Fresh challenges every day!</div>
        <div id="daily-list"></div>
        <div class="daily-rewards">
            <div class="daily-rewards-title"> Complete All Challenges</div>
            <div class="daily-rewards-text">Bonus: <span id="daily-bonus">200</span> Credits + <span id="daily-bonus-xp">100</span> XP!</div>
        </div>
        <button id="daily-close-btn">CLOSE</button>
    </div>

    <!-- Story Quests Panel -->
    <div id="quests-panel">
        <h3> STORY QUESTS</h3>
        <div id="quest-subtitle">Help Walter and the crew!</div>
        <div id="quest-list"></div>
        <button id="quests-close-btn">CLOSE</button>
    </div>

    <!-- Active Event Timer -->
    <div id="active-event-bar">
        <span class="event-timer-name" id="event-timer-name"> EVENT</span>
        <div class="event-timer-track">
            <div class="event-timer-fill" id="event-timer-fill" style="width:100%; background:#ffd700"></div>
        </div>
        <span class="event-timer-time" id="event-timer-time">30s</span>
    </div>

    <!-- Random Event Banner (legacy - now using dynamic .event-banner) -->
    <div id="event-banner" style="display:none!important"></div>

    <!-- Achievement Toast -->
    <div id="ach-toast">
        <div class="toast-icon" id="toast-icon"></div>
        <div class="toast-text" id="toast-text">Achievement Unlocked!</div>
    </div>

    <!-- Streak Panel -->
    <div id="streak-panel">
        <h3> STREAKS </h3>
        <div id="streak-list"></div>
        <button id="streak-close-btn">CLOSE</button>
    </div>

    <!-- Prestige Panel -->
    <!-- Pet Panel -->
    <div id="pet-panel">
        <h2> SPACE PETS </h2>
        <div class="pet-subtitle">Adopt an alien pet! They wander the bar and give you passive bonuses.</div>
        <div id="pet-list"></div>
        <button class="pet-close-btn" onclick="togglePetPanel()">CLOSE</button>
    </div>

    <!-- Loyalty Panel -->
    <div id="loyalty-panel">
        <h2> VIP REGULARS </h2>
        <div class="loyalty-subtitle">Your most loyal customers! Regulars tip more, wait longer, and love your bar.</div>
        <div id="loyalty-summary"></div>
        <div id="loyalty-list"></div>
        <button class="loyalty-close-btn" onclick="toggleLoyaltyPanel()">CLOSE</button>
    </div>

    <div id="prestige-panel">
        <h2> PRESTIGE RESET </h2>
        <div id="prestige-desc">
            Start fresh with permanent bonuses! Your achievements, streaks, and character favorites will be preserved.
        </div>
        <div class="prestige-stats">
            <h4> Current Progress</h4>
            <div class="prestige-stat-row"><span class="label">Level</span><span class="value" id="p-level">1</span></div>
            <div class="prestige-stat-row"><span class="label">Total Drinks</span><span class="value" id="p-drinks">0</span></div>
            <div class="prestige-stat-row"><span class="label">Credits Earned</span><span class="value" id="p-earned">0</span></div>
            <div class="prestige-stat-row"><span class="label">Current Prestige</span><span class="value" id="p-current">0</span></div>
        </div>
        <div class="prestige-earned">
            <h4> PRESTIGE POINTS TO EARN</h4>
            <div class="amount" id="p-points">0</div>
            <div class="formula">Based on Level + Drinks + Earnings</div>
        </div>
        <div class="prestige-bonuses">
            <h4> Permanent Bonuses (per point)</h4>
            <div class="prestige-bonus-item"><span class="icon"></span> +50 Starting Credits</div>
            <div class="prestige-bonus-item"><span class="icon"></span> +5% XP Multiplier</div>
            <div class="prestige-bonus-item"><span class="icon"></span> +3% Tip Bonus</div>
            <div class="prestige-bonus-item"><span class="icon"></span> +5 Starting Reputation</div>
        </div>
        <div class="prestige-req" id="p-req"></div>
        <div class="prestige-buttons">
            <button class="prestige-btn confirm" id="prestige-confirm" disabled>PRESTIGE NOW</button>
            <button class="prestige-btn cancel" id="prestige-cancel">CANCEL</button>
        </div>
    </div>

    <!-- Statistics Dashboard -->
    <div id="stats-panel">
        <h2> STATISTICS </h2>
        
        <div class="stats-section">
            <h4> Lifetime Service</h4>
            <div class="stats-grid">
                <div class="stat-card">
                    <div class="stat-value" id="stats-total-served">0</div>
                    <div class="stat-label">Total Drinks Served</div>
                </div>
                <div class="stat-card gold">
                    <div class="stat-value" id="stats-total-earned">0</div>
                    <div class="stat-label">Credits Earned (All Time)</div>
                </div>
                <div class="stat-card">
                    <div class="stat-value" id="stats-vips-served">0</div>
                    <div class="stat-label">VIPs Served</div>
                </div>
                <div class="stat-card purple">
                    <div class="stat-value" id="stats-perfect-serves">0</div>
                    <div class="stat-label">Perfect Serves (100%)</div>
                </div>
            </div>
        </div>

        <div class="stats-section">
            <h4> Personal Records</h4>
            <div class="records-list">
                <div class="record-row">
                    <span class="record-label"> Best Combo</span>
                    <span class="record-value" id="stats-best-combo">0x</span>
                </div>
                <div class="record-row">
                    <span class="record-label"> Highest Level Reached</span>
                    <span class="record-value" id="stats-highest-level">1</span>
                </div>
                <div class="record-row">
                    <span class="record-label"> Most Credits Held</span>
                    <span class="record-value" id="stats-max-credits">0</span>
                </div>
                <div class="record-row">
                    <span class="record-label"> Best Reputation</span>
                    <span class="record-value" id="stats-max-rep">0</span>
                </div>
                <div class="record-row">
                    <span class="record-label"> Longest Login Streak</span>
                    <span class="record-value" id="stats-best-streak">0 days</span>
                </div>
            </div>
        </div>

        <div class="stats-section">
            <h4> Prestige & Progress</h4>
            <div class="stats-grid">
                <div class="stat-card gold">
                    <div class="stat-value" id="stats-prestige-count">0</div>
                    <div class="stat-label">Times Prestiged</div>
                </div>
                <div class="stat-card">
                    <div class="stat-value" id="stats-prestige-points">0</div>
                    <div class="stat-label">Total Prestige Points</div>
                </div>
                <div class="stat-card">
                    <div class="stat-value" id="stats-achievements">0</div>
                    <div class="stat-label">Achievements Unlocked</div>
                </div>
                <div class="stat-card">
                    <div class="stat-value" id="stats-stars-caught">0</div>
                    <div class="stat-label"> Stars Caught</div>
                </div>
                <div class="stat-card purple">
                    <div class="stat-value" id="stats-quests">0</div>
                    <div class="stat-label">Quests Completed</div>
                </div>
            </div>
        </div>

        <div class="stats-section">
            <h4> Play Time</h4>
            <div class="records-list">
                <div class="record-row">
                    <span class="record-label"> Days Played</span>
                    <span class="record-value" id="stats-days-played">0</span>
                </div>
                <div class="record-row">
                    <span class="record-label"> Session Count</span>
                    <span class="record-value" id="stats-sessions">0</span>
                </div>
            </div>
        </div>

        <button class="stats-close-btn" id="stats-close-btn">CLOSE</button>
    </div>

    <!-- Settings Menu -->
    <div id="settings-panel">
        <h2> SETTINGS </h2>

        <div class="settings-group">
            <h4> Sound</h4>
            <div class="setting-row">
                <span class="setting-label">Master Volume</span>
                <input type="range" id="setting-volume" min="0" max="100" value="50">
                <span class="volume-display" id="volume-display">50%</span>
            </div>
            <div class="setting-row">
                <span class="setting-label">Sound Effects</span>
                <input type="checkbox" id="setting-sfx" checked>
            </div>
            <div class="setting-row">
                <span class="setting-label">Music</span>
                <input type="checkbox" id="setting-music">
            </div>
        </div>

        <div class="settings-group">
            <h4> Gameplay</h4>
            <div class="setting-row">
                <span class="setting-label">Auto-Save Interval</span>
                <select id="setting-autosave">
                    <option value="30">30 seconds</option>
                    <option value="60" selected>1 minute</option>
                    <option value="120">2 minutes</option>
                    <option value="300">5 minutes</option>
                </select>
            </div>
            <div class="setting-row">
                <span class="setting-label">Show Tips</span>
                <input type="checkbox" id="setting-tips" checked>
            </div>
            <div class="setting-row">
                <span class="setting-label">Particle Effects</span>
                <input type="checkbox" id="setting-particles" checked>
            </div>
        </div>

        <div class="settings-group">
            <h4> Display</h4>
            <div class="setting-row">
                <span class="setting-label">Show Event Log</span>
                <input type="checkbox" id="setting-eventlog" checked>
            </div>
            <div class="setting-row">
                <span class="setting-label">Show Combo Counter</span>
                <input type="checkbox" id="setting-combo" checked>
            </div>
        </div>

        <div class="settings-buttons">
            <button class="settings-btn save" id="settings-save"> SAVE</button>
            <button class="settings-btn close" id="settings-close">CANCEL</button>
        </div>

        <div class="settings-group" style="margin-top: 15px; border-color: rgba(255,100,100,0.3);">
            <h4> Danger Zone</h4>
            <button class="settings-btn danger" id="settings-reset" style="width: 100%;"> RESET ALL DATA</button>
        </div>
    </div>

    <!-- Character Guide Panel -->
    <div id="char-panel">
        <h3> CHARACTER FAVORITES</h3>
        <div class="char-subtitle">Each character has favorite drinks that give +50% rewards!</div>
        <div id="char-list"></div>
        <button id="char-close-btn">CLOSE</button>
    </div>

    <!-- Active Decoration Bonuses -->
    <div id="active-bonuses">
        <h4> ACTIVE BONUSES</h4>
        <div id="bonus-list"></div>
    </div>

    <!-- Mini-Game Overlay -->
    <div id="minigame-overlay">
        <div id="minigame-container">
            <!-- Game Selection Screen -->
            <div id="minigame-select">
                <h2> ARCADE </h2>
                <div id="minigame-desc">Pick a mini-game!</div>
                <div style="display:flex;flex-direction:column;gap:12px;margin:20px 0;">
                    <button class="minigame-btn" onclick="selectMiniGame('sequence')" style="width:100%;padding:16px;font-size:18px;">
                         Color Sequence
                        <div style="font-size:12px;color:#aaddff;margin-top:4px;">Memorize & repeat the pattern!</div>
                    </button>
                    <button class="minigame-btn" onclick="selectMiniGame('catch')" style="width:100%;padding:16px;font-size:18px;">
                         Ingredient Catch
                        <div style="font-size:12px;color:#aaddff;margin-top:4px;">Catch falling ingredients to mix drinks!</div>
                    </button>
                    <button class="minigame-btn" onclick="selectMiniGame('darts')" style="width:100%;padding:16px;font-size:18px;">
                         Space Darts
                        <div style="font-size:12px;color:#aaddff;margin-top:4px;">Time your throw to hit the bullseye!</div>
                    </button>
                </div>
                <button class="minigame-btn cancel" id="minigame-close">BACK</button>
            </div>
            <!-- Color Sequence Game -->
            <div id="minigame-sequence" style="display:none;">
                <h2> COLOR SEQUENCE </h2>
                <div style="color:#aaddff;text-align:center;margin-bottom:12px;font-size:14px;">Match the sequence as fast as you can!</div>
                <div id="minigame-stage">
                    <div id="minigame-timer">Ready...</div>
                    <div class="sequence-display" id="sequence-display"></div>
                    <div id="minigame-score">Score: 0</div>
                </div>
                <div class="minigame-btns">
                    <button class="minigame-btn" id="minigame-start">START CHALLENGE</button>
                    <button class="minigame-btn cancel" onclick="backToArcade()">BACK</button>
                </div>
            </div>
            <!-- Ingredient Catch Game -->
            <div id="minigame-catch" style="display:none;">
                <h2> INGREDIENT CATCH </h2>
                <div style="color:#aaddff;text-align:center;margin-bottom:8px;font-size:14px;">Click the ingredients in order to mix the drink!</div>
                <div id="catch-recipe" style="text-align:center;margin-bottom:8px;font-size:16px;color:#ffd700;"></div>
                <div id="catch-stage" style="position:relative;width:100%;height:250px;background:rgba(0,0,0,0.6);border:2px solid #00ff88;border-radius:12px;overflow:hidden;cursor:crosshair;">
                    <canvas id="catch-canvas" width="440" height="250" style="width:100%;height:100%;"></canvas>
                </div>
                <div style="display:flex;justify-content:space-between;margin-top:8px;">
                    <div id="catch-timer" style="color:#00ff88;font-family:'Bangers',cursive;font-size:20px;"> 45s</div>
                    <div id="catch-score" style="color:#ffd700;font-family:'Bangers',cursive;font-size:20px;">Score: 0</div>
                    <div id="catch-drinks" style="color:#ff66ff;font-family:'Bangers',cursive;font-size:20px;"> 0</div>
                </div>
                <div class="minigame-btns" style="margin-top:10px;">
                    <button class="minigame-btn" id="catch-start-btn" onclick="startCatchGame()">START!</button>
                    <button class="minigame-btn cancel" onclick="backToArcade()">BACK</button>
                </div>
            </div>
            <!-- Space Darts Game -->
            <div id="minigame-darts" style="display:none;">
                <h2> SPACE DARTS </h2>
                <div style="color:#aaddff;text-align:center;margin-bottom:8px;font-size:14px;">Click when the marker hits the bullseye!</div>
                <div id="darts-round-info" style="text-align:center;color:#ffd700;font-family:'Bangers',cursive;font-size:18px;margin-bottom:6px;">Round 1 / 3  Throw 1 / 3</div>
                <div style="position:relative;width:300px;height:300px;margin:0 auto;">
                    <canvas id="darts-canvas" width="300" height="300" style="width:100%;height:100%;cursor:pointer;border-radius:50%;"></canvas>
                </div>
                <div style="display:flex;justify-content:center;gap:20px;margin-top:10px;">
                    <div id="darts-score" style="color:#ffd700;font-family:'Bangers',cursive;font-size:22px;">Score: 0</div>
                </div>
                <div id="darts-result" style="text-align:center;color:#00ff88;font-size:16px;min-height:24px;margin-top:4px;"></div>
                <div class="minigame-btns" style="margin-top:10px;">
                    <button class="minigame-btn" id="darts-start-btn" onclick="startDartsGame()">THROW!</button>
                    <button class="minigame-btn cancel" onclick="backToArcade()">BACK</button>
                </div>
            </div>
        </div>
    </div>

    <!-- Tutorial -->
    <div id="tutorial">
        <div class="tut-box">
            <h1>ORION'S BARREL</h1>
            <div class="subtitle">"Where a hungover alien saved the dinosaurs"</div>
            <div class="chars">
                <img src="assets/new/mary-front.png" class="char-preview" alt="Mary">
                <img src="assets/new/walter-front-v2.png" class="char-preview" alt="Walter">
                <img src="assets/new/carl-front.png" class="char-preview" alt="Carl">
                <img src="assets/new/scally-front.png" class="char-preview" alt="Scally">
            </div>
            <p> <b>Click customers</b> () to take their orders</p>
            <p> <b>Choose drinks</b>  fancier = more credits & XP</p>
            <p> <b>Serve fast</b> before they lose patience! Click when it says SERVE!</p>
            <p> Earn credits  buy upgrades & furniture from the <b>SHOP</b></p>
            <p> Watch for <b>VIP customers</b>  they tip 2.5x more!</p>
            <p> The bar cycles through <b>day & night</b>  Happy Hour = more customers!</p>
            <p> <b>Random events</b> keep things interesting  bar fights, celebrity visits...</p>
            <p> Unlock <b>achievements</b> and climb the <b>leaderboard</b>!</p>
            <button class="tut-btn" onclick="startGame()">OPEN THE BAR!</button>
        </div>
    </div>

    <!-- DIALOGUE OVERLAY -->
    <div id="dialogue-overlay">
        <div class="dialogue-portrait">
            <img id="dialogue-img" src="assets/new/walter-front-v2.png">
        </div>
        <div class="dialogue-content">
            <div class="dialogue-name" id="dialogue-name">Walter</div>
            <div class="dialogue-text" id="dialogue-text">...</div>
            <div class="dialogue-choices" id="dialogue-choices"></div>
            <div class="dialogue-continue" id="dialogue-continue" onclick="advanceDialogue()">Click to continue...</div>
        </div>
    </div>

    <!-- RECIPE BOOK -->
    <div id="recipe-book">
        <div class="recipe-header">
            <h2> RECIPE BOOK</h2>
            <button class="close-btn" onclick="document.getElementById('recipe-book').classList.remove('show')"></button>
        </div>
        <div style="display:flex;gap:6px;margin:0 15px 10px;justify-content:center">
            <button class="recipe-tab active" onclick="showRecipeTab('drinks')" id="rtab-drinks" style="padding:6px 16px;border-radius:8px;border:2px solid #00ff88;background:rgba(0,255,136,0.2);color:#fff;cursor:pointer;font-weight:bold"> Drinks</button>
            <button class="recipe-tab" onclick="showRecipeTab('synergy')" id="rtab-synergy" style="padding:6px 16px;border-radius:8px;border:2px solid #ff00ff;background:rgba(255,0,255,0.1);color:#aaa;cursor:pointer;font-weight:bold"> Synergies</button>
        </div>
        <div class="recipe-list" id="recipe-list"></div>
        <div class="recipe-list" id="synergy-list" style="display:none"></div>
    </div>

    <!-- LEVEL UP OVERLAY -->
    <div id="levelup-overlay">
        <div class="levelup-box">
            <h1>LEVEL UP!</h1>
            <div class="levelup-badge" id="levelup-badge">1</div>
            <div class="levelup-rewards">
                <h3>UNLOCKED:</h3>
                <div id="levelup-list"></div>
            </div>
            <button class="tut-btn" onclick="closeLevelUp()">CONTINUE</button>
        </div>
    </div>
</div>

<script>
// ===================================================================
//  ORION'S BARREL  Space Bar Manager v2.0
// ===================================================================

// ==================== DATA ====================
const DRINKS = {
    cosmic_martini:  { name: 'Cosmic Martini',  icon: '', color: '#ff00ff', time: 4,  price: 20,  xp: 8,   level: 1 },
    nebula_shot:     { name: 'Nebula Shot',     icon: '', color: '#00ffff', time: 3,  price: 15,  xp: 6,   level: 1 },
    rocket_fuel:     { name: 'Rocket Fuel',     icon: '', color: '#ff6600', time: 6,  price: 35,  xp: 14,  level: 1 },
    starlight_fizz:  { name: 'Starlight Fizz',  icon: '', color: '#ffff00', time: 8,  price: 50,  xp: 22,  level: 3 },
    void_brew:       { name: 'Void Brew',       icon: '', color: '#9900ff', time: 10, price: 70,  xp: 30,  level: 5 },
    solar_punch:     { name: 'Solar Punch',     icon: '', color: '#ff9900', time: 12, price: 90,  xp: 40,  level: 7 },
    moon_milk:       { name: 'Moon Milk',       icon: '', color: '#ccffff', time: 8,  price: 60,  xp: 25,  level: 4 },
    gravity_well:    { name: 'Gravity Well',    icon: '', color: '#4400ff', time: 15, price: 130, xp: 55,  level: 9 },
    dinosaur_daiquiri: { name: 'Dino Daiquiri', icon: '', color: '#44ff44', time: 10, price: 85,  xp: 35,  level: 6 },
    big_bang:        { name: 'The Big Bang',    icon: '', color: '#ff0044', time: 20, price: 200, xp: 80,  level: 10 },
    warp_whiskey:    { name: 'Warp Whiskey',    icon: '', color: '#cc6600', time: 5,  price: 25,  xp: 10,  level: 2 },
    plasma_punch:    { name: 'Plasma Punch',    icon: '', color: '#ff33cc', time: 7,  price: 45,  xp: 18,  level: 3 },
    aurora_ale:      { name: 'Aurora Ale',      icon: '', color: '#33ffaa', time: 4,  price: 18,  xp: 7,   level: 1 },
    quasar_cooler:   { name: 'Quasar Cooler',   icon: '', color: '#66ccff', time: 9,  price: 55,  xp: 24,  level: 4 },
    pulsar_mojito:   { name: 'Pulsar Mojito',   icon: '', color: '#33ff66', time: 11, price: 80,  xp: 33,  level: 6 },
    dark_matter:     { name: 'Dark Matter',     icon: '', color: '#330066', time: 14, price: 110, xp: 48,  level: 8 },
    supernova_sour:  { name: 'Supernova Sour',  icon: '', color: '#ffff33', time: 18, price: 160, xp: 65,  level: 9 },
    walters_regret:  { name: "Walter's Regret", icon: '', color: '#ff6633', time: 25, price: 250, xp: 100, level: 12 },
    // NEW EXOTIC DRINKS - High tier specialties
    quantum_cola:    { name: 'Quantum Cola',    icon: '', color: '#00ddff', time: 13, price: 95,  xp: 42,  level: 8 },
    black_hole_brew: { name: 'Black Hole Brew', icon: '', color: '#000033', time: 16, price: 140, xp: 60,  level: 10 },
    comet_tail:      { name: 'Comet Tail',      icon: '', color: '#ffaa33', time: 10, price: 75,  xp: 32,  level: 5 },
    galaxy_swirl:    { name: 'Galaxy Swirl',    icon: '', color: '#cc33ff', time: 17, price: 175, xp: 70,  level: 11 },
    alien_absinthe:  { name: 'Alien Absinthe',  icon: '', color: '#33ff33', time: 19, price: 190, xp: 75,  level: 11 },
    time_warp_tea:   { name: 'Time Warp Tea',   icon: '', color: '#8844ff', time: 22, price: 220, xp: 90,  level: 13 },
};

const FURNITURE = {
    small_table:  { name: 'Small Table',  icon: '', price: 0,    level: 1, seats: 2 },
    booth:        { name: 'Cozy Booth',   icon: '', price: 150,  level: 2, seats: 3 },
    medium_table: { name: 'Round Table',  icon: '', price: 300,  level: 3, seats: 4 },
    vip_booth:    { name: 'VIP Booth',    icon: '', price: 600,  level: 5, seats: 4 },
    large_table:  { name: 'Long Table',   icon: '', price: 800,  level: 7, seats: 6 },
    // NEW FURNITURE
    poker_table:  { name: 'Poker Table',  icon: '', price: 1000, level: 8, seats: 6, 
                    bonus: { type: 'tips', value: 1.1, desc: 'Gamblers tip 10% more' } },
    dance_floor:  { name: 'Dance Floor',  icon: '', price: 1500, level: 10, seats: 8,
                    bonus: { type: 'happiness', value: 15, desc: 'Dancing = +15 happiness' },
                    light: { color: 'rainbow', radius: 100, spin: true } },
    hover_seats:  { name: 'Hover Seats',  icon: '', price: 1200, level: 9, seats: 4,
                    bonus: { type: 'patience', value: 0.85, desc: 'Comfy! 15% slower patience' } },
    karaoke_stage:{ name: 'Karaoke Stage',icon: '', price: 900,  level: 6, seats: 3,
                    bonus: { type: 'happiness', value: 10, desc: 'Sing along! +10 happiness' } },
    aqua_bar:     { name: 'Aqua Bar',     icon: '', price: 1100, level: 8, seats: 5,
                    bonus: { type: 'tips', value: 1.12, desc: 'Fancy seating! +12% tips' } },
    hammock_pod:  { name: 'Hammock Pods', icon: '', price: 700,  level: 5, seats: 2,
                    bonus: { type: 'patience', value: 0.75, desc: 'So relaxing! 25% slower patience' } },
};

const UPGRADES = {
    faster_mixing:   { name: 'Speed Shaker',    icon: '', price: 200,  level: 2, desc: '-20% prep time' },
    bigger_tips:     { name: 'Charm School',     icon: '', price: 350,  level: 3, desc: '+25% tips' },
    patience_boost:  { name: 'Ambient Music',    icon: '', price: 250,  level: 2, desc: 'Customers wait longer' },
    double_serve:    { name: 'Extra Hands',      icon: '', price: 500,  level: 5, desc: 'Serve 2 drinks at once' },
    auto_greet:      { name: 'Greeter Bot',      icon: '', price: 700,  level: 6, desc: 'Auto-take orders' },
    happy_hour:      { name: 'Happy Hour Sign',  icon: '', price: 400,  level: 4, desc: 'More customers' },
    helper_bot:      { name: 'Helper Droid',     icon: '', price: 1500, level: 8, desc: 'Auto-serves 1 drink every 15s' },
    vip_beacon:      { name: 'VIP Beacon',       icon: '', price: 2000, level: 10, desc: '+50% VIP customer chance' },
    quantum_mixer:   { name: 'Quantum Mixer',    icon: '', price: 2500, level: 12, desc: '-40% prep time (stacks with Speed Shaker)' },
};

const DECORATIONS = {
    // TIER 1 - Early game basics
    neon_sign:    { name: 'Neon Sign',      icon: '', price: 100, level: 1, rep: 5,  
                    bonus: { type: 'happiness', value: 5, desc: '+5 starting happiness' },
                    light: { color: '#ff00ff', radius: 80, flicker: true } },
    jukebox:      { name: 'Space Jukebox',  icon: '', price: 200, level: 2, rep: 10, 
                    bonus: { type: 'patience', value: 0.9, desc: '10% slower patience drain' },
                    light: { color: '#00ffff', radius: 60, pulse: true } },
    poster:       { name: 'Vintage Poster', icon: '', price: 80, level: 1, rep: 3,   
                    bonus: { type: 'happiness', value: 3, desc: '+3 starting happiness' } },
    
    // TIER 2 - Mid game upgrades
    aquarium:     { name: 'Alien Aquarium', icon: '', price: 400, level: 4, rep: 15, 
                    bonus: { type: 'tips', value: 1.15, desc: '+15% tips from all customers' },
                    light: { color: '#0088ff', radius: 70, pulse: true } },
    hologram:     { name: 'Holo Dancer',    icon: '', price: 600, level: 6, rep: 20, 
                    bonus: { type: 'happiness', value: 10, desc: '+10 starting happiness' },
                    light: { color: '#00ff88', radius: 50, flicker: true } },
    trophy:       { name: 'Asteroid Trophy',icon: '', price: 300, level: 3, rep: 8,  
                    bonus: { type: 'xp', value: 1.1, desc: '+10% XP from serves' } },
    plants:       { name: 'Cosmic Plants',  icon: '', price: 150, level: 2, rep: 5,  
                    bonus: { type: 'patience', value: 0.95, desc: '5% slower patience drain' } },
    
    // TIER 3 - Late game luxury
    chandelier:   { name: 'Crystal Chandelier', icon: '', price: 1000, level: 8, rep: 30, 
                    bonus: { type: 'vip', value: 1.5, desc: '+50% VIP spawn chance' },
                    light: { color: '#ffffaa', radius: 120 } },
    fountain:     { name: 'Quantum Fountain',   icon: '', price: 800, level: 7, rep: 25, 
                    bonus: { type: 'happiness', value: 15, desc: '+15 starting happiness' },
                    light: { color: '#aaffff', radius: 90, pulse: true } },
    arcade:       { name: 'Retro Arcade',       icon: '', price: 1200, level: 9, rep: 35, 
                    bonus: { type: 'patience', value: 0.8, desc: '20% slower patience drain' },
                    light: { color: '#ff0055', radius: 60, flicker: true } },
    
    // TIER 4 - Endgame prestige
    statue:       { name: 'Mary Statue',    icon: '', price: 2000, level: 12, rep: 50, 
                    bonus: { type: 'tips', value: 1.25, desc: '+25% tips from all customers' } },
    telescope:    { name: 'Cosmic Telescope', icon: '', price: 1500, level: 10, rep: 40, 
                    bonus: { type: 'xp', value: 1.2, desc: '+20% XP from serves' } },
    fireplace:    { name: 'Plasma Fireplace',  icon: '', price: 1800, level: 11, rep: 45, 
                    bonus: { type: 'all', value: 1.1, desc: '+10% tips, XP, and happiness' },
                    light: { color: '#ff6600', radius: 100, flicker: true } },
    
    // NEW ITEMS
    disco_ball:   { name: 'Disco Ball',     icon: '', price: 2500, level: 13, rep: 60,
                    bonus: { type: 'happiness', value: 20, desc: 'Party vibes! +20 starting happiness' },
                    light: { color: 'rainbow', radius: 150, spin: true } },
    holo_tree:    { name: 'Holo-Tree',      icon: '', price: 1600, level: 9, rep: 30,
                    bonus: { type: 'patience', value: 0.85, desc: 'Calming vibes. 15% slower patience drain' },
                    light: { color: '#00ff44', radius: 80, pulse: true } },
};

// ==================== DIALOGUE SYSTEM ====================
const DIALOGUE_DATA = {
    // INTRO DIALOGUE
    intro_1: {
        char: 'walter',
        text: "Well look who finally woke up! That stasis pod malfunction really did a number on you, huh?",
        next: 'intro_2'
    },
    intro_2: {
        char: 'mary',
        text: "Easy, Walter. They've been frozen for 50 years. Give them a second.",
        next: 'intro_3'
    },
    intro_3: {
        char: 'walter',
        text: "We don't HAVE a second! The rent is due, the gravity generator is leaking, and I think I saw a space rat in the kitchen.",
        choices: [
            { text: "I'm ready to work!", next: 'intro_work' },
            { text: "Space rat?", next: 'intro_rat' }
        ]
    },
    intro_work: {
        char: 'mary',
        text: "That's the spirit! Here's the deal: You mix the drinks, I'll handle the angry customers. Let's get this place open.",
        action: () => { showNotification(' LETS GO!'); },
        end: true
    },
    intro_rat: {
        char: 'walter',
        text: "Yeah, size of a golden retriever. Don't worry about it. Just... don't pet it.",
        next: 'intro_work'
    },
    
    // QUEST: REPUTATION (Q2)
    q2_start: {
        char: 'mary',
        text: "Listen, we need to get our name out there. Right now, the only people who know this bar are pirates and... well, Walter.",
        next: 'q2_2'
    },
    q2_2: {
        char: 'mary',
        text: "If we can get our Reputation to 50, maybe we can attract some classier clientele. Or at least ones that pay.",
        end: true
    },
    
    // QUEST: VIP (Q3)
    q3_start: {
        char: 'carl',
        text: "*psst* Hey buddy. You see that guy over there? That's a VIP. Very Important... Person? Alien? Thing?",
        next: 'q3_2'
    },
    q3_2: {
        char: 'carl',
        text: "Anyway, VIPs have gold names. Serve them fast and they tip HUGE. Like, 'buy a small moon' huge.",
        end: true
    },

    // QUEST: FURNITURE (Q4)
    q4_start: {
        char: 'walter',
        text: "My feet are killing me. And I have four of them. We need more places for folks to sit.",
        next: 'q4_2'
    },
    q4_2: {
        char: 'walter',
        text: "Check the Shop. Buy some tables. If they sit, they order. Simple math.",
        end: true
    },
    
    // QUEST: DECORATION (Q11)
    q11_start: {
        char: 'scally',
        text: "*gestures with all eight tentacles* This place has POTENTIAL! But it's so... bland.",
        next: 'q11_2'
    },
    q11_2: {
        char: 'scally',
        text: "Get some decorations! Neon signs, aquariums, maybe a hologram dancer. Make it FANCY!",
        end: true
    },
    
    // QUEST: COMBO MASTER (Q12)
    q12_start: {
        char: 'dick',
        text: "Oh, you think you're fast now? Please. My grandmother serves faster. And she's been dead for 200 years.",
        next: 'q12_2'
    },
    q12_2: {
        char: 'dick',
        text: "Get a 10x combo. THEN we'll talk about who's the real bartender around here.",
        end: true
    },
    
    // QUEST: FAVORITES (Q13)
    q13_start: {
        char: 'mary',
        text: "Honey, being a great bartender isn't just about speed. It's about KNOWING people.",
        next: 'q13_2'
    },
    q13_2: {
        char: 'mary',
        text: "Everyone here has favorite drinks. Learn them. Serve them right. Watch the tips roll in. ",
        end: true
    },
    
    // QUEST: PRESTIGE (Q14)
    q14_start: {
        char: 'walter',
        text: "Kid... I haven't been this clear-headed in centuries. I need to tell you something important.",
        next: 'q14_2'
    },
    q14_2: {
        char: 'walter',
        text: "There's a thing called 'Prestige'. Reset everything, but keep permanent bonuses. It's how legends are made.",
        end: true
    },
    
    // QUEST: GALACTIC FAME (Q15)
    q15_start: {
        char: 'toni',
        text: "*antenna buzzing excitedly* The Galactic Council has noticed us! This is HUGE!",
        next: 'q15_2'
    },
    q15_2: {
        char: 'toni',
        text: "Earn enough credits and they'll officially recognize Orion's Barrel. We'll be on STAR MAPS!",
        end: true
    },
    
    // RANDOM EVENT: POWER SURGE
    event_surge: {
        char: 'scally',
        text: "Oops. I might have plugged my quantum toaster into the main reactor. My bad.",
        end: true
    },
    
    // RANDOM EVENT: CELEBRITY
    event_celeb: {
        char: 'dick',
        text: "Is that... Zaphod Beeblebrox?! No, wait, just some guy with two heads. Still, looks rich!",
        end: true
    },
    
    // CHARACTER: WALTER
    chat_walter_1: {
        char: 'walter',
        text: "You know, back before the asteroid, I was a lawyer. Can you believe it? Dinosaurs had great legal systems.",
        end: true
    },
    chat_walter_2: {
        char: 'walter',
        text: "The trick to a good Warp Whiskey is to stir it counter-clockwise. Or is it clockwise? ...Whatever, just stir it.",
        end: true
    },
    
    // CHARACTER: CARL
    chat_carl_1: {
        char: 'carl',
        text: "I've been reading about 'cats'. Apparently they ignore you and knock things over? Sounds like my ex-wife!",
        end: true
    },
    
    // LEVEL UP 5
    level_5: {
        char: 'mary',
        text: "Level 5! Look at you go! We might actually survive this month's rent.",
        end: true
    },
    
    // LEVEL UP 10
    level_10: {
        char: 'walter',
        text: "Level 10! I haven't felt this excited since the Cretaceous period. We're actually making it!",
        next: 'level_10b'
    },
    level_10b: {
        char: 'mary',
        text: "Don't jinx it, Walter. Last time you said that, we got raided by space pirates.",
        end: true
    },
    
    // LEVEL UP 15
    level_15: {
        char: 'toni',
        text: "*antenna sparking* Level 15! The quantum vibrations in here are INCREDIBLE. We're famous!",
        next: 'level_15b'
    },
    level_15b: {
        char: 'dick',
        text: "Famous? I've been famous since birth. But sure, you're doing... adequate work.",
        end: true
    },
    
    // LEVEL UP 20
    level_20: {
        char: 'mary',
        text: "Level 20. I never thought this dump would become something special. I'm proud of you, kid.",
        next: 'level_20b'
    },
    level_20b: {
        char: 'walter',
        text: "*tears up* It's just... the dust... in my four eyes... I'm not crying, YOU'RE crying.",
        end: true
    },
    
    // MORE CHARACTER CHATS
    chat_carl_2: {
        char: 'carl',
        text: "I chased my tail for three hours yesterday. In my defense, it was doing something suspicious.",
        end: true
    },
    chat_carl_3: {
        char: 'carl',
        text: "Every time someone opens the airlock, I have to fight the urge to stick my head out. It's a DOG thing.",
        end: true
    },
    chat_dick_1: {
        char: 'dick',
        text: "I see EVERYTHING. Every dimension. Every timeline. And in ALL of them, this bar needs cleaning.",
        end: true
    },
    chat_dick_2: {
        char: 'dick',
        text: "My eye doctor says I have 20/20/20/20/20 vision. It's a blessing and a curse. Mostly a curse.",
        end: true
    },
    chat_scally_1: {
        char: 'scally',
        text: "Did you know octopi have three hearts? Well I have FIVE. Two of them are for partying.",
        end: true
    },
    chat_scally_2: {
        char: 'scally',
        text: "I could tend bar eight times faster than you. Eight arms, baby. But I'm on VACATION.",
        end: true
    },
    chat_toni_1: {
        char: 'toni',
        text: "My antennae are picking up transmissions from 47 galaxies. Most of them are just ads for space insurance.",
        end: true
    },
    chat_toni_2: {
        char: 'toni',
        text: "On my planet, we communicate by changing colour. Right now I'm... *turns purple* ...hungry.",
        end: true
    },
    chat_glorp_1: {
        char: 'glorp',
        text: "I absorbed a dictionary once. Now I can't stop making puns. It's a real... ABSORBING hobby. Get it?",
        end: true
    },
    chat_glorp_2: {
        char: 'glorp',
        text: "People ask if it hurts being amorphous. Only emotionally. *wobbles sadly*",
        end: true
    },
    chat_zix_1: {
        char: 'zix',
        text: "ERROR: Social subroutine failed. RETRY: Hi. How are ERROR. ABORT. *sparks nervously*",
        end: true
    },
    chat_zix_2: {
        char: 'zix',
        text: "I calculated there's a 73.2% chance this conversation will be awkward. So far I'm right.",
        end: true
    },
    chat_blorb_1: {
        char: 'blorb',
        text: "*gentle bubbling* ...you know what the meaning of life is? ...me neither. But this drink is nice.",
        end: true
    },
    chat_blorb_2: {
        char: 'blorb',
        text: "*slowly absorbs a coaster* ...oops. That wasn't food. ...or was it? *contemplates*",
        end: true
    },
    chat_krax_1: {
        char: 'krax',
        text: "I've been sitting in the same spot for 800 years once. It was a Tuesday. Best Tuesday of my life.",
        end: true
    },
    chat_krax_2: {
        char: 'krax',
        text: "People think rocks don't have feelings. We do. They're just... really slow feelings. I'm still processing something from 1987.",
        end: true
    },
    chat_pip_1: {
        char: 'pip',
        text: "I once drank 200 cups of Quantum Cola and I could literally see the FUTURE! ...it was mostly just more cola.",
        end: true
    },
    chat_pip_2: {
        char: 'pip',
        text: "Glorp and I started a band! I play the theremin and Glorp plays... Glorp. It's EXPERIMENTAL!",
        end: true
    },
    chat_mary_1: {
        char: 'mary',
        text: "Before I ran this bar, I was a space marine. 15 years. That's why I don't flinch when Dick yells.",
        end: true
    },
    chat_mary_2: {
        char: 'mary',
        text: "The secret to the Cosmic Martini? A dash of meteorite dust. Don't tell health inspectors.",
        end: true
    },
    
    // BAR STORIES (random lore events)
    story_origin: {
        char: 'walter',
        text: "You know why this place is called Orion's Barrel? The original owner won it in a poker game. Against Orion himself.",
        next: 'story_origin2'
    },
    story_origin2: {
        char: 'mary',
        text: "And Orion STILL comes by sometimes looking for a rematch. We pretend we're closed.",
        end: true
    },
    story_ghost: {
        char: 'scally',
        text: "*whispers* Don't tell anyone, but I've seen a ghost in the cellar. A pirate captain. He just sits there rating our grog.",
        next: 'story_ghost2'
    },
    story_ghost2: {
        char: 'dick',
        text: "That's not a ghost, Scally. That's just Walter after his third Warp Whiskey.",
        end: true
    },
    story_music: {
        char: 'carl',
        text: "GUYS! The jukebox played a song from Earth! Something called... 'Who Let The Dogs Out'? I cried.",
        end: true
    },
    story_health: {
        char: 'mary',
        text: "The health inspector is coming next week. Everyone act normal. Blorb, STOP eating the furniture.",
        next: 'story_health2'
    },
    story_health2: {
        char: 'blorb',
        text: "*slowly releases a chair leg* ...no promises.",
        end: true
    },
    story_rival: {
        char: 'toni',
        text: "Intercepted a transmission! That bar across the nebula  'The Black Hole Lounge'  they're trash-talking us!",
        next: 'story_rival2'
    },
    story_rival2: {
        char: 'dick',
        text: "They said our drinks taste like engine coolant? ...I mean, they DO, but that's the FLAVOUR PROFILE.",
        end: true
    },
    story_date: {
        char: 'zix',
        text: "ALERT: Two customers are... holding appendages? My romance subroutine suggests this is a 'date'.",
        next: 'story_date2'
    },
    story_date2: {
        char: 'carl',
        text: "Awwww! Quick, dim the lights! Play something romantic! *knocks over three glasses*",
        end: true
    }
};

let currentDialogue = null;
let dialogueQueue = [];

function showDialogue(id) {
    if (currentDialogue) {
        dialogueQueue.push(id);
        return;
    }
    
    const data = DIALOGUE_DATA[id];
    if (!data) return;
    
    currentDialogue = data;
    
    const overlay = document.getElementById('dialogue-overlay');
    const nameEl = document.getElementById('dialogue-name');
    const textEl = document.getElementById('dialogue-text');
    const imgEl = document.getElementById('dialogue-img');
    const choicesEl = document.getElementById('dialogue-choices');
    const continueEl = document.getElementById('dialogue-continue');
    
    // Setup Character
    const char = CHAR_DATA[data.char];
    nameEl.textContent = char ? char.name : 'Unknown';
    nameEl.style.color = char ? char.color : '#fff';
    // Use the already-loaded image src (which uses the new asset paths)
    const sprKey = char ? char.sprite : 'walter_sprite';
    imgEl.src = imgs[sprKey] ? imgs[sprKey].src : `assets/${sprKey}.png`;
    
    // Setup Text
    textEl.textContent = '';
    typewriterText(data.text, textEl);
    
    // Setup Choices
    choicesEl.innerHTML = '';
    if (data.choices) {
        continueEl.style.display = 'none';
        data.choices.forEach(choice => {
            const btn = document.createElement('div');
            btn.className = 'dialogue-choice';
            btn.textContent = choice.text;
            btn.onclick = () => {
                if (choice.action) choice.action();
                if (choice.next) showDialogue(choice.next);
                else closeDialogue();
            };
            choicesEl.appendChild(btn);
        });
    } else {
        continueEl.style.display = 'block';
        continueEl.onclick = () => advanceDialogue();
    }
    
    overlay.classList.add('show');
    playSound('click');
    
    // Pause game interactions if needed (optional)
    GS.dialogueActive = true;
}

function advanceDialogue() {
    if (!currentDialogue) return;
    
    // If typing isn't done, finish it instantly
    if (typewriterInterval) {
        clearInterval(typewriterInterval);
        typewriterInterval = null;
        document.getElementById('dialogue-text').textContent = currentDialogue.text;
        return;
    }
    
    if (currentDialogue.action) currentDialogue.action();
    
    if (currentDialogue.next) {
        const nextId = currentDialogue.next;
        currentDialogue = null; // Clear so showDialogue doesn't queue it
        showDialogue(nextId);
    } else {
        closeDialogue();
    }
}

function closeDialogue() {
    document.getElementById('dialogue-overlay').classList.remove('show');
    currentDialogue = null;
    GS.dialogueActive = false;
    
    // Check queue
    if (dialogueQueue.length > 0) {
        setTimeout(() => showDialogue(dialogueQueue.shift()), 500);
    }
}

let typewriterInterval = null;
function typewriterText(text, element) {
    if (typewriterInterval) clearInterval(typewriterInterval);
    let i = 0;
    element.textContent = '';
    typewriterInterval = setInterval(() => {
        element.textContent += text.charAt(i);
        i++;
        if (i >= text.length) {
            clearInterval(typewriterInterval);
            typewriterInterval = null;
        }
    }, 20); // Speed of typing
}

// ==================== RECIPE BOOK ====================
const DRINK_LORE = {
    cosmic_martini:  "The classic spacefarer's drink. Shaken during re-entry for optimal bubbles.",
    nebula_shot:     "One sip and you'll see colors that don't exist. Side effects: temporary omniscience.",
    rocket_fuel:     "Literally rocket fuel. Well, mostly. We added a cherry.",
    starlight_fizz:  "Captured starlight mixed with carbonated void-water. Tastes like Tuesday.",
    void_brew:       "Brewed in the absolute zero of deep space. Served warm, somehow.",
    solar_punch:     "Warning: May cause spontaneous sunburn. And enlightenment.",
    moon_milk:       "From the moon cows of Titan-7. Don't ask how they milk them.",
    gravity_well:    "So dense it bends light around the glass. Great conversation starter.",
    dinosaur_daiquiri: "Walter's secret recipe from 65 million years ago. Literally.",
    big_bang:        "Recreates the birth of the universe in your mouth. Tips recommended.",
    warp_whiskey:    "Aged 50 years in 5 seconds thanks to time dilation. Smooth.",
    plasma_punch:    "Plasma state beverages are all the rage on Mars colonies.",
    aurora_ale:      "Changes color as you drink it. Each sip is a different flavor.",
    quasar_cooler:   "Cooled by actual quasar radiation. Perfectly safe. Probably.",
    pulsar_mojito:   "The mint is grown in rotating gravity fields. Extra fresh.",
    dark_matter:     "Nobody knows what's in it. That's the point.",
    supernova_sour:  "So sour it briefly creates a micro-singularity on your tongue.",
    walters_regret:  "Walter invented this during a three-day bender. He doesn't remember how.",
    quantum_cola:    "Simultaneously flat AND fizzy until you observe it.",
    black_hole_brew: "Whatever goes in... doesn't come out. Including your sobriety.",
    comet_tail:      "Trailing notes of ice, rock, and existential wonder.",
    galaxy_swirl:    "Contains actual galaxy dust. Mostly for the aesthetic.",
    alien_absinthe:  "The green fairy is actually a small alien named Gerald.",
    time_warp_tea:   "Drink it now, taste it yesterday. Time is weird in space.",
};

function toggleRecipeBook() {
    const panel = document.getElementById('recipe-book');
    panel.classList.toggle('show');
    if (panel.classList.contains('show')) renderRecipeBook();
}

function renderRecipeBook() {
    const list = document.getElementById('recipe-list');
    list.innerHTML = '';
    
    // Sort drinks by level
    const sortedDrinks = Object.entries(DRINKS).sort((a, b) => a[1].level - b[1].level);
    
    for (const [key, drink] of sortedDrinks) {
        const unlocked = GS.unlockedDrinks.includes(key);
        const card = document.createElement('div');
        card.className = `recipe-card ${unlocked ? '' : 'locked'}`;
        
        const lore = DRINK_LORE[key] || 'A mysterious concoction...';
        
        card.innerHTML = `
            <div class="recipe-card-header">
                <span class="recipe-icon">${unlocked ? drink.icon : ''}</span>
                <div>
                    <div class="recipe-name">${unlocked ? drink.name : '???'}</div>
                    <div class="recipe-level">Level ${drink.level} required</div>
                </div>
            </div>
            <div class="recipe-stats">
                <span> ${drink.price} Cr</span>
                <span> ${drink.time}s</span>
                <span> ${drink.xp} XP</span>
            </div>
            ${unlocked ? `<div class="recipe-lore">"${lore}"</div>` : '<div class="recipe-lore">Unlock this drink to learn its secrets...</div>'}
            <div class="recipe-color-bar" style="background: ${unlocked ? drink.color : '#333'}"></div>
        `;
        
        list.appendChild(card);
    }
}

function showRecipeTab(tab) {
    document.getElementById('recipe-list').style.display = tab === 'drinks' ? '' : 'none';
    document.getElementById('synergy-list').style.display = tab === 'synergy' ? '' : 'none';
    document.getElementById('rtab-drinks').style.background = tab === 'drinks' ? 'rgba(0,255,136,0.2)' : 'transparent';
    document.getElementById('rtab-drinks').style.color = tab === 'drinks' ? '#fff' : '#aaa';
    document.getElementById('rtab-synergy').style.background = tab === 'synergy' ? 'rgba(255,0,255,0.2)' : 'transparent';
    document.getElementById('rtab-synergy').style.color = tab === 'synergy' ? '#fff' : '#aaa';
    if (tab === 'synergy') renderSynergyGuide();
}

function renderSynergyGuide() {
    const list = document.getElementById('synergy-list');
    list.innerHTML = `<div style="text-align:center;color:#aa88cc;font-size:12px;margin-bottom:10px;padding:0 10px">Serve two matching drinks within 8 seconds to trigger a synergy bonus!</div>`;
    
    for (const syn of DRINK_SYNERGIES) {
        const [a, b] = syn.drinks;
        const drinkA = DRINKS[a], drinkB = DRINKS[b];
        const unlockedA = GS.unlockedDrinks.includes(a);
        const unlockedB = GS.unlockedDrinks.includes(b);
        const discovered = (GS._synergiesTriggered || 0) > 0; // Simple: show all if any triggered
        
        const card = document.createElement('div');
        card.style.cssText = 'background:rgba(80,0,120,0.3);border:1px solid rgba(255,0,255,0.3);border-radius:10px;padding:10px 12px;margin:0 10px 8px';
        card.innerHTML = `
            <div style="font-size:15px;color:#ffd700;font-weight:bold;margin-bottom:4px">${syn.name}</div>
            <div style="display:flex;align-items:center;gap:8px;margin-bottom:4px">
                <span style="background:rgba(0,0,0,0.3);padding:3px 8px;border-radius:6px;font-size:13px;color:${unlockedA ? drinkA.color : '#555'}">${unlockedA ? drinkA.icon + ' ' + drinkA.name : ' ???'}</span>
                <span style="color:#ff00ff;font-weight:bold">+</span>
                <span style="background:rgba(0,0,0,0.3);padding:3px 8px;border-radius:6px;font-size:13px;color:${unlockedB ? drinkB.color : '#555'}">${unlockedB ? drinkB.icon + ' ' + drinkB.name : ' ???'}</span>
            </div>
            <div style="display:flex;justify-content:space-between;font-size:12px">
                <span style="color:#aa88cc">${syn.desc}</span>
                <span style="color:#00ff88;font-weight:bold">+${syn.bonus}</span>
            </div>
        `;
        list.appendChild(card);
    }
}

// ==================== ACHIEVEMENTS ====================
const ACHIEVEMENTS = {
    // DRINKS SERVED
    first_serve:     { name: 'First Shift',        icon: '', desc: 'Serve your first drink',                  check: () => GS.totalServed >= 1,     reward: { cr: 10 } },
    bartender:       { name: 'Bartender',          icon: '', desc: 'Serve 50 drinks',                         check: () => GS.totalServed >= 50,    reward: { cr: 100, xp: 50 } },
    mixologist:      { name: 'Mixologist',         icon: '', desc: 'Serve 200 drinks',                        check: () => GS.totalServed >= 200,   reward: { cr: 300, xp: 100 } },
    master_server:   { name: 'Master Server',      icon: '', desc: 'Serve 500 drinks',                        check: () => GS.totalServed >= 500,   reward: { cr: 500, xp: 200 } },
    legend:          { name: 'Barrel Legend',      icon: '', desc: 'Serve 1000 drinks',                       check: () => GS.totalServed >= 1000,  reward: { cr: 1500, xp: 500, rep: 25 } },
    
    // CREDITS EARNED
    entrepreneur:    { name: 'Entrepreneur',       icon: '', desc: 'Earn 1,000 total credits',                check: () => GS.totalEarned >= 1000,  reward: { cr: 200 } },
    businessowner:   { name: 'Business Owner',     icon: '', desc: 'Earn 5,000 total credits',                check: () => GS.totalEarned >= 5000,  reward: { cr: 500, xp: 150 } },
    tycoon:          { name: 'Space Tycoon',       icon: '', desc: 'Earn 25,000 total credits',               check: () => GS.totalEarned >= 25000, reward: { cr: 2000, xp: 500, rep: 20 } },
    
    // LEVEL MILESTONES
    level5:          { name: 'Experienced',        icon: '', desc: 'Reach level 5',                           check: () => GS.level >= 5,           reward: { cr: 150, xp: 75 } },
    level10:         { name: 'Veteran',            icon: '', desc: 'Reach level 10',                          check: () => GS.level >= 10,          reward: { cr: 400, xp: 200 } },
    level15:         { name: 'Elite',              icon: '', desc: 'Reach level 15',                          check: () => GS.level >= 15,          reward: { cr: 1000, xp: 500, rep: 15 } },
    level20:         { name: 'Legendary',          icon: '', desc: 'Reach level 20',                          check: () => GS.level >= 20,          reward: { cr: 2500, xp: 1000, rep: 30 } },
    
    // COMBO ACHIEVEMENTS
    combo5:          { name: 'On a Roll',          icon: '', desc: 'Get a 5x combo',                          check: () => GS._maxCombo >= 5,       reward: { cr: 50, xp: 25 } },
    combo10:         { name: 'Hot Streak',         icon: '', desc: 'Get a 10x combo',                         check: () => GS._maxCombo >= 10,      reward: { cr: 200, xp: 100 } },
    combo25:         { name: 'Unstoppable',        icon: '', desc: 'Get a 25x combo',                         check: () => GS._maxCombo >= 25,      reward: { cr: 800, xp: 400, rep: 10 } },
    
    // VIP ACHIEVEMENTS
    vip_first:       { name: 'VIP Service',        icon: '', desc: 'Serve your first VIP',                    check: () => GS._vipServed >= 1,      reward: { cr: 50 } },
    vip_master:      { name: 'VIP Master',         icon: '', desc: 'Serve 25 VIPs',                           check: () => GS._vipServed >= 25,     reward: { cr: 300, xp: 150 } },
    vip_legend:      { name: 'Celebrity Magnet',   icon: '', desc: 'Serve 100 VIPs',                          check: () => GS._vipServed >= 100,    reward: { cr: 1000, xp: 500, rep: 20 } },
    
    // REPUTATION
    rep50:           { name: 'Getting Known',      icon: '', desc: 'Reach 50 reputation',                     check: () => GS.reputation >= 50,     reward: { cr: 100, xp: 50 } },
    rep100:          { name: 'Famous',             icon: '', desc: 'Reach 100 reputation',                    check: () => GS.reputation >= 100,    reward: { cr: 400, xp: 200 } },
    rep150:          { name: 'Renowned',           icon: '', desc: 'Reach 150 reputation',                    check: () => GS.reputation >= 150,    reward: { cr: 1000, xp: 500, rep: 10 } },
    
    // PERFECT SERVES
    perfect10:       { name: 'Perfectionist',      icon: '', desc: 'Serve 10 customers at 100% happiness',    check: () => GS._perfectServes >= 10, reward: { cr: 150, xp: 75 } },
    perfect50:       { name: 'Flawless',           icon: '', desc: 'Serve 50 customers at 100% happiness',    check: () => GS._perfectServes >= 50, reward: { cr: 500, xp: 250, rep: 10 } },
    
    // COLLECTION ACHIEVEMENTS
    all_drinks:      { name: 'Drink Master',       icon: '', desc: 'Unlock all drinks',                       check: () => GS.unlockedDrinks.length >= Object.keys(DRINKS).length, reward: { cr: 800, xp: 400, rep: 15 } },
    all_furniture:   { name: 'Interior Designer',  icon: '', desc: 'Purchase all furniture types',            check: () => Object.keys(FURNITURE).every(k => GS.inventory[k] > 0), reward: { cr: 500, xp: 250, rep: 10 } },
    all_decorations: { name: 'Master Decorator',   icon: '', desc: 'Purchase all decorations',                check: () => GS.decorations.length >= Object.keys(DECORATIONS).length, reward: { cr: 1200, xp: 600, rep: 25 } },
    all_upgrades:    { name: 'Fully Upgraded',     icon: '', desc: 'Purchase all upgrades',                   check: () => GS.upgrades.length >= Object.keys(UPGRADES).length, reward: { cr: 1000, xp: 500, rep: 20 } },
    
    // STORY & QUESTS
    quest_complete:  { name: 'Quest Hero',         icon: '', desc: 'Complete 5 story quests',                 check: () => completedQuests.length >= 5, reward: { cr: 300, xp: 150 } },
    quest_master:    { name: 'Legend of the Bar',  icon: '', desc: 'Complete all 10 story quests',            check: () => completedQuests.length >= 10, reward: { cr: 1000, xp: 500, rep: 25 } },
    
    // DAILY CHALLENGES
    daily_warrior:   { name: 'Daily Warrior',      icon: '', desc: 'Complete a full day of challenges',       check: () => GS._dailiesCompleted >= 1, reward: { cr: 200, xp: 100 } },
    daily_champion:  { name: 'Daily Champion',     icon: '', desc: 'Complete 7 days of challenges',           check: () => GS._dailiesCompleted >= 7, reward: { cr: 800, xp: 400, rep: 15 } },
    
    // CHARACTER ACHIEVEMENTS
    walter_fan:      { name: "Walter's Friend",    icon: '', desc: 'Serve Walter 50 times',                   check: () => GS._walterServed >= 50,  reward: { cr: 250, xp: 125 } },
    carl_buddy:      { name: "Carl's Companion",   icon: '', desc: 'Serve Carl 50 times',                     check: () => GS._carlServed >= 50,    reward: { cr: 250, xp: 125 } },
    zix_calmer:      { name: 'Robot Whisperer',    icon: '', desc: 'Serve Zix 30 times',                      check: () => GS._zixServed >= 30,     reward: { cr: 300, xp: 150 } },
    blorb_friend:    { name: 'Blob Buddy',         icon: '', desc: 'Serve Blorb 30 times',                    check: () => GS._blorbServed >= 30,   reward: { cr: 300, xp: 150 } },
    
    // FAVORITE DRINK ACHIEVEMENTS
    favorite_5:      { name: 'Taste Tester',       icon: '', desc: 'Serve 5 characters their favorite drinks',  check: () => (GS._favoritesServed || []).length >= 5,  reward: { cr: 300, xp: 150 } },
    favorite_10:     { name: 'Preference Master',  icon: '', desc: 'Serve 10 characters their favorite drinks', check: () => (GS._favoritesServed || []).length >= 10, reward: { cr: 600, xp: 300, rep: 15 } },
    favorite_all:    { name: 'Perfect Memory',     icon: '', desc: 'Discover all character favorites',         check: () => (GS._favoritesServed || []).length >= 24, reward: { cr: 1500, xp: 750, rep: 30 } },
    // SYNERGY ACHIEVEMENTS
    synergy_first:   { name: 'Mixologist',        icon: '', desc: 'Trigger your first drink synergy',         check: () => (GS._synergiesTriggered || 0) >= 1,  reward: { cr: 100, xp: 50 } },
    synergy_10:      { name: 'Combo Chemist',     icon: '', desc: 'Trigger 10 drink synergies',              check: () => (GS._synergiesTriggered || 0) >= 10, reward: { cr: 500, xp: 250, rep: 10 } },
    synergy_50:      { name: 'Master Alchemist',  icon: '', desc: 'Trigger 50 drink synergies',              check: () => (GS._synergiesTriggered || 0) >= 50, reward: { cr: 2000, xp: 1000, rep: 25 } },
    
    // TIME-BASED
    night_owl:       { name: 'Night Owl',          icon: '', desc: 'Serve 100 customers during Night Shift',  check: () => GS._nightOwlServed >= 100, reward: { cr: 400, xp: 200, rep: 10 } },
    
    // FURNITURE PLACEMENT
    decorator:       { name: 'Decorator',          icon: '', desc: 'Place 10 pieces of furniture',            check: () => GS.placedFurniture.length >= 10, reward: { cr: 200, xp: 100 } },
    
    // STREAK ACHIEVEMENTS
    streak_3:        { name: 'On Fire',            icon: '', desc: 'Maintain a 3-day login streak',           check: () => GS._loginStreak >= 3,   reward: { cr: 150, xp: 75 } },
    streak_7:        { name: 'Week Warrior',       icon: '', desc: 'Maintain a 7-day login streak',           check: () => GS._loginStreak >= 7,   reward: { cr: 400, xp: 200 } },
    streak_14:       { name: 'Fortnight Champion', icon: '', desc: 'Maintain a 14-day login streak',          check: () => GS._loginStreak >= 14,  reward: { cr: 1000, xp: 500, rep: 10 } },
    streak_30:       { name: 'Monthly Master',     icon: '', desc: 'Maintain a 30-day login streak',          check: () => GS._loginStreak >= 30,  reward: { cr: 2500, xp: 1250, rep: 25 } },
    streak_100:      { name: 'Dedication Legend',  icon: '', desc: 'Maintain a 100-day login streak',         check: () => GS._loginStreak >= 100, reward: { cr: 10000, xp: 5000, rep: 100 } },
    perfect_5:       { name: 'Perfectionist',      icon: '', desc: 'Complete 5 perfect challenge days',       check: () => GS._perfectDayStreak >= 5,  reward: { cr: 500, xp: 250 } },
    perfect_10:      { name: 'Perfect Ten',        icon: '', desc: 'Complete 10 perfect challenge days',      check: () => GS._perfectDayStreak >= 10, reward: { cr: 1200, xp: 600, rep: 15 } },
};

let unlockedAchievements = [];

// Character data  6 unique customers + Mary
const CHAR_DATA = {
    walter: {
        name: 'Walter', sprite: 'walter_sprite', role: 'customer',
        favorites: ['dinosaur_daiquiri', 'walters_regret', 'gravity_well', 'time_warp_tea'],
        emoji: '', color: '#ff8833',
        quips: [
            "*hic* ...what year is it?",
            "I saved the dinosaurs, y'know...",
            "One more won't hurt... much",
            "Is this bar spinning or is it me?",
            "Back in my day, asteroids were BIGGER",
            "Mary! The usual! ...what's my usual?",
            "I'm not drunk, the station is rotating",
            "These drinks remind me of the Cretaceous...",
            "Did I tell you about the asteroid?",
            "65 million years and I STILL feel guilty",
        ]
    },
    carl: {
        name: 'Carl', sprite: 'carl_sprite', role: 'customer',
        favorites: ['moon_milk', 'aurora_ale', 'starlight_fizz', 'comet_tail'],
        emoji: '', color: '#88aa44',
        quips: [
            "Do you think they have dogs on Earth?",
            "I saw a picture of a Golden Retriever...",
            "One day I'll get an Earth dog...",
            "What if the dog doesn't like me?",
            "*sighs dreamily about puppies*",
            "Earth dogs can FETCH. Can you believe it?!",
            "I'd name it Captain Barksworth",
            "Have you SEEN a corgi? They're PERFECT",
            "Maybe a Labrador... or a Beagle...",
            "*shows you 47 dog photos on his datapad*",
        ]
    },
    dick: {
        name: 'Dick', sprite: 'dick_sprite', role: 'customer',
        favorites: ['warp_whiskey', 'void_brew', 'big_bang', 'black_hole_brew'],
        emoji: '', color: '#aa55cc',
        quips: [
            "This drink better be good or ELSE",
            "Nice place... be a shame if someone...",
            "*flips the bird at nothing in particular*",
            "Burberry is timeless. Fight me.",
            "I got kicked out of THREE bars today",
            "What are you looking at, one-eye? ...wait",
            "Put it on someone else's tab",
            "I didn't start that fire. Probably.",
            "My therapist says I have 'boundary issues'",
            "Burberry hat stays ON during drinks",
        ]
    },
    scally: {
        name: 'Scally', sprite: 'scally_sprite', role: 'customer',
        favorites: ['plasma_punch', 'quasar_cooler', 'nebula_shot', 'galaxy_swirl'],
        emoji: '', color: '#ff66cc',
        quips: [
            "*tentacle gestures* Make it strong",
            "This reminds me of Andromeda...",
            "Your oxygen mix is 2% off. I can taste it.",
            "On my planet, we drink with ALL our mouths",
            "*slurps thoughtfully with multiple appendages*",
            "I've been to 47 galaxies. This bar? Top 10.",
            "The void whispers to me... it wants a refill",
            "Did you know I have THREE livers?",
            "Fascinating carbon-based beverage technique",
        ]
    },
    toni: {
        name: 'Toni', sprite: 'toni_sprite', role: 'customer',
        favorites: ['cosmic_martini', 'supernova_sour', 'pulsar_mojito', 'alien_absinthe'],
        emoji: '', color: '#66ff99',
        quips: [
            "Beep boop! Just kidding, I speak Common",
            "Nice atmosphere in here. Literally.",
            "I'll take whatever doesn't violate my dietary restrictions",
            "My home world was destroyed. This helps.",
            "*adjusts antenna* Signal's good here",
            "You wouldn't believe what I saw in the Horsehead Nebula",
            "This drink is... *chef's kiss* ...adequate",
            "I'm not saying it was aliens, but it was ME",
            "The stars are right. For drinking!",
        ]
    },
    glorp: {
        name: 'Glorp', sprite: 'glorp_sprite', role: 'customer',
        favorites: ['dark_matter', 'void_brew', 'rocket_fuel', 'quantum_cola'],
        emoji: '', color: '#9933ff',
        quips: [
            "*GLORP*",
            "*happy gurgling sounds*",
            "GLORP GLORP!",
            "*gestures wildly at menu*",
            "Glorp... glooorp?",
            "*leaves a puddle* Sorry about that",
            "*communicates entirely through smell*",
            "GLOOOOORP! *thumbs up*",
            "*your universal translator says: 'Another!'*",
        ]
    },
    zix: {
        name: 'Zix', sprite: 'zix_sprite', role: 'customer',
        favorites: ['nebula_shot', 'rocket_fuel', 'quantum_cola', 'warp_whiskey'],
        emoji: '', color: '#55ddff',
        quips: [
            "ERROR 418: I am a teapot. Wait, no. A customer.",
            "My anxiety subroutine is at 97%... make it strong",
            "PLEASE don't shake the drink near me I will short-circuit",
            "*beeps nervously*",
            "I calculated a 73.6% chance this drink is adequate",
            "My creator said bars would 'help me relax'. LIES.",
            "Is... is that drink SUPPOSED to be on fire?!",
            "I tipped 40% because I panicked. Keep it.",
            "Every time Dick looks at me my threat detection spikes",
            "*vibrating with social anxiety*",
        ]
    },
    blorb: {
        name: 'Blorb', sprite: 'blorb_sprite', role: 'customer',
        favorites: ['aurora_ale', 'cosmic_martini', 'moon_milk', 'starlight_fizz'],
        emoji: '', color: '#88ffcc',
        quips: [
            "*JIGGLE* Hellooooo beautiful people!",
            "Everything is WONDERFUL when you're a blob!",
            "I absorb drinks through my membrane. Science!",
            "*wobbles happily* Another round for my FRIENDS!",
            "On my planet I'm considered VERY handsome",
            "Group hug? No? Is it the slime? It's the slime.",
            "I don't need a chair, I AM the chair! *sits on floor*",
            "*splits into two smaller blobs* We'll both have one!",
            "Your gravity here is DELIGHTFUL. So squishy!",
            "I've been here 6 hours. I LOVE this place!",
        ]
    },
    krax: {
        name: 'Krax', sprite: 'krax_sprite', role: 'customer',
        favorites: ['dark_matter', 'big_bang', 'warp_whiskey', 'void_brew'],
        emoji: '', color: '#aa7744',
        quips: [
            "*cracks knuckles* ...oh, that was my face. Ignore that.",
            "I've been alive for 4 billion years. This better be worth it.",
            "Chairs break when I sit. That's YOUR problem.",
            "On my planet we drink LAVA. This is... cute.",
            "*grinds teeth* No, that's how I smile. APPRECIATE IT.",
            "I don't tip. It's not personal. Actually yes it is.",
            "Someone stepped on my foot. They're still in the hospital.",
            "This music is too loud. And I'm LITERALLY A ROCK.",
            "*sits perfectly still for 20 minutes* ...I was dancing.",
            "My therapist is a geologist. Get it? GEOlogist? ...I'm lonely.",
        ]
    },
    pip: {
        name: 'Pip', sprite: 'pip_sprite', role: 'customer',
        favorites: ['starlight_fizz', 'galaxy_swirl', 'moon_milk', 'quantum_cola'],
        emoji: '', color: '#ffdd44',
        quips: [
            "OHMYGOSH is that a MENU?! I want EVERYTHING!",
            "*zips around at light speed* HI EVERYONE!",
            "I'm 300 years old but I look great right?! RIGHT?!",
            "Does this place have WIFI? I need to post this IMMEDIATELY",
            "*accidentally knocks over 3 drinks* SORRY SORRY SORRY!",
            "I had 47 espressos today. I can SEE THROUGH TIME.",
            "Dick scared me and I flew into the ceiling. There's a dent now.",
            "*vibrating* This is the BEST BAR in ALL of SPACE and I mean it!",
            "Glorp and I are besties! We're SO different but it WORKS!",
            "I tip 200% because GENEROSITY IS MY BRAND!",
        ]
    },
    mary: {
        name: 'Mary', sprite: 'mary_sprite', backSprite: 'mary_back_sprite', role: 'bartender',
        emoji: '', color: '#ff3366',
        quips: [
            "Order up!",
            "Coming right up, sugar!",
            "Another round? You got it!",
            "Walter, you've had enough... oh fine",
            "Dick, behave or you're OUT",
            "Best bar in the quadrant, baby!",
        ]
    },
};

// ==================== POSITIONS ON MAP (1408x736) ====================
const BAR_CENTER = { x: 390, y: 340 };
const MARY_POS = { x: BAR_CENTER.x, y: BAR_CENTER.y - 40 };
const ENTRY_POS = { x: 700, y: 680 };

const TABLE_SPOTS = [
    { x: 580, y: 280, seats: 2 },  // near bar upper right
    { x: 780, y: 280, seats: 2 },  // upper far right
    { x: 580, y: 440, seats: 2 },  // middle right
    { x: 780, y: 440, seats: 2 },  // middle far right
    { x: 440, y: 500, seats: 2 },  // lower left
    { x: 600, y: 580, seats: 2 },  // lower center
    { x: 800, y: 560, seats: 2 },  // lower right
    { x: 980, y: 340, seats: 2 },  // far right
    { x: 250, y: 450, seats: 2 },  // left side
    { x: 950, y: 500, seats: 2 },  // far right lower
];

const BAR_STOOL_SPOTS = [
    { x: 340, y: 380 },
    { x: 380, y: 400 },
    { x: 420, y: 380 },
    { x: 460, y: 360 },
];

// ==================== AMBIENT CHARACTER SYSTEM ====================
const AMBIENT_CHAR_INFO = [
    { key: 'walter',  name: 'Walter',  sprite: 'walter_sprite',  emoji: '', color: '#ff8833',
      desc: '65 million years old and STILL the most embarrassing person in the bar.',
      quips: ["*hic* ...what year is it?","I saved the dinosaurs, y'know...","One more won\'t hurt... much","The asteroid was NOT my fault","Back in my day, drinks were BIGGER","I\'m not drunk, the station is rotating","Did I tell you about the asteroid?","65 million years and I STILL feel guilty","Mary! The usual! ...what\'s my usual?","Is this bar spinning or is it me?"] },
    { key: 'carl',    name: 'Carl',    sprite: 'carl_sprite',    emoji: '', color: '#88dd44',
      desc: 'Obsessed with Earth dogs. Has 2,000+ saved photos on his datapad.',
      quips: ["Do you think they have dogs on Earth?","I saw a picture of a Golden Retriever...","One day I\'ll get an Earth dog...","Earth dogs can FETCH. Can you believe it?!","I\'d name it Captain Barksworth","Have you SEEN a corgi? They\'re PERFECT","Maybe a Labrador... or a Beagle...","*shows you 47 dog photos on his datapad*","What if the dog doesn\'t like me?","*sighs dreamily about puppies*"] },
    { key: 'dick',    name: 'Dick',    sprite: 'dick_sprite',    emoji: '', color: '#cc66ff',
      desc: 'One eye, zero chill. Currently banned from 14 other bars.',
      quips: ["This drink better be good or ELSE","Nice place... be a shame if someone...","*flips the bird at nothing in particular*","Burberry is timeless. Fight me.","I got kicked out of THREE bars today","Put it on someone else\'s tab","I didn\'t start that fire. Probably.","My therapist says I have \'boundary issues\'","Burberry hat stays ON during drinks","What are you looking at? I\'ll fight you."] },
    { key: 'scally',  name: 'Scally',  sprite: 'scally_sprite',  emoji: '', color: '#ff66cc',
      desc: 'Multi-limbed philosopher from Andromeda. Has THREE livers and uses all of them.',
      quips: ["*tentacle gestures* Make it strong","This reminds me of Andromeda...","Your oxygen mix is 2% off. I can taste it.","On my planet, we drink with ALL our mouths","*slurps thoughtfully with multiple appendages*","I\'ve been to 47 galaxies. This bar? Top 10.","The void whispers to me... it wants a refill","Did you know I have THREE livers?","Fascinating carbon-based beverage technique","I can taste the sadness in this drink. Magnificent."] },
    { key: 'toni',    name: 'Toni',    sprite: 'toni_sprite',    emoji: '', color: '#66ff99',
      desc: 'Antenna-having regular. Lost their home world but found this bar. It helps.',
      quips: ["Beep boop! Just kidding, I speak Common","Nice atmosphere in here. Literally.","I\'ll take whatever doesn\'t violate my dietary restrictions","My home world was destroyed. This helps.","*adjusts antenna* Signal\'s good here","You wouldn\'t believe what I saw in the Horsehead Nebula","This drink is... *chef\'s kiss* ...adequate","I\'m not saying it was aliens, but it was ME","The stars are right. For drinking!","I feel 83% less existential dread in here."] },
    { key: 'glorp',   name: 'Glorp',   sprite: 'glorp_sprite',   emoji: '', color: '#aa44ff',
      desc: 'Communication style: enthusiastic gurgling. Still tips 20%.',
      quips: ["*GLORP*","*happy gurgling sounds*","GLORP GLORP!","*gestures wildly at menu*","Glorp... glooorp?","*leaves a puddle* Sorry about that","GLOOOOORP! *thumbs up*","*your translator says: \'Another!\'*","*GURGLE* means \'I love this place\'","Glorp glorp GLORP? (I think?)"] },
    { key: 'zix',     name: 'Zix',     sprite: 'zix_sprite',     emoji: '', color: '#55ddff',
      desc: 'Anxiety-ridden android. Calculated 73.6% chance this drink is adequate.',
      quips: ["ERROR 418: I am a teapot. Wait, no. A customer.","My anxiety subroutine is at 97%... make it strong","PLEASE don\'t shake the drink I will short-circuit","*beeps nervously*","I calculated a 73.6% chance this is adequate","My creator said bars would \'help me relax\'. LIES.","Is... is that drink SUPPOSED to be on fire?!","I tipped 40% because I panicked. Keep it.","*vibrating with social anxiety*","Every time Dick looks at me my threat detection spikes"] },
    { key: 'blorb',   name: 'Blorb',   sprite: 'blorb_sprite',   emoji: '', color: '#88ffcc',
      desc: 'Sentient blob from the Gelatinous Nebula. Surprisingly good at karaoke.',
      quips: ["*JIGGLE* Hellooooo beautiful people!","Everything is WONDERFUL when you\'re a blob!","I absorb drinks through my membrane. Science!","*wobbles happily* Another round for my FRIENDS!","On my planet I\'m considered VERY handsome","Group hug? No? Is it the slime?","*splits into two smaller blobs* We\'ll both have one!","I\'ve been here 6 hours. I LOVE this place!","Your gravity here is DELIGHTFUL. So squishy!","I don\'t need a chair, I AM the chair!"] },
    { key: 'krax',    name: 'Krax',    sprite: 'krax_sprite',    emoji: '', color: '#cc8844',
      desc: '4 billion year old rock entity. Chairs break when he sits. Your problem.',
      quips: ["*cracks knuckles* ...oh, that was my face.","I\'ve been alive 4 billion years. This better be worth it.","Chairs break when I sit. That\'s YOUR problem.","On my planet we drink LAVA. This is... cute.","*grinds teeth* No, that\'s how I smile. APPRECIATE IT.","I don\'t tip. It\'s not personal. Actually yes it is.","Someone stepped on my foot. They\'re still in the hospital.","This music is too loud. And I\'m LITERALLY A ROCK.","*sits perfectly still for 20 minutes* ...I was dancing.","My therapist is a geologist. Get it? GEOlogist?"] },
    { key: 'pip',     name: 'Pip',     sprite: 'pip_sprite',     emoji: '', color: '#ffdd44',
      desc: '300 year old tiny mystery species. Has 47 espressos and can see through time.',
      quips: ["OHMYGOSH is that a MENU?! I want EVERYTHING!","*zips around at light speed* HI EVERYONE!","I\'m 300 years old but I look great right?! RIGHT?!","Does this place have WIFI? Need to post this IMMEDIATELY","*accidentally knocks over 3 drinks* SORRY SORRY SORRY!","I had 47 espressos today. I can SEE THROUGH TIME.","Dick scared me and I flew into the ceiling. There\'s a dent.","*vibrating* This is the BEST BAR in ALL of SPACE!","I tip 200% because GENEROSITY IS MY BRAND!","Glorp and I are besties! We\'re SO different but it WORKS!"] },
];

let ambientChars = [];
let ambientSpeechBubble = null; // { charKey, text, screenX, screenY, expires, desc }

function initAmbientChars() {
    // Spread characters around the map (1408x736)
    const startPositions = [
        { x: 350, y: 360 }, // near bar
        { x: 620, y: 290 }, // upper tables area
        { x: 820, y: 290 }, // upper right
        { x: 560, y: 460 }, // middle
        { x: 780, y: 460 }, // middle right
        { x: 440, y: 530 }, // lower left
        { x: 650, y: 560 }, // lower center
        { x: 850, y: 540 }, // lower right
        { x: 990, y: 360 }, // far right
        { x: 970, y: 510 }, // far right lower
    ];
    ambientChars = AMBIENT_CHAR_INFO.map((cd, i) => {
        const sp = startPositions[i] || { x: 300 + Math.random() * 800, y: 250 + Math.random() * 400 };
        return {
            key: cd.key,
            x: sp.x, y: sp.y,
            targetX: sp.x, targetY: sp.y,
            speed: 28 + Math.random() * 18, // world px per second
            waitTimer: 500 + Math.random() * 2500,
            moving: false,
            flipX: false,
            bobPhase: Math.random() * Math.PI * 2,
        };
    });
}

function updateAmbientChars(dt) {
    for (const ac of ambientChars) {
        if (ac.moving) {
            const dx = ac.targetX - ac.x;
            const dy = ac.targetY - ac.y;
            const dist = Math.sqrt(dx * dx + dy * dy);
            const moveAmt = ac.speed * dt / 1000;
            if (dist <= moveAmt + 0.5) {
                ac.x = ac.targetX; ac.y = ac.targetY;
                ac.moving = false;
                ac.waitTimer = 1500 + Math.random() * 4000;
            } else {
                ac.x += (dx / dist) * moveAmt;
                ac.y += (dy / dist) * moveAmt;
                ac.flipX = dx < 0;
            }
        } else {
            ac.waitTimer -= dt;
            if (ac.waitTimer <= 0) {
                // Pick a new random destination within bar map bounds
                const margin = 80;
                ac.targetX = margin + Math.random() * (1408 - margin * 2);
                ac.targetY = 140 + Math.random() * (736 - 280);
                ac.moving = true;
            }
        }
    }
    // Expire speech bubble
    if (ambientSpeechBubble && performance.now() > ambientSpeechBubble.expires) {
        ambientSpeechBubble = null;
    }
}

function drawAmbientChars() {
    const nowT = performance.now();
    for (const ac of ambientChars) {
        const cd = AMBIENT_CHAR_INFO.find(c => c.key === ac.key);
        if (!cd) continue;
        const img = imgs[cd.sprite];
        if (!img) {
            // Fallback: draw colored circle with emoji
            const s = w2s(ac.x, ac.y);
            ctx.fillStyle = cd.color;
            ctx.beginPath();
            ctx.arc(s.x, s.y - 20 * cam.zoom, 20 * cam.zoom, 0, Math.PI * 2);
            ctx.fill();
            ctx.font = `${22 * cam.zoom}px Arial`;
            ctx.textAlign = 'center';
            ctx.fillText(cd.emoji, s.x, s.y - 12 * cam.zoom);
            ctx.font = `bold ${9 * cam.zoom}px Nunito`;
            ctx.fillStyle = cd.color;
            ctx.fillText(cd.name, s.x, s.y - 42 * cam.zoom);
            continue;
        }

        const s = w2s(ac.x, ac.y);
        const spriteW = 62 * cam.zoom;
        const spriteH = (img.height / img.width) * spriteW;
        const bob = ac.moving ? Math.sin(nowT / 140 + ac.bobPhase) * 3 * cam.zoom : 0;

        // Shadow
        ctx.fillStyle = 'rgba(0,0,0,0.22)';
        ctx.beginPath();
        ctx.ellipse(s.x, s.y, 18 * cam.zoom, 6 * cam.zoom, 0, 0, Math.PI * 2);
        ctx.fill();

        // Sprite
        ctx.save();
        if (ac.flipX) {
            ctx.translate(s.x, s.y - spriteH + bob);
            ctx.scale(-1, 1);
            ctx.drawImage(img, -spriteW / 2, 0, spriteW, spriteH);
        } else {
            ctx.drawImage(img, s.x - spriteW / 2, s.y - spriteH + bob, spriteW, spriteH);
        }
        ctx.restore();

        // Name tag
        const nameY = s.y - spriteH - 6 * cam.zoom + bob;
        ctx.font = `bold ${10 * cam.zoom}px Nunito`;
        ctx.textAlign = 'center';
        ctx.strokeStyle = 'rgba(0,0,0,0.85)';
        ctx.lineWidth = 3 * cam.zoom;
        ctx.strokeText(cd.emoji + ' ' + cd.name, s.x, nameY);
        ctx.fillStyle = cd.color;
        ctx.fillText(cd.emoji + ' ' + cd.name, s.x, nameY);
    }

    // Draw speech bubble (on top of all characters)
    if (ambientSpeechBubble) {
        const { text, desc, charKey } = ambientSpeechBubble;
        const cd = AMBIENT_CHAR_INFO.find(c => c.key === charKey);
        const ac = ambientChars.find(a => a.key === charKey);
        // Dynamically compute screen position from current character world pos
        const acS = ac ? w2s(ac.x, ac.y) : { x: W/2, y: H/2 };
        const acImg = cd && imgs[cd.sprite];
        const acSpriteH = acImg ? (acImg.height / acImg.width) * 62 * cam.zoom : 60 * cam.zoom;
        const screenX = acS.x;
        const screenY = acS.y - acSpriteH;
        const col = cd ? cd.color : '#00ff88';
        const age = performance.now() - ambientSpeechBubble.born;
        const ttl = ambientSpeechBubble.expires - ambientSpeechBubble.born;
        const fadeAlpha = age > ttl * 0.75 ? 1 - (age - ttl * 0.75) / (ttl * 0.25) : 1;
        ctx.globalAlpha = Math.max(0, fadeAlpha);

        const pad = 10, lineH = 16, maxW = 270;
        const descFontSize = 10;
        // Word-wrap helper
        function wrapText(str, font, maxPx) {
            ctx.font = font;
            const ws = str.split(' '); const ls = []; let c = '';
            for (const w of ws) { const t = c ? c + ' ' + w : w; if (ctx.measureText(t).width > maxPx) { if (c) ls.push(c); c = w; } else c = t; }
            if (c) ls.push(c);
            return ls;
        }
        const lines = wrapText(text, 'bold 12px Nunito', maxW - pad * 2);
        const descLines = desc ? wrapText(desc, `italic ${descFontSize}px Nunito`, maxW - pad * 2) : [];

        const bubbleW = maxW;
        const bubbleH = pad + lines.length * lineH + (descLines.length > 0 ? descLines.length * (descFontSize + 3) + 6 : 0) + pad;
        let bx = screenX - bubbleW / 2;
        let by = screenY - bubbleH - 18;
        // Clamp to viewport
        bx = Math.max(6, Math.min(W - bubbleW - 6, bx));
        by = Math.max(6, by);

        // Bubble background
        ctx.fillStyle = 'rgba(5,12,28,0.95)';
        ctx.strokeStyle = col;
        ctx.lineWidth = 2;
        ctx.beginPath();
        if (ctx.roundRect) ctx.roundRect(bx, by, bubbleW, bubbleH, 10);
        else ctx.rect(bx, by, bubbleW, bubbleH);
        ctx.fill(); ctx.stroke();

        // Tail
        const tailX = Math.min(bx + bubbleW - 20, Math.max(bx + 20, screenX));
        ctx.fillStyle = 'rgba(5,12,28,0.95)';
        ctx.strokeStyle = col;
        ctx.beginPath();
        ctx.moveTo(tailX - 7, by + bubbleH);
        ctx.lineTo(tailX + 7, by + bubbleH);
        ctx.lineTo(tailX, by + bubbleH + 12);
        ctx.closePath();
        ctx.fill(); ctx.stroke();

        // Quip text
        ctx.fillStyle = '#ffffff';
        ctx.font = 'bold 12px Nunito';
        ctx.textAlign = 'left';
        lines.forEach((ln, i) => {
            ctx.fillText(ln, bx + pad, by + pad + (i + 1) * lineH - 2);
        });
        // Desc text (italic, character flavor)
        if (descLines.length > 0) {
            ctx.fillStyle = col;
            ctx.font = `italic ${descFontSize}px Nunito`;
            const descStartY = by + pad + lines.length * lineH + 8;
            descLines.forEach((ln, i) => {
                ctx.fillText(ln, bx + pad, descStartY + i * (descFontSize + 3));
            });
        }
        ctx.globalAlpha = 1;
        ctx.textAlign = 'center';
    }
}

function checkAmbientCharClick(worldX, worldY) {
    for (const ac of ambientChars) {
        const dx = worldX - ac.x;
        const dy = worldY - ac.y;
        if (Math.abs(dx) < 40 && dy > -80 && dy < 10) {
            const cd = AMBIENT_CHAR_INFO.find(c => c.key === ac.key);
            if (!cd) continue;
            const quip = cd.quips[Math.floor(Math.random() * cd.quips.length)];
            ambientSpeechBubble = {
                charKey: ac.key,  // used to look up current position dynamically
                text: quip,
                desc: cd.desc,
                born: performance.now(),
                expires: performance.now() + 4500,
            };
            return true;
        }
    }
    return false;
}

// ==================== GAME STATE ====================
const GS = {
    credits: 100,
    level: 1,
    xp: 0,
    xpNeeded: 100,
    reputation: 50,
    tables: [],       // { type, spotIndex }
    customers: [],    // { id, char, state, pos, targetPos, happiness, order, drinkProgress, quip, quipTimer, tableIdx }
    upgrades: [],     // purchased upgrade keys
    decorations: [],  // purchased decoration keys
    unlockedDrinks: ['cosmic_martini', 'nebula_shot', 'rocket_fuel', 'aurora_ale'],
    inventory: {},        // { itemKey: quantity }
    placedFurniture: [],  // { type, x, y }
    nextCustId: 1,
    lastSpawn: 0,
    spawnInterval: 6000,
    gameSpeed: 1,
    totalServed: 0,
    totalEarned: 0,
    started: false,
    // Achievement tracking
    _maxCombo: 0,
    _vipServed: 0,
    _perfectServes: 0,
    _dailiesCompleted: 0,
    _walterServed: 0,
    _carlServed: 0,
    _zixServed: 0,
    _blorbServed: 0,
    _nightOwlServed: 0,
    // Streak tracking
    _loginStreak: 0,
    _lastLogin: null,
    _perfectDayStreak: 0,
    _longestLoginStreak: 0,
    _totalLogins: 0,
    _streakRewardsClaimed: [],
    // Prestige tracking
    _prestigePoints: 0,
    _lifetimePrestige: 0,
    _prestigeCount: 0,
    shopOpen: false,
    invOpen: false,
    shopTab: 'furniture',
    selectedCustomer: null,
    drinkMenuOpen: false,
    placementMode: null,  // { type, category } when placing
    placementPos: null,   // { x, y } mouse world pos
    placementValid: false,
    dialogueActive: false,
};

// ==================== CANVAS SETUP ====================
let canvas, ctx, W, H;
let cam = { x: 0, y: -50, zoom: 1.2 };
let drag = { active: false, lx: 0, ly: 0, moved: false };
const imgs = {};
let assetsLoaded = 0, totalAssets = 0;

// ==================== ASSET LOADING ====================
function loadImg(key, src) {
    return new Promise(r => {
        const img = new Image();
        img.onload = () => { imgs[key] = img; assetsLoaded++; updateLoading(); r(); };
        img.onerror = () => { console.warn('Failed:', src); assetsLoaded++; updateLoading(); r(); };
        img.src = src;
    });
}

function updateLoading() {
    const pct = totalAssets > 0 ? (assetsLoaded / totalAssets * 100) : 0;
    document.getElementById('load-fill').style.width = pct + '%';
    const msgs = ['Polishing the glasses...', 'Stocking Rocket Fuel...', 'Waking up Walter...', 'Bribing Dick to behave...', 'Teaching Carl about dogs...'];
    document.getElementById('load-text').textContent = msgs[assetsLoaded % msgs.length];
}

async function loadAllAssets() {
    const list = [
        ['map', 'assets/new/map-interior.png'],
        // Yaan's new character art (bg-removed)
        ['carl_sprite', 'assets/new/carl-front.png'],
        ['walter_sprite', 'assets/new/walter-front-v2.png'],
        ['walter_back_sprite', 'assets/new/walter-back.png'],
        ['mary_sprite', 'assets/new/mary-front.png'],
        ['mary_back_sprite', 'assets/new/mary-back.png'],
        ['scally_sprite', 'assets/new/scally-front.png'],
        // Other sprites (original)
        ['dick_sprite', 'assets/dick_sprite.png'],
        ['bar_counter_front', 'assets/bar_counter_front.png'],
        ['toni_sprite', 'assets/toni_sprite.png'],
        ['glorp_sprite', 'assets/glorp_sprite.png'],
        ['zix_sprite', 'assets/zix_sprite.png'],
        ['blorb_sprite', 'assets/blorb_sprite.png'],
        ['krax_sprite', 'assets/krax_sprite.png'],
        ['pip_sprite', 'assets/pip_sprite.png'],
    ];
    totalAssets = list.length;
    await Promise.race([
        Promise.all(list.map(([k,s]) => loadImg(k,s))),
        new Promise(r => setTimeout(r, 12000))
    ]);
    document.getElementById('loading').style.display = 'none';
    document.getElementById('game-container').style.display = 'block';
    initCanvas();
}

// ==================== DECORATION BONUSES ====================
function getDecorationBonuses() {
    const bonuses = {
        happiness: 0,      // Added to starting happiness
        patience: 1.0,     // Multiplier for patience drain (lower = slower drain)
        tips: 1.0,         // Multiplier for tips
        xp: 1.0,           // Multiplier for XP
        vip: 1.0           // Multiplier for VIP spawn chance
    };
    
    // Helper to apply a bonus
    function applyBonus(b) {
        if (!b) return;
        if (b.type === 'happiness') bonuses.happiness += b.value;
        else if (b.type === 'patience') bonuses.patience *= b.value;
        else if (b.type === 'tips') bonuses.tips *= b.value;
        else if (b.type === 'xp') bonuses.xp *= b.value;
        else if (b.type === 'vip') bonuses.vip *= b.value;
        else if (b.type === 'all') {
            bonuses.tips *= b.value;
            bonuses.xp *= b.value;
            bonuses.happiness += Math.floor((b.value - 1) * 100);
        }
    }
    
    // Apply decoration bonuses
    GS.decorations.forEach(key => {
        const deco = DECORATIONS[key];
        if (deco && deco.bonus) applyBonus(deco.bonus);
    });
    
    // Apply furniture bonuses from placed furniture
    GS.placedFurniture.forEach(f => {
        const furn = FURNITURE[f.type];
        if (furn && furn.bonus) applyBonus(furn.bonus);
    });
    
    return bonuses;
}

function getActiveDecorationEffects() {
    // Returns array of active decoration bonus descriptions for UI display
    const effects = [];
    GS.decorations.forEach(key => {
        const deco = DECORATIONS[key];
        if (deco && deco.bonus) {
            effects.push({ icon: deco.icon, name: deco.name, desc: deco.bonus.desc });
        }
    });
    // Also include furniture bonuses
    const seenFurniture = new Set();
    GS.placedFurniture.forEach(f => {
        if (seenFurniture.has(f.type)) return;
        const furn = FURNITURE[f.type];
        if (furn && furn.bonus) {
            effects.push({ icon: furn.icon, name: furn.name, desc: furn.bonus.desc });
            seenFurniture.add(f.type);
        }
    });
    return effects;
}

// ==================== INIT ====================
function initCanvas() {
    canvas = document.getElementById('game-canvas');
    ctx = canvas.getContext('2d');
    resize();
    window.addEventListener('resize', resize);
    setupInput();
    loadSave();
    loadSettings(); // Load user settings
    checkIdleEarnings(); // Show welcome back popup if away
    GS._sessionCount = (GS._sessionCount || 0) + 1; // Track session count
    checkLoginStreak(); // Check daily login streak
    generateDailyChallenges();
    initQuests();
    initTipJar(); // Initialize tip jar system
    updateBarRating(); // Initialize bar rating display
    initTooltips(); // Initialize tooltip system
    initSpaceForecast(); // Initialize space weather system
    initNewsTicker(); // Initialize space news ticker
    
    // Ensure starter tables
    if (GS.tables.length === 0) {
        for (let i = 0; i < 3; i++) GS.tables.push({ type: 'small_table', spotIndex: i });
    }
    
    // Restore TABLE_SPOTS from placed furniture
    if (GS.placedFurniture && GS.placedFurniture.length > 0) {
        for (const f of GS.placedFurniture) {
            if (FURNITURE[f.type]) {
                // Check if this spot already exists
                const exists = TABLE_SPOTS.some(s => Math.abs(s.x - f.x) < 5 && Math.abs(s.y - f.y) < 5);
                if (!exists) {
                    TABLE_SPOTS.push({ x: f.x, y: f.y, seats: FURNITURE[f.type].seats || 2 });
                }
            }
        }
    }
    
    updateHUD();
    initDailySpecialHUD();
    buildShop();
    initAmbientChars();
    requestAnimationFrame(gameLoop);
}

function resize() {
    W = window.innerWidth; H = window.innerHeight;
    canvas.width = W; canvas.height = H;
}

// ==================== CAMERA / COORD TRANSFORMS ====================
function w2s(wx, wy) {
    const m = imgs.map;
    if (!m) return { x: 0, y: 0 };
    const mw = m.width * cam.zoom, mh = m.height * cam.zoom;
    return {
        x: W/2 - mw/2 + cam.x + wx * cam.zoom,
        y: H/2 - mh/2 + cam.y + wy * cam.zoom
    };
}

function s2w(sx, sy) {
    const m = imgs.map;
    if (!m) return { x: 0, y: 0 };
    const mw = m.width * cam.zoom, mh = m.height * cam.zoom;
    return {
        x: (sx - W/2 + mw/2 - cam.x) / cam.zoom,
        y: (sy - H/2 + mh/2 - cam.y) / cam.zoom
    };
}

// ==================== INPUT ====================
function setupInput() {
    canvas.addEventListener('mousedown', e => { drag.active = true; drag.lx = e.clientX; drag.ly = e.clientY; drag.moved = false; });
    canvas.addEventListener('mousemove', e => {
        // Track placement ghost
        if (GS.placementMode) {
            GS.placementPos = s2w(e.clientX, e.clientY);
            GS.placementValid = isValidPlacement(GS.placementPos);
        }
        // Cursor hint for clickable shooting stars/comets
        let hoverStar = false;
        for (const ss of shootingStars) {
            if (!ss.caught && Math.sqrt((e.clientX-ss.x)**2+(e.clientY-ss.y)**2) < 35) { hoverStar = true; break; }
        }
        if (!hoverStar) {
            for (const c of spaceWeather.comets) {
                if (!c.caught && Math.sqrt((e.clientX-c.x)**2+(e.clientY-c.y)**2) < 45) { hoverStar = true; break; }
            }
        }
        canvas.style.cursor = hoverStar ? 'pointer' : (GS.placementMode ? 'crosshair' : 'grab');
        if (!drag.active) return;
        const dx = e.clientX - drag.lx, dy = e.clientY - drag.ly;
        if (Math.abs(dx) > 3 || Math.abs(dy) > 3) drag.moved = true;
        cam.x += dx; cam.y += dy;
        drag.lx = e.clientX; drag.ly = e.clientY;
    });
    canvas.addEventListener('mouseup', e => {
        if (!drag.moved) handleClick(e.clientX, e.clientY);
        drag.active = false;
    });
    canvas.addEventListener('contextmenu', e => { e.preventDefault(); cancelPlacement(); });
    document.addEventListener('keydown', handleKeyboard);
    
    // Touch
    canvas.addEventListener('touchstart', e => {
        e.preventDefault();
        if (e.touches.length === 1) {
            drag.active = true; drag.lx = e.touches[0].clientX; drag.ly = e.touches[0].clientY; drag.moved = false;
        }
    });
    canvas.addEventListener('touchmove', e => {
        e.preventDefault();
        if (!drag.active || e.touches.length !== 1) return;
        const dx = e.touches[0].clientX - drag.lx, dy = e.touches[0].clientY - drag.ly;
        if (Math.abs(dx) > 3 || Math.abs(dy) > 3) drag.moved = true;
        cam.x += dx; cam.y += dy;
        drag.lx = e.touches[0].clientX; drag.ly = e.touches[0].clientY;
    });
    canvas.addEventListener('touchend', e => {
        e.preventDefault();
        if (!drag.moved && e.changedTouches.length === 1) handleClick(e.changedTouches[0].clientX, e.changedTouches[0].clientY);
        drag.active = false;
    });
    
    // Zoom
    canvas.addEventListener('wheel', e => {
        e.preventDefault();
        cam.zoom *= e.deltaY < 0 ? 1.1 : 0.9;
        cam.zoom = Math.max(0.3, Math.min(2.5, cam.zoom));
    }, { passive: false });
    
    document.getElementById('btn-zoomin').onclick = () => { cam.zoom = Math.min(2.5, cam.zoom * 1.15); };
    document.getElementById('btn-zoomout').onclick = () => { cam.zoom = Math.max(0.3, cam.zoom / 1.15); };
    
    // Bottom buttons
    document.getElementById('btn-shop').onclick = () => { playSound('click');

        GS.shopOpen = !GS.shopOpen;
        if (GS.shopOpen) { GS.invOpen = false; document.getElementById('inv-panel').classList.remove('open'); }
        document.getElementById('shop-panel').classList.toggle('open', GS.shopOpen);
        closeDrinkMenu();
    };
    document.getElementById('btn-inv').onclick = () => {
        GS.invOpen = !GS.invOpen;
        if (GS.invOpen) { GS.shopOpen = false; document.getElementById('shop-panel').classList.remove('open'); buildInventory(); }
        document.getElementById('inv-panel').classList.toggle('open', GS.invOpen);
        closeDrinkMenu();
    };
    document.getElementById('btn-menu').onclick = () => showDrinksInfo();
    document.getElementById('btn-daily').onclick = () => {
        playSound('click');
        const p = document.getElementById('daily-panel');
        const open = p.classList.toggle('open');
        if (open) {
            generateDailyChallenges();
            buildDailyChallenges();
        }
    };
    document.getElementById('daily-close-btn').onclick = () => {
        playSound('click');
        document.getElementById('daily-panel').classList.remove('open');
    };
    document.getElementById('btn-quests').onclick = () => {
        playSound('click');
        const p = document.getElementById('quests-panel');
        const open = p.classList.toggle('open');
        if (open) {
            buildQuests();
        }
    };
    document.getElementById('quests-close-btn').onclick = () => {
        playSound('click');
        document.getElementById('quests-panel').classList.remove('open');
    };
    document.getElementById('btn-ach').onclick = () => {
        const p = document.getElementById('achievements-panel');
        const open = p.classList.toggle('open');
        if (open) { buildAchievements(); document.getElementById('leaderboard-panel').classList.remove('open'); }
    };
    document.getElementById('btn-lb').onclick = () => {
        const p = document.getElementById('leaderboard-panel');
        const open = p.classList.toggle('open');
        if (open) { buildLeaderboard(); document.getElementById('achievements-panel').classList.remove('open'); }
    };
    
    // Character guide panel handlers
    document.getElementById('btn-chars').onclick = () => {
        const p = document.getElementById('char-panel');
        const open = p.classList.toggle('open');
        if (open) { buildCharacterGuide(); }
    };
    document.getElementById('char-close-btn').onclick = () => {
        document.getElementById('char-panel').classList.remove('open');
    };
    
    // Streak panel handlers
    document.getElementById('streak-badge').onclick = () => {
        const p = document.getElementById('streak-panel');
        const open = p.classList.toggle('open');
        if (open) { buildStreaks(); }
    };
    document.getElementById('streak-close-btn').onclick = () => {
        document.getElementById('streak-panel').classList.remove('open');
    };
    
    // Prestige panel handlers
    document.getElementById('prestige-badge').onclick = () => {
        playSound('click');
        openPrestigePanel();
    };
    document.getElementById('prestige-confirm').onclick = () => {
        playSound('click');
        doPrestige();
    };
    document.getElementById('prestige-cancel').onclick = () => {
        playSound('click');
        closePrestigePanel();
    };
    
    document.getElementById('btn-speed').onclick = () => {
        GS.gameSpeed = GS.gameSpeed === 1 ? 2 : GS.gameSpeed === 2 ? 3 : 1;
        document.getElementById('btn-speed').textContent = ` x${GS.gameSpeed}`;
    };
    
    // Mini-game handlers
    document.getElementById('btn-minigame').onclick = () => {
        playSound('click');
        openMiniGame();
    };
    document.getElementById('minigame-start').onclick = () => {
        playSound('click');
        startMiniGame();
    };
    document.getElementById('minigame-close').onclick = () => {
        playSound('click');
        closeMiniGame();
    };
    
    // Statistics panel handlers
    document.getElementById('btn-stats').onclick = () => {
        playSound('click');
        openStatsPanel();
    };
    document.getElementById('stats-close-btn').onclick = () => {
        playSound('click');
        closeStatsPanel();
    };
    
    // Settings panel handlers
    document.getElementById('btn-settings').onclick = () => {
        playSound('click');
        openSettingsPanel();
    };
    document.getElementById('settings-save').onclick = () => {
        playSound('click');
        saveSettings();
    };
    document.getElementById('settings-close').onclick = () => {
        playSound('click');
        closeSettingsPanel();
    };
    document.getElementById('settings-reset').onclick = () => {
        playSound('click');
        resetAllData();
    };
    document.getElementById('setting-volume').oninput = (e) => {
        document.getElementById('volume-display').textContent = e.target.value + '%';
    };
    
    // Shop tabs
    document.querySelectorAll('.shop-tab').forEach(tab => {
        tab.onclick = () => {
            document.querySelectorAll('.shop-tab').forEach(t => t.classList.remove('active'));
            tab.classList.add('active');
            GS.shopTab = tab.dataset.tab;
            buildShop();
        };
    });
}

function handleClick(cx, cy) {
    // Try clicking shooting stars / comets first (screen coords)
    if (tryClickShootingStar(cx, cy)) return;
    
    // Placement mode
    if (GS.placementMode) {
        const world = s2w(cx, cy);
        if (isValidPlacement(world)) {
            placeFurnitureAt(GS.placementMode, world);
        } else {
            showNotification(' Can\'t place here!');
        }
        return;
    }
    
    // Close drink menu if clicking elsewhere
    if (GS.drinkMenuOpen) { closeDrinkMenu(); return; }
    
    const world = s2w(cx, cy);
    
    // Check customer clicks
    for (const c of GS.customers) {
        const dx = world.x - c.pos.x, dy = world.y - (c.pos.y - 40);
        if (Math.sqrt(dx*dx + dy*dy) < 45) {
            handleCustomerClick(c, cx, cy);
            return;
        }
    }
    
    // Check Mary click
    const mdx = world.x - MARY_POS.x, mdy = world.y - MARY_POS.y;
    if (Math.sqrt(mdx*mdx + mdy*mdy) < 50) {
        if (Math.random() < 0.2) { 
            const keys = Object.keys(DIALOGUE_DATA).filter(k => k.startsWith('chat_') || k.startsWith('intro_'));
            // Just random chat if any
            const chatKeys = Object.keys(DIALOGUE_DATA).filter(k => k.startsWith('chat_'));
            if (chatKeys.length > 0) {
                showDialogue(chatKeys[Math.floor(Math.random() * chatKeys.length)]);
            } else {
                showNotification(CHAR_DATA.mary.quips[Math.floor(Math.random() * CHAR_DATA.mary.quips.length)]);
            }
        } else {
            showNotification(CHAR_DATA.mary.quips[Math.floor(Math.random() * CHAR_DATA.mary.quips.length)]);
        }
        return;
    }

    // Check ambient character clicks (show speech bubble)
    checkAmbientCharClick(world.x, world.y);
}

function handleCustomerClick(customer, screenX, screenY) {
    if (customer.state === 'walking') return;
    
    // Bar fight: clicking fighters breaks up the fight
    if (GS._barFightActive && (customer.id === GS._fighter1 || customer.id === GS._fighter2)) {
        GS._barFightClicks = (GS._barFightClicks || 0) + 1;
        spawnFloatingNumber(customer.pos.x, customer.pos.y - 40, ' BREAK IT UP!', 'combo');
        playSound('click');
        if (GS._barFightClicks >= GS._barFightNeeded) {
            // End the fight early!
            endSpecialEvent();
            showNotification(' Fight broken up! Bouncer bonus earned!');
        } else {
            showNotification(` ${GS._barFightClicks}/${GS._barFightNeeded}  Keep clicking!`);
        }
        return;
    }
    
    if (customer.state === 'waiting') {
        // Show drink menu
        GS.selectedCustomer = customer;
        showDrinkMenu(screenX, screenY);
    } else if (customer.state === 'ordered' && customer.drinkProgress >= 1) {
        // Start Perfect Pour mini-interaction!
        startPerfectPour(customer, screenX, screenY);
    } else if (customer.state === 'ordered') {
        // Tap to speed up prep slightly
        customer.drinkProgress = Math.min(1, customer.drinkProgress + 0.03);
        spawnFloatingNumber(customer.pos.x, customer.pos.y - 40, '', 'credits');
        playSound('click');
        if (customer.drinkProgress >= 1) {
            customer._readyNotified = true;
            addLog(` ${DRINKS[customer.order].name} ready for ${CHAR_DATA[customer.char].name}!`);
            playSound('ready');
        }
    }
}

// ==================== DRINK MENU ====================
// ==================== DAILY DRINK SPECIAL ====================
function getDailySpecial() {
    const today = new Date();
    const seed = today.getFullYear() * 10000 + (today.getMonth() + 1) * 100 + today.getDate();
    const drinkKeys = Object.keys(DRINKS);
    return drinkKeys[seed % drinkKeys.length];
}

function getDailySpecialBonus() {
    return { creditMult: 1.5, xpMult: 1.5, label: '+50% SPECIAL' };
}

function showDailySpecialInfo() {
    const key = getDailySpecial();
    const d = DRINKS[key];
    if (!d) return;
    const served = GS._dailySpecialsServed || 0;
    const unlocked = GS.unlockedDrinks.includes(key);
    showNotification(` TODAY'S SPECIAL: ${d.icon} ${d.name}! Serve it for +50% credits & XP! ${unlocked ? `(Served ${served}x today)` : ' Unlock at Lv ' + d.level}`);
}

function initDailySpecialHUD() {
    const key = getDailySpecial();
    const d = DRINKS[key];
    if (d) {
        const badge = document.getElementById('hud-daily-special');
        if (badge) badge.textContent = d.icon + ' ' + d.name;
    }
}

function showDrinkMenu(sx, sy) {
    const menu = document.getElementById('drink-menu');
    const opts = document.getElementById('drink-options');
    opts.innerHTML = '';
    
    const customer = GS.selectedCustomer;
    const charData = customer ? CHAR_DATA[customer.char] : null;
    const favorites = charData && charData.favorites ? charData.favorites : [];
    const dailySpecial = getDailySpecial();
    
    const available = Object.entries(DRINKS).filter(([k,v]) => GS.unlockedDrinks.includes(k));
    available.forEach(([key, d]) => {
        const isFavorite = favorites.includes(key);
        const isSpecial = key === dailySpecial;
        const div = document.createElement('div');
        div.className = 'drink-option' + (isSpecial ? ' daily-special' : '');
        div.style.background = isSpecial ? 'rgba(255,215,0,0.15)' : isFavorite ? 'rgba(255,102,255,0.2)' : '';
        div.style.border = isSpecial ? '2px solid #ffd700' : isFavorite ? '1px solid #ff66ff' : '';
        if (isSpecial) div.style.boxShadow = '0 0 12px rgba(255,215,0,0.3)';
        const specialTag = isSpecial ? ' ' : '';
        const favTag = isFavorite ? ' ' : '';
        const bonusText = isSpecial && isFavorite ? ' +100%' : isSpecial ? ' +50%' : isFavorite ? ' +50%' : '';
        div.innerHTML = `
            <div class="drink-dot" style="background:${d.color}${isSpecial ? ';box-shadow:0 0 8px ' + d.color : ''}"></div>
            <span class="drink-name">${specialTag}${favTag}${d.icon} ${d.name}</span>
            <span class="drink-info">${d.price} ${d.time}s${bonusText}</span>
        `;
        div.onclick = (e) => { e.stopPropagation(); orderDrink(key); };
        opts.appendChild(div);
    });
    
    menu.style.display = 'block';
    menu.style.left = Math.min(sx, W - 220) + 'px';
    menu.style.top = Math.max(70, Math.min(sy - 100, H - 300)) + 'px';
    GS.drinkMenuOpen = true;
}

function closeDrinkMenu() {
    document.getElementById('drink-menu').style.display = 'none';
    GS.drinkMenuOpen = false;
    GS.selectedCustomer = null;
}

function orderDrink(drinkKey) {
    const c = GS.selectedCustomer;
    if (!c || c.state !== 'waiting') { closeDrinkMenu(); return; }
    
    const d = DRINKS[drinkKey];
    c.state = 'ordered';
    c.order = drinkKey;
    c.drinkProgress = 0;
    let drinkTimeMod = GS.upgrades.includes('faster_mixing') ? 0.8 : 1;
    if (GS.upgrades.includes('quantum_mixer')) drinkTimeMod *= 0.6;
    
    // Event modifiers
    const now = performance.now();
    if (GS._slowDrinksUntil && now < GS._slowDrinksUntil) drinkTimeMod *= 1.5; // Power surge
    if (GS._speedBoostUntil && now < GS._speedBoostUntil) drinkTimeMod *= 0.75; // Mary's pep talk
    
    c.drinkTime = d.time * 1000 * drinkTimeMod * getJukeboxBuff('speed');
    
    addLog(` ${CHAR_DATA[c.char].name} ordered ${d.name}`, 'tip');
    showNotification(`${d.icon} ${CHAR_DATA[c.char].name}: "${getOrderQuip(c.char)}"`);
    playSound('order');
    closeDrinkMenu();
}

function getOrderQuip(char) {
    const quips = {
        walter: ["Make it strong...", "Hair of the dog, please", "Whatever's closest"],
        carl: ["Ooh, fancy!", "Do dogs drink these?", "Something cheerful please!"],
        dick: ["Hurry up!", "It better be good", "Don't spit in it... this time"],
    };
    const q = quips[char] || ["I'll have that"];
    return q[Math.floor(Math.random() * q.length)];
}

function serveDrink(customer) {
    const d = DRINKS[customer.order];
    const decoBonuses = getDecorationBonuses();
    let tip = 0;
    
    if (customer.happiness > 75) {
        tip = Math.floor(d.price * (GS.upgrades.includes('bigger_tips') ? 0.6 : 0.35));
    } else if (customer.happiness > 40) {
        tip = Math.floor(d.price * 0.1);
    }
    
    // VIP tip multiplier
    if (customer.isVip) {
        tip = Math.floor(tip * customer.tipMultiplier);
        GS._vipServed = (GS._vipServed || 0) + 1;
    }
    
    // Double tips event
    if (GS._doubleTipsUntil && performance.now() < GS._doubleTipsUntil) {
        tip *= 2;
    }
    
    // DECORATION BONUSES - Apply tip multiplier
    tip = Math.floor(tip * decoBonuses.tips);
    
    // PRESTIGE BONUSES - Apply tip multiplier
    const prestigeBonuses = getPrestigeBonuses();
    tip = Math.floor(tip * prestigeBonuses.tipMultiplier);
    
    // HAPPY HOUR BONUS - Double tips!
    const happyHourMult = getHappyHourMultiplier();
    tip = Math.floor(tip * happyHourMult);
    
    // SPACE WEATHER BONUSES
    tip = Math.floor(tip * getWeatherMult('tips'));
    
    // Skill tree bonuses
    const skillBonuses = getSkillBonuses();
    tip = Math.floor(tip * skillBonuses.tipMult);
    // Relationship bonus (Krax)
    tip = Math.floor(tip * getRelationshipBonuses().tips);
    // Jukebox tip buff
    tip = Math.floor(tip * getJukeboxBuff('tips'));
    // Drink Mastery tip bonus
    tip = Math.floor(tip * getDrinkMasteryBonus(customer.order).tipBonus);
    // Legendary Charm: 5% chance of 3x tips
    if (hasSkill('legendary_charm') && Math.random() < 0.05) {
        tip *= 3;
        spawnFloatingNumber(customer.pos.x, customer.pos.y - 50, '3x TIP!', 'combo');
    }
    // Cosmic Blend: 8% chance of free refill (2x payment)
    if (hasSkill('cosmic_blend') && Math.random() < 0.08) {
        tip *= 2;
        spawnFloatingNumber(customer.pos.x, customer.pos.y - 60, ' REFILL!', 'combo');
    }
    
    // GOLD RUSH ABILITY  3x tips for next N serves
    if (GS._goldRushServes && GS._goldRushServes > 0) {
        tip = Math.floor(tip * 3);
        GS._goldRushServes--;
        spawnFloatingNumber(customer.pos.x, customer.pos.y - 60, ' GOLD RUSH!', 'combo');
        if (GS._goldRushServes <= 0) showNotification(' Gold Rush ended!');
    }
    
    // PET BONUS  tip multiplier
    tip = Math.floor(tip * getPetBonuses().tips);
    
    // LOYALTY BONUS  regulars tip more
    tip = Math.floor(tip * getLoyaltyBonuses(customer.char).tipBonus);
    
    // SPECIAL EVENT BONUSES - Tip tornado, jackpot customer
    const eventTipMult = GS._tipMultiplier || 1;
    tip = Math.floor(tip * eventTipMult);
    
    // Jackpot customer - 5x tip!
    if (GS._nextJackpot) {
        tip = tip * 5;
        GS._nextJackpot = false;
        showNotification(' JACKPOT! 5x TIP!!!');
        spawnParticleBurst(customer.pos.x, customer.pos.y, '#ffd700', 25);
        spawnSparkles(customer.pos.x, customer.pos.y, 20);
        playSound('levelup');
    }
    
    // Night owl tracking
    if (currentPhase && currentPhase.name === 'Late Night') {
        GS._nightOwlServed = (GS._nightOwlServed || 0) + 1;
    }
    
    // Achievement tracking
    if (customer.happiness === 100) {
        GS._perfectServes = (GS._perfectServes || 0) + 1;
    }
    // Track relationship + legacy counters + bounties + loyalty
    trackCharServe(customer.char);
    trackLoyaltyVisit(customer.char);
    trackBountyServe(customer.order, customer);
    if (customer.char === 'walter') {
        GS._walterServed = (GS._walterServed || 0) + 1;
    }
    if (customer.char === 'carl') {
        GS._carlServed = (GS._carlServed || 0) + 1;
    }
    if (customer.char === 'zix') {
        GS._zixServed = (GS._zixServed || 0) + 1;
    }
    if (customer.char === 'blorb') {
        GS._blorbServed = (GS._blorbServed || 0) + 1;
    }
    
    // SPECIAL EVENT - Food Critic handling
    if (GS._criticActive && customer.isVip) {
        GS._criticActive = false;
        if (customer.happiness >= 70) {
            // Good review from critic!
            GS.reputation += 25;
            showNotification(' CRITIC IMPRESSED! +25 Reputation!');
            spawnParticleBurst(customer.pos.x, customer.pos.y, '#00ff88', 20);
            playSound('levelup');
        } else {
            // Bad review
            GS.reputation = Math.max(0, GS.reputation - 15);
            showNotification(' BAD REVIEW! -15 Reputation!');
            spawnParticleBurst(customer.pos.x, customer.pos.y, '#ff0000', 15);
            playSound('angry');
        }
    }
    
    // CHARACTER FAVORITE DRINK BONUS!
    let favoriteBonus = 0;
    const charData = CHAR_DATA[customer.char];
    if (charData && charData.favorites && charData.favorites.includes(customer.order)) {
        const favMult = hasSkill('secret_recipe') ? 0.75 : 0.5;
        favoriteBonus = Math.floor(d.price * favMult); // 50% (or 75% with Secret Recipe) bonus credits
        const bonusXP = Math.floor(d.xp * 0.5); // 50% bonus XP
        GS.credits += favoriteBonus;
        GS.xp += bonusXP;
        GS.totalEarned += favoriteBonus;
        
        // Track unique favorites served
        if (!GS._favoritesServed) GS._favoritesServed = [];
        const favKey = `${customer.char}_${customer.order}`;
        if (!GS._favoritesServed.includes(favKey)) {
            GS._favoritesServed.push(favKey);
        }
        
        // Visual celebration!
        showNotification(` ${charData.name} LOVED their ${d.name}! +50% bonus!`);
        spawnParticleBurst(customer.x, customer.y, '#ff66ff', 12);
        spawnSparkles(customer.x, customer.y, 8);
        spawnFloatingNumber(customer.x - 15, customer.y - 40, `+${favoriteBonus}`, 'combo');
        spawnFloatingNumber(customer.x + 15, customer.y - 40, `+${bonusXP}`, 'xp');
        playSound('levelup');
        addLog(` ${charData.name} got their favorite! +${favoriteBonus}Cr +${bonusXP}XP`, 'tip');
    }
    
    // DAILY SPECIAL BONUS
    let dailySpecialBonus = 0;
    const dailySpecial = getDailySpecial();
    if (customer.order === dailySpecial) {
        const specBonus = getDailySpecialBonus();
        const extraCredits = Math.floor(d.price * (specBonus.creditMult - 1));
        dailySpecialBonus = extraCredits;
        GS.credits += extraCredits;
        GS.totalEarned += extraCredits;
        GS._dailySpecialsServed = (GS._dailySpecialsServed || 0) + 1;
        showNotification(` DAILY SPECIAL! ${d.name} +${extraCredits} bonus credits!`);
        spawnFloatingNumber(customer.pos.x - 20, customer.pos.y - 55, `+${extraCredits}`, 'combo');
        spawnParticleBurst(customer.pos.x, customer.pos.y, '#ffd700', 10);
        playSound('combo');
        // Track for daily challenges
        updateDailyChallengeProgress('daily_special', GS._dailySpecialsServed);
    }

    const total = d.price + tip;
    GS.credits += total;
    
    // DECORATION BONUSES + PRESTIGE BONUSES + HAPPY HOUR + EVENTS - Apply XP multiplier
    const eventXpMult = GS._xpMultiplier || 1;
    const dailyXpMult = customer.order === dailySpecial ? getDailySpecialBonus().xpMult : 1;
    const xpGained = Math.floor(d.xp * decoBonuses.xp * prestigeBonuses.xpMultiplier * happyHourMult * eventXpMult * getWeatherMult('xp') * getSkillBonuses().xpMult * getRelationshipBonuses().xp * getJukeboxBuff('xp') * dailyXpMult * getPetBonuses().xp);
    GS.xp += xpGained;
    
    GS.totalServed++;
    GS.totalEarned += total;
    
    // Drink Mastery tracking
    trackDrinkMastery(customer.order);
    
    // Rush challenge tracking
    if (GS._rushChallengeActive) {
        const elapsed = performance.now() - GS._rushChallengeStart;
        if (elapsed <= 60000) { // 60 seconds
            GS._rushChallengeServed = (GS._rushChallengeServed || 0) + 1;
            if (GS._rushChallengeServed >= 5) {
                GS._rushChallengeActive = false;
                GS.credits += 150;
                showNotification(' RUSH CHALLENGE COMPLETE! +150 Cr bonus!');
                spawnParticleBurst(BAR_CENTER.x, BAR_CENTER.y, '#ff00ff', 25);
                spawnSparkles(BAR_CENTER.x, BAR_CENTER.y, 15);
                spawnFloatingNumber(BAR_CENTER.x, BAR_CENTER.y, '+150', 'combo');
                playSound('levelup');
            } else {
                addLog(` Rush challenge: ${GS._rushChallengeServed}/5 (${Math.floor((60000 - elapsed)/1000)}s left)`, 'tip');
            }
        } else {
            // Time ran out
            GS._rushChallengeActive = false;
            addLog(' Rush challenge failed! Time\'s up.', 'bad');
        }
    }
    
    // Update daily challenges
    updateDailyChallengeProgress('serve_drinks', GS.totalServed);
    updateDailyChallengeProgress('earn_credits', GS.totalEarned);
    if (customer.happiness === 100) {
        updateDailyChallengeProgress('perfect_serve', (dailyProgress.perfect_serve || 0) + 1);
    }
    if (customer.happiness >= 80) {
        updateDailyChallengeProgress('happy_customers', (dailyProgress.happy_customers || 0) + 1);
    }
    if (customer.isVip) {
        updateDailyChallengeProgress('vip_serve', (dailyProgress.vip_serve || 0) + 1);
    }
    
    customer.state = 'drinking';
    customer.drinkTimer = 3000;
    customer._wasServed = true; // Flag for review system
    customer._finalHappiness = customer.happiness; // Store happiness at service time
    
    // Departure star rating
    const hp = customer.happiness;
    const starCount = hp >= 95 ? 5 : hp >= 75 ? 4 : hp >= 55 ? 3 : hp >= 35 ? 2 : 1;
    customer._departRating = ''.repeat(starCount);
    customer._departRatingTimer = 2500;
    
    if (tip > 0) trackBountyTip(tip);
    const vipStr = customer.isVip ? ' ' : '';
    const tipStr = tip > 0 ? ` (+${tip} tip!${vipStr})` : '';
    addLog(` +${total} credits from ${CHAR_DATA[customer.char].name}${tipStr}`, 'earn');
    showNotification(`${d.icon} Served! +${total} credits${tipStr}`);
    playSound('serve');
    
    // Drink delivery trail animation
    spawnDrinkTrail(MARY_POS.x, MARY_POS.y, customer.pos.x, customer.pos.y, d.color, d.icon);
    
    // ===== ENHANCED VISUAL EFFECTS =====
    // Floating numbers for credits and XP
    spawnFloatingNumber(customer.pos.x, customer.pos.y, `+${total}`, 'credits');
    spawnFlyingCoin(customer.pos.x, customer.pos.y);
    spawnFloatingNumber(customer.pos.x + 20, customer.pos.y, `+${d.xp} XP`, 'xp');
    
    // Particle burst - color based on happiness
    let particleColor = '#ffd700'; // Gold default
    if (customer.happiness > 90) {
        particleColor = '#ff00ff'; // Purple for excellent
        spawnSparkles(customer.pos.x, customer.pos.y, 8);
    } else if (customer.happiness > 75) {
        particleColor = '#00ff88'; // Green for great
        spawnSparkles(customer.pos.x, customer.pos.y, 4);
    } else if (customer.happiness < 50) {
        particleColor = '#ff6600'; // Orange for poor
    }
    spawnParticleBurst(customer.pos.x, customer.pos.y, particleColor, customer.isVip ? 16 : 10);
    
    // Extra effects for VIPs
    if (customer.isVip) {
        spawnSparkles(customer.pos.x, customer.pos.y, 10);
        setTimeout(() => spawnParticleBurst(customer.pos.x, customer.pos.y, '#ffd700', 12), 200);
    }
    
    // Floating emoji animation
    const emojis = customer.happiness > 75 ? ['', '', ''] : ['', ''];
    if (customer.isVip) emojis.push('');
    spawnFloatingEmojis(customer.pos.x, customer.pos.y, emojis);
    
    // Gift drop system  rare drops from happy customers
    maybeDropGift(customer);
    
    // Combo system
    comboCount++;
    trackBountyCombo(comboCount);
    comboTimer = (5000 + (GS._comboTimerBonus || 0)) * getPetBonuses().combo;  // EVENT BONUS + pet combo bonus
    // Track max combo for achievements/quests
    if (comboCount > (GS._maxCombo || 0)) GS._maxCombo = comboCount;
    updateDailyChallengeProgress('combo_streak', comboCount);
    if (comboCount >= 3) {
        const bonus = comboCount * 5;
        GS.credits += bonus;
        showCombo(comboCount, bonus);
        playSound('combo');
        // Fireworks at milestone combos!
        if (comboCount === 5 || comboCount === 10 || comboCount === 15 || comboCount === 25 || comboCount === 50) {
            spawnComboFireworks(comboCount);
        }
    }
    
    // Drink synergy check
    checkDrinkSynergy(customer.order);
    
    // Random quip while drinking
    setTimeout(() => {
        if (customer.state === 'drinking') {
            customer.quip = CHAR_DATA[customer.char].quips[Math.floor(Math.random() * CHAR_DATA[customer.char].quips.length)];
            customer.quipTimer = 3000;
        }
    }, 1000);
    
    const weatherRepMult = getWeatherMult('repMult');
    const repChange = customer.happiness > 60 ? Math.ceil(2 * weatherRepMult * getRelationshipBonuses().repGain) : -1;
    GS.reputation = Math.min(100, GS.reputation + repChange);
    checkLevelUp();
    updateHUD();
    checkAchievements(); // Check for unlocked achievements
}

// ==================== BARTENDER ABILITIES ====================
const ABILITIES = [
    {
        name: 'Hyper Mix', icon: '', key: 'z',
        duration: 8000, cooldown: 45000, unlockLevel: 3,
        desc: '3x prep speed for 8s',
        onActivate: () => {
            GS._abilityPrepMult = 3;
            showNotification(' HYPER MIX! 3x prep speed!');
            spawnScreenFlash('#00aaff', 0.3);
        },
        onDeactivate: () => { GS._abilityPrepMult = 1; },
    },
    {
        name: 'Charm Wave', icon: '', key: 'x',
        duration: 0, cooldown: 60000, unlockLevel: 5,
        desc: 'All customers +30 happiness',
        onActivate: () => {
            let count = 0;
            for (const c of GS.customers) {
                if (c.state === 'waiting' || c.state === 'ordered') {
                    c.happiness = Math.min(100, c.happiness + 30);
                    spawnFloatingEmojis(c.pos.x, c.pos.y, ['', '', '']);
                    count++;
                }
            }
            showNotification(` CHARM WAVE! ${count} customers charmed!`);
            spawnScreenFlash('#ff69b4', 0.3);
        },
        onDeactivate: () => {},
    },
    {
        name: 'Gold Rush', icon: '', key: 'v',
        duration: 0, cooldown: 90000, unlockLevel: 7,
        desc: 'Next 5 serves give 3x tips',
        onActivate: () => {
            GS._goldRushServes = 5;
            showNotification(' GOLD RUSH! Next 5 serves = 3x tips!');
            spawnScreenFlash('#ffd700', 0.3);
        },
        onDeactivate: () => {},
    },
];

// Ability state: { lastUsed: timestamp, activeUntil: timestamp }
let abilityState = [
    { lastUsed: 0, activeUntil: 0 },
    { lastUsed: 0, activeUntil: 0 },
    { lastUsed: 0, activeUntil: 0 },
];

function activateAbility(idx) {
    if (GS.paused || GS.dialogueActive) return;
    const ab = ABILITIES[idx];
    const st = abilityState[idx];
    const now = performance.now();
    
    // Check level requirement
    if (GS.level < ab.unlockLevel) {
        showNotification(` ${ab.name} unlocks at level ${ab.unlockLevel}!`);
        return;
    }
    
    // Check cooldown
    const cdRemain = st.lastUsed + ab.cooldown - now;
    if (cdRemain > 0) {
        showNotification(` ${ab.name} on cooldown: ${Math.ceil(cdRemain/1000)}s`);
        return;
    }
    
    // Activate
    st.lastUsed = now;
    st.activeUntil = ab.duration > 0 ? now + ab.duration : 0;
    ab.onActivate();
    playSound('levelup');
    
    // If has duration, schedule deactivation
    if (ab.duration > 0) {
        setTimeout(() => {
            ab.onDeactivate();
            showNotification(`${ab.icon} ${ab.name} ended`);
        }, ab.duration);
    }
}

function updateAbilityBar() {
    const now = performance.now();
    for (let i = 0; i < ABILITIES.length; i++) {
        const ab = ABILITIES[i];
        const st = abilityState[i];
        const el = document.getElementById(`ability-${i}`);
        const cdEl = document.getElementById(`ability-cd-${i}`);
        if (!el || !cdEl) continue;
        
        // Lock check
        if (GS.level < ab.unlockLevel) {
            el.classList.add('locked');
            continue;
        } else {
            el.classList.remove('locked');
        }
        
        const cdRemain = st.lastUsed + ab.cooldown - now;
        const isActive = st.activeUntil > 0 && now < st.activeUntil;
        
        if (isActive) {
            el.classList.add('active-ability');
            el.classList.remove('on-cooldown');
            cdEl.style.height = '0%';
        } else if (cdRemain > 0) {
            el.classList.remove('active-ability');
            el.classList.add('on-cooldown');
            cdEl.style.height = Math.max(0, (cdRemain / ab.cooldown) * 100) + '%';
        } else {
            el.classList.remove('active-ability', 'on-cooldown');
            cdEl.style.height = '0%';
        }
    }
}

function spawnScreenFlash(color, alpha) {
    const flash = document.createElement('div');
    flash.style.cssText = `position:fixed;top:0;left:0;right:0;bottom:0;background:${color};opacity:${alpha};z-index:9999;pointer-events:none;transition:opacity 0.4s`;
    document.body.appendChild(flash);
    requestAnimationFrame(() => { flash.style.opacity = '0'; });
    setTimeout(() => flash.remove(), 500);
}

// ==================== DRINK MASTERY SYSTEM ====================
const MASTERY_LEVELS = [
    { name: 'Novice',      threshold: 0,   color: '#888',    speedBonus: 1.0,  tipBonus: 1.0  },
    { name: 'Apprentice',  threshold: 10,  color: '#44aaff', speedBonus: 1.05, tipBonus: 1.05 },
    { name: 'Skilled',     threshold: 25,  color: '#00ff88', speedBonus: 1.10, tipBonus: 1.10 },
    { name: 'Expert',      threshold: 50,  color: '#ff8800', speedBonus: 1.18, tipBonus: 1.18 },
    { name: 'Master',      threshold: 100, color: '#ff44ff', speedBonus: 1.25, tipBonus: 1.25 },
    { name: 'Legendary',   threshold: 200, color: '#ffd700', speedBonus: 1.35, tipBonus: 1.35 },
];

function getDrinkMasteryLevel(drinkKey) {
    const count = (GS._drinkMastery || {})[drinkKey] || 0;
    let level = MASTERY_LEVELS[0];
    for (let i = MASTERY_LEVELS.length - 1; i >= 0; i--) {
        if (count >= MASTERY_LEVELS[i].threshold) { level = MASTERY_LEVELS[i]; break; }
    }
    return { ...level, count, levelIndex: MASTERY_LEVELS.indexOf(level) };
}

function getDrinkMasteryBonus(drinkKey) {
    const m = getDrinkMasteryLevel(drinkKey);
    return { speedBonus: m.speedBonus, tipBonus: m.tipBonus };
}

function trackDrinkMastery(drinkKey) {
    if (!GS._drinkMastery) GS._drinkMastery = {};
    const prev = GS._drinkMastery[drinkKey] || 0;
    GS._drinkMastery[drinkKey] = prev + 1;
    const newCount = prev + 1;
    // Check for level up
    for (const ml of MASTERY_LEVELS) {
        if (ml.threshold > 0 && prev < ml.threshold && newCount >= ml.threshold) {
            const d = DRINKS[drinkKey];
            showNotification(` ${d.icon} ${d.name} Mastery: ${ml.name}! Speed +${Math.round((ml.speedBonus-1)*100)}% Tips +${Math.round((ml.tipBonus-1)*100)}%`);
            spawnParticleBurst(BAR_CENTER.x, BAR_CENTER.y, ml.color, 20);
            spawnSparkles(BAR_CENTER.x, BAR_CENTER.y, 12);
            playSound('levelup');
            break;
        }
    }
}

function toggleMasteryPanel() {
    const panel = document.getElementById('mastery-panel');
    panel.classList.toggle('open');
    if (panel.classList.contains('open')) buildMasteryList();
}

function buildMasteryList() {
    const list = document.getElementById('mastery-list');
    const summary = document.getElementById('mastery-total-summary');
    if (!GS._drinkMastery) GS._drinkMastery = {};
    
    // Summary
    let totalServedMastery = 0;
    let maxedCount = 0;
    const maxThreshold = MASTERY_LEVELS[MASTERY_LEVELS.length - 1].threshold;
    Object.values(GS._drinkMastery).forEach(c => { totalServedMastery += c; if (c >= maxThreshold) maxedCount++; });
    const totalDrinks = Object.keys(DRINKS).filter(k => DRINKS[k].level <= GS.level).length;
    summary.innerHTML = `<span>${totalServedMastery}</span> drinks mastered  <span>${maxedCount}/${totalDrinks}</span> Legendary`;
    
    // Sort: unlocked first, then by mastery count desc
    const drinkKeys = Object.keys(DRINKS).sort((a, b) => {
        const aUnlocked = DRINKS[a].level <= GS.level;
        const bUnlocked = DRINKS[b].level <= GS.level;
        if (aUnlocked !== bUnlocked) return bUnlocked - aUnlocked;
        return ((GS._drinkMastery[b] || 0) - (GS._drinkMastery[a] || 0));
    });
    
    let html = '';
    for (const key of drinkKeys) {
        const d = DRINKS[key];
        const unlocked = d.level <= GS.level;
        const m = getDrinkMasteryLevel(key);
        const nextLevel = MASTERY_LEVELS[m.levelIndex + 1];
        const isMax = !nextLevel;
        const progress = isMax ? 100 : Math.min(100, ((m.count - MASTERY_LEVELS[m.levelIndex].threshold) / (nextLevel.threshold - MASTERY_LEVELS[m.levelIndex].threshold)) * 100);
        const rankClass = m.name.toLowerCase();
        const itemClass = !unlocked ? 'mastery-item locked' : isMax ? 'mastery-item max-level' : 'mastery-item';
        
        const bonusText = m.levelIndex > 0 
            ? `-${Math.round((1 - 1/m.speedBonus)*100)}% prep  +${Math.round((m.tipBonus-1)*100)}% tips`
            : 'No bonus yet  keep serving!';
        const nextText = nextLevel ? `Next: ${nextLevel.name} at ${nextLevel.threshold}` : ' MAX MASTERY ';
        
        html += `<div class="${itemClass}">
            <div class="mastery-icon">${d.icon}</div>
            <div class="mastery-info">
                <div class="mastery-name">${d.name} <span class="mastery-rank ${rankClass}">${m.name}</span></div>
                <div class="mastery-bonus">${bonusText}</div>
                <div class="mastery-progress"><div class="mastery-progress-inner" style="width:${progress}%"></div></div>
            </div>
            <div class="mastery-count">${m.count}${nextLevel ? '/' + nextLevel.threshold : ''}<br><span style="font-size:9px;color:#666">${nextText}</span></div>
        </div>`;
    }
    list.innerHTML = html;
}

// ==================== DRINK SYNERGY SYSTEM ====================
const DRINK_SYNERGIES = [
    { drinks: ['cosmic_martini', 'nebula_shot'],    name: ' Stellar Fusion',    bonus: 100, desc: 'Stars collide!' },
    { drinks: ['rocket_fuel', 'solar_punch'],       name: ' Solar Ignition',    bonus: 150, desc: 'Explosive combo!' },
    { drinks: ['void_brew', 'dark_matter'],         name: ' Event Horizon',     bonus: 200, desc: 'Beyond the veil!' },
    { drinks: ['moon_milk', 'starlight_fizz'],      name: ' Moonbeam',           bonus: 120, desc: 'Dreamy vibes!' },
    { drinks: ['big_bang', 'black_hole_brew'],       name: ' Universal Reset',   bonus: 300, desc: 'Reality bends!' },
    { drinks: ['warp_whiskey', 'gravity_well'],      name: ' Spacetime Twist',   bonus: 180, desc: 'Time slows down!' },
    { drinks: ['aurora_ale', 'quasar_cooler'],       name: ' Prismatic Blast',   bonus: 130, desc: 'Colors everywhere!' },
    { drinks: ['quantum_cola', 'time_warp_tea'],     name: ' Quantum Entangle',  bonus: 250, desc: 'Two drinks, one reality!' },
    { drinks: ['alien_absinthe', 'galaxy_swirl'],    name: ' Alien Awakening',   bonus: 220, desc: 'Third eye opens!' },
    { drinks: ['plasma_punch', 'comet_tail'],        name: ' Plasma Comet',      bonus: 140, desc: 'Streaking through space!' },
    { drinks: ['dinosaur_daiquiri', 'walters_regret'],name: ' Extinction Event', bonus: 350, desc: "Walter's hangover returns!" },
    { drinks: ['pulsar_mojito', 'supernova_sour'],   name: ' Superpulse',        bonus: 200, desc: 'Energy overload!' },
];

let recentServes = []; // { drink, time }

function checkDrinkSynergy(drinkKey) {
    const now = Date.now();
    recentServes.push({ drink: drinkKey, time: now });
    // Keep only last 8 seconds
    recentServes = recentServes.filter(s => now - s.time < 8000);
    
    for (const syn of DRINK_SYNERGIES) {
        const [a, b] = syn.drinks;
        if (drinkKey !== a && drinkKey !== b) continue;
        const other = drinkKey === a ? b : a;
        if (recentServes.some(s => s.drink === other && s.time !== now)) {
            triggerSynergy(syn);
            // Remove matched entries to prevent double-triggering
            recentServes = recentServes.filter(s => s.drink !== a && s.drink !== b);
            return;
        }
    }
}

function triggerSynergy(syn) {
    const bonus = syn.bonus;
    GS.credits += bonus;
    GS.totalEarned += bonus;
    
    // Track synergies for stats
    if (!GS._synergiesTriggered) GS._synergiesTriggered = 0;
    GS._synergiesTriggered++;
    
    // Big flashy notification
    showNotification(`${syn.name}  ${syn.desc} +${bonus}`);
    addLog(` SYNERGY: ${syn.name}! +${bonus} credits!`, 'tip');
    
    // Visual effects  big particle burst at bar center
    spawnParticleBurst(BAR_CENTER.x, BAR_CENTER.y, '#ff00ff', 25);
    spawnParticleBurst(BAR_CENTER.x, BAR_CENTER.y, '#ffd700', 20);
    spawnSparkles(BAR_CENTER.x, BAR_CENTER.y, 15);
    spawnFloatingNumber(BAR_CENTER.x, BAR_CENTER.y - 30, `${syn.name}`, 'combo');
    spawnFloatingNumber(BAR_CENTER.x, BAR_CENTER.y, `+${bonus}`, 'credits');
    
    // Screen shake + sound
    screenShake(4, 300);
    playSound('levelup');
    
    updateHUD();
}

// ==================== CUSTOMER SPAWN / LOGIC ====================
// Track respawn cooldowns per character
const RESPAWN_DELAY = 8000; // ms before character comes back
const charRespawnTimers = { walter: 0, carl: 0, dick: 0 };

function spawnCustomer() {
    const charKeys = ['walter', 'carl', 'dick', 'scally', 'toni', 'glorp', 'zix', 'blorb', 'krax', 'pip'];
    
    for (const char of charKeys) {
        // Skip if already in the bar
        if (GS.customers.some(c => c.char === char)) continue;
        // Skip if on respawn cooldown
        if (charRespawnTimers[char] > 0) continue;
        
        // Find available table
        const usedSpots = new Set(GS.customers.map(c => c.tableIdx));
        const availIdx = [];
        for (let i = 0; i < GS.tables.length && i < TABLE_SPOTS.length; i++) {
            if (!usedSpots.has(i)) availIdx.push(i);
        }
        for (let i = 0; i < BAR_STOOL_SPOTS.length; i++) {
            const bsIdx = TABLE_SPOTS.length + i;
            if (!usedSpots.has(bsIdx)) availIdx.push(bsIdx);
        }
        if (availIdx.length === 0) break;
        
        const tableIdx = availIdx[Math.floor(Math.random() * availIdx.length)];
        const targetPos = tableIdx < TABLE_SPOTS.length 
            ? { ...TABLE_SPOTS[tableIdx] }
            : { ...BAR_STOOL_SPOTS[tableIdx - TABLE_SPOTS.length] };
        
        // Day/night spawn rate modifier
        if (currentPhase && Math.random() > currentPhase.spawnMod) {
            // Rush events override phase spawn limits
            const now = performance.now();
            if (!(GS._megaRushUntil && now < GS._megaRushUntil) && 
                !(GS._rushHourUntil && now < GS._rushHourUntil)) {
                continue;
            }
        }

        // Get decoration bonuses for this customer
        const decoBonuses = getDecorationBonuses();
        
        const cust = {
            id: GS.nextCustId++,
            char,
            state: 'walking',
            pos: { ...ENTRY_POS },
            targetPos,
            happiness: 100 + decoBonuses.happiness + (GS._happinessBonus || 0) + getSkillBonuses().happinessBonus + getRelationshipBonuses().happiness + getJukeboxBuff('happiness') + getPetBonuses().happiness,
            order: null,
            drinkProgress: 0,
            drinkTime: 0,
            drinkTimer: 0,
            tableIdx,
            quip: null,
            quipTimer: 0,
            walkSpeed: 0.12 + Math.random() * 0.04,
            patienceRate: (GS.upgrades.includes('patience_boost') ? 0.7 : 1) * decoBonuses.patience,  // DECORATION BONUS - Patience rate
            facingLeft: false,
            lastX: ENTRY_POS.x,
            isVip: false,
            tipMultiplier: 1,
        };
        
        // Aurora event = extra patience
        const now = performance.now();
        if (GS._auroraUntil && now < GS._auroraUntil) {
            cust.patienceRate *= 0.6;
        }
        
        // Impatient event = less patience
        if (GS._impatientUntil && now < GS._impatientUntil) {
            cust.patienceRate *= 1.5;
        }
        
        // Space weather patience modifier
        const weatherPatience = getWeatherMult('patience');
        if (weatherPatience !== 1) {
            cust.patienceRate *= (2 - weatherPatience); // Invert: higher patience mult = slower drain
        }

        // Jukebox patience buff
        cust.patienceRate *= getJukeboxBuff('patience');

        // Character-specific traits
        if (char === 'zix') {
            cust.patienceRate *= 1.4;    // Nervous robot = impatient
            cust.tipMultiplier *= 1.5;   // But tips generously (anxiety tipping)
            cust.walkSpeed *= 1.3;       // Scurries fast
        } else if (char === 'blorb') {
            cust.patienceRate *= 0.6;    // Super chill blob = very patient
            cust.tipMultiplier *= 0.7;   // Tips less (orders cheap drinks)
            cust.walkSpeed *= 0.7;       // Wobbles slowly
            cust._happinessAura = true;  // Boosts nearby customers
        } else if (char === 'krax') {
            cust.patienceRate *= 1.8;    // Very impatient rock
            cust.tipMultiplier *= 0.5;   // Terrible tipper
            cust.walkSpeed *= 0.6;       // Heavy and slow
            cust.happiness += 10;        // Harder to make unhappy (thick skinned)
        } else if (char === 'pip') {
            cust.patienceRate *= 0.8;    // Fairly patient (easily distracted)
            cust.tipMultiplier *= 2.0;   // Tips 200% (generous fairy)
            cust.walkSpeed *= 1.5;       // Zips around fast
            cust.happiness -= 5;         // Fragile happiness (sensitive)
        }

        // Loyalty patience bonus  regulars are more patient
        cust.patienceRate *= getLoyaltyBonuses(char).patienceBonus;

        // VIP chance
        const vipType = isVipSpawn();
        if (vipType === 'ambassador') {
            cust.char = char; // Keep their personality
            cust._isAmbassador = true;
            makeVip(cust);
        } else if (vipType) {
            makeVip(cust);
        }

        // Entrance animation  randomly pick from 4 types
        const entranceTypes = ['beam', 'portal', 'crashland', 'wormhole'];
        const entranceType = entranceTypes[Math.floor(Math.random() * entranceTypes.length)];
        cust._entranceType = entranceType;
        cust._beamIn = true;
        cust._beamTimer = 0;
        cust._beamDuration = entranceType === 'crashland' ? 1200 : entranceType === 'wormhole' ? 1000 : 800;
        
        GS.customers.push(cust);
    }
}

function updateCustomers(dt) {
    const toRemove = [];
    
    // Tick respawn timers
    for (const char of ['walter', 'carl', 'dick', 'scally', 'toni', 'glorp', 'zix', 'blorb', 'krax', 'pip']) {
        if (charRespawnTimers[char] > 0) charRespawnTimers[char] -= dt;
    }
    
    // Blorb's happiness aura  boost nearby customers' happiness slightly
    const blorb = GS.customers.find(c => c.char === 'blorb' && c.state !== 'leaving' && c.state !== 'walking');
    if (blorb) {
        for (const c of GS.customers) {
            if (c === blorb || c.state === 'leaving' || c.state === 'walking') continue;
            const dx = c.pos.x - blorb.pos.x, dy = c.pos.y - blorb.pos.y;
            if (Math.sqrt(dx*dx + dy*dy) < 250) {
                c.happiness = Math.min(c.happiness + dt * 0.002, 120); // Slow happiness regen
            }
        }
    }
    
    for (const c of GS.customers) {
        // Quip timer
        if (c.quipTimer > 0) c.quipTimer -= dt;
        
        // Track facing direction
        if (c.pos.x !== c.lastX) {
            c.facingLeft = c.pos.x < (c.lastX || c.pos.x);
            c.lastX = c.pos.x;
        }
        
        if (c.state === 'walking') {
            const dx = c.targetPos.x - c.pos.x;
            const dy = c.targetPos.y - c.pos.y;
            const dist = Math.sqrt(dx*dx + dy*dy);
            if (dist < 5) {
                c.state = 'waiting';
                c.pos = { ...c.targetPos };
                // Auto-greet if upgrade
                if (GS.upgrades.includes('auto_greet')) {
                    const avail = Object.keys(DRINKS).filter(k => GS.unlockedDrinks.includes(k));
                    const pick = avail[Math.floor(Math.random() * avail.length)];
                    c.state = 'ordered';
                    c.order = pick;
                    c.drinkProgress = 0;
                    c.drinkTime = DRINKS[pick].time * 1000 * (GS.upgrades.includes('faster_mixing') ? 0.8 : 1) * (GS.upgrades.includes('quantum_mixer') ? 0.6 : 1) * getPetBonuses().speed;
                    addLog(` Auto-ordered ${DRINKS[pick].name} for ${CHAR_DATA[c.char].name}`);
                }
            } else {
                c.pos.x += (dx / dist) * c.walkSpeed * dt;
                c.pos.y += (dy / dist) * c.walkSpeed * dt;
            }
        } else if (c.state === 'waiting') {
            c.happiness -= (dt / 1000) * 3 * c.patienceRate * (GS._patienceRate || 1) * getPetBonuses().patience * getStaffPatienceMult();
            // Random quip
            if (!c.quip && Math.random() < 0.001 * dt) {
                c.quip = CHAR_DATA[c.char].quips[Math.floor(Math.random() * CHAR_DATA[c.char].quips.length)];
                c.quipTimer = 3500;
            }
            if (c.happiness <= 0) {
                c.state = 'leaving';
                c.targetPos = { ...ENTRY_POS };
                c._departRating = '';
                c._departRatingTimer = 2000;
                addLog(` ${CHAR_DATA[c.char].name} left angry!`, 'bad');
                GS.reputation = Math.max(0, GS.reputation - Math.floor(5 * getRelationshipBonuses().repLoss));
                playSound('angry');
                spawnFloatingEmojis(c.pos.x, c.pos.y, ['', '']);
                updateHUD();
            }
        } else if (c.state === 'ordered') {
            const prepSpeedMult = (GS._prepSpeedMult || 1) * (GS._abilityPrepMult || 1) * getSkillBonuses().prepSpeed * getDrinkMasteryBonus(c.order).speedBonus;
            c.drinkProgress += (dt / c.drinkTime) * prepSpeedMult;
            // Lightning Serve: 10% chance per tick to instantly finish
            if (hasSkill('lightning_serve') && c.drinkProgress < 1 && Math.random() < 0.0002 * dt) {
                c.drinkProgress = 1;
                spawnFloatingNumber(c.pos.x, c.pos.y - 40, 'INSTANT!', 'combo');
            }
            const patienceBonus = 1 - (GS._patienceBonus || 0);  // EVENT BONUS - Less patience drain
            c.happiness -= (dt / 1000) * 1.5 * c.patienceRate * patienceBonus * (GS._patienceRate || 1) * getStaffPatienceMult();
            if (c.drinkProgress >= 1) {
                c.drinkProgress = 1;
                if (!c._readyNotified) {
                    c._readyNotified = true;
                    addLog(` ${DRINKS[c.order].name} ready for ${CHAR_DATA[c.char].name}!`);
                    playSound('ready');
                }
            }
            if (c.happiness <= 0) {
                c.state = 'leaving';
                c.targetPos = { ...ENTRY_POS };
                c._departRating = '';
                c._departRatingTimer = 2000;
                addLog(` ${CHAR_DATA[c.char].name} left  too slow!`, 'bad');
                GS.reputation = Math.max(0, GS.reputation - Math.floor(5 * getRelationshipBonuses().repLoss));
                playSound('angry');
                spawnFloatingEmojis(c.pos.x, c.pos.y, ['', '']);
                updateHUD();
            }
        } else if (c.state === 'drinking') {
            c.drinkTimer -= dt;
            if (c.drinkTimer <= 0) {
                c.state = 'leaving';
                c.targetPos = { ...ENTRY_POS };
            }
        } else if (c.state === 'leaving') {
            const dx = c.targetPos.x - c.pos.x;
            const dy = c.targetPos.y - c.pos.y;
            const dist = Math.sqrt(dx*dx + dy*dy);
            if (dist < 10) {
                toRemove.push(c.id);
                charRespawnTimers[c.char] = RESPAWN_DELAY;
                
                // Leave a review if they were served (had an order)
                if (c._wasServed) {
                    addCustomerReview(c, c._finalHappiness || c.happiness);
                }
            } else {
                c.pos.x += (dx / dist) * 0.15 * dt;
                c.pos.y += (dy / dist) * 0.15 * dt;
            }
        }
    }
    
    GS.customers = GS.customers.filter(c => !toRemove.includes(c.id));
}

// ==================== LEVEL UP ====================
function checkLevelUp() {
    let leveledUp = false;
    let newUnlocks = [];

    while (GS.xp >= GS.xpNeeded) {
        GS.xp -= GS.xpNeeded;
        GS.level++;
        GS.xpNeeded = Math.floor(GS.xpNeeded * 1.4);
        leveledUp = true;
        
        // Unlock drinks
        Object.entries(DRINKS).forEach(([k,v]) => {
            if (v.level <= GS.level && !GS.unlockedDrinks.includes(k)) {
                GS.unlockedDrinks.push(k);
                newUnlocks.push({ type: 'drink', name: v.name, icon: v.icon });
            }
        });
        
        // Unlock furniture/decor (check levels)
        Object.values(FURNITURE).forEach(v => {
            if (v.level === GS.level) newUnlocks.push({ type: 'furniture', name: v.name, icon: v.icon });
        });
        Object.values(DECORATIONS).forEach(v => {
            if (v.level === GS.level) newUnlocks.push({ type: 'decor', name: v.name, icon: v.icon });
        });
        Object.values(UPGRADES).forEach(v => {
            if (v.level === GS.level) newUnlocks.push({ type: 'upgrade', name: v.name, icon: v.icon });
        });

        checkAchievements(); // Check for level achievements
    }

    if (leveledUp) {
        showLevelUpScreen(GS.level, newUnlocks);
        playSound('levelup');
        screenShake();
    }
    updateHUD();
}

function showLevelUpScreen(level, unlocks) {
    const overlay = document.getElementById('levelup-overlay');
    document.getElementById('levelup-badge').textContent = level;
    
    const list = document.getElementById('levelup-list');
    list.innerHTML = '';
    
    if (unlocks.length > 0) {
        unlocks.forEach(u => {
            const div = document.createElement('div');
            div.className = 'levelup-item';
            div.innerHTML = `<span class="icon">${u.icon}</span> New ${u.type}: ${u.name}`;
            list.appendChild(div);
        });
    } else {
        list.innerHTML = '<div class="levelup-item">Higher stats!</div>';
    }
    
    overlay.classList.add('show');
    GS.dialogueActive = true; // Pause game
    
    // Fireworks effect behind the box
    for(let i=0; i<5; i++) {
        setTimeout(() => {
            spawnParticleBurst(W/2 + (Math.random()-0.5)*300, H/2 + (Math.random()-0.5)*300, 
                ['#ff0000', '#00ff00', '#0000ff', '#ffff00'][Math.floor(Math.random()*4)], 30);
        }, i * 200);
    }
}

function closeLevelUp() {
    document.getElementById('levelup-overlay').classList.remove('show');
    GS.dialogueActive = false; // Resume game
    
    // Trigger level milestone dialogues
    const milestoneKey = 'level_' + GS.level;
    if (DIALOGUE_DATA[milestoneKey]) {
        setTimeout(() => showDialogue(milestoneKey), 500);
    }
}

// ==================== SHOP ====================
function buildShop() {
    const grid = document.getElementById('shop-grid');
    const skillContainer = document.getElementById('skill-tree-container');
    
    if (GS.shopTab === 'skills') {
        grid.style.display = 'none';
        skillContainer.style.display = 'block';
        buildSkillTree();
        return;
    }
    grid.style.display = 'grid';
    skillContainer.style.display = 'none';
    grid.innerHTML = '';
    
    let items;
    if (GS.shopTab === 'furniture') items = FURNITURE;
    else if (GS.shopTab === 'upgrades') items = UPGRADES;
    else items = DECORATIONS;
    
    Object.entries(items).forEach(([key, item]) => {
        const locked = item.level > GS.level;
        const owned = GS.shopTab === 'upgrades' ? GS.upgrades.includes(key) : 
                      GS.shopTab === 'decorations' ? GS.decorations.includes(key) : false;
        
        const div = document.createElement('div');
        div.className = 'shop-item' + (locked || owned ? ' locked' : '');
        
        // For decorations, show bonus effect
        let bonusText = '';
        if (GS.shopTab === 'decorations' && item.bonus) {
            bonusText = `<div style="color:#00ff88;font-size:10px;margin-top:2px;font-weight:bold"> ${item.bonus.desc}</div>`;
        } else if (item.desc) {
            bonusText = `<div style="color:#88ccdd;font-size:10px;margin-top:2px">${item.desc}</div>`;
        }
        
        div.innerHTML = `
            <div class="item-icon">${item.icon}</div>
            <div class="item-name">${item.name}</div>
            ${owned ? '<div class="item-lock"> Owned</div>' :
              locked ? `<div class="item-lock"> Level ${item.level}</div>` :
              `<div class="item-price">${item.price} </div>`}
            ${bonusText}
        `;
        
        if (!locked && !owned) {
            div.onclick = () => buyItem(GS.shopTab, key);
        }
        grid.appendChild(div);
    });
}

function buyItem(category, key) {
    let item, list;
    if (category === 'furniture') { item = FURNITURE[key]; }
    else if (category === 'upgrades') { item = UPGRADES[key]; list = GS.upgrades; }
    else { item = DECORATIONS[key]; list = GS.decorations; }
    
    if (GS.credits < item.price) { showNotification(' Not enough credits!'); return; }
    
    GS.credits -= item.price;
    
    if (category === 'furniture') {
        GS.inventory[key] = (GS.inventory[key] || 0) + 1;
        addLog(` ${item.name}  Inventory!`, 'earn');
        if (GS.invOpen) buildInventory();
    } else if (category === 'upgrades') {
        GS.upgrades.push(key);
        addLog(` Upgraded: ${item.name}!`, 'earn');
        // Apply spawn rate for happy hour
        if (key === 'happy_hour') GS.spawnInterval = Math.max(3000, GS.spawnInterval - 1500);
    } else {
        // Decorations - add to decorations list (passive bonuses)
        GS.decorations.push(key);
        if (item.rep) {
            GS.reputation += item.rep;
            addLog(` ${item.name} installed! +${item.rep} Rep`, 'earn');
        }
        if (item.bonus) {
            addLog(` Bonus active: ${item.bonus.desc}`, 'tip');
        }
    }
    
    showNotification(` Bought ${item.name}!`);
    playSound('buy');
    
    // ===== PURCHASE VISUAL EFFECTS =====
    spawnSparkles(BAR_CENTER.x, BAR_CENTER.y, 6);
    spawnParticleBurst(BAR_CENTER.x, BAR_CENTER.y, '#00ff88', 10);
    spawnFloatingNumber(BAR_CENTER.x, BAR_CENTER.y, `-${item.price}`, 'credits');
    
    updateHUD();
    buildShop();
    checkAchievements(); // Check for collection achievements
    save();
}

function showDrinksInfo() {
    const unlocked = Object.entries(DRINKS).filter(([k]) => GS.unlockedDrinks.includes(k));
    const msg = unlocked.map(([k,d]) => `${d.icon} ${d.name}: ${d.price}`).join(' | ');
    showNotification(' ' + msg);
}

// ==================== INVENTORY & PLACEMENT ====================
function buildInventory() {
    const grid = document.getElementById('inv-grid');
    grid.innerHTML = '';
    const allItems = { ...FURNITURE, ...DECORATIONS };
    const hasItems = Object.entries(GS.inventory).some(([k,v]) => v > 0);
    if (!hasItems) {
        grid.innerHTML = '<div class="inv-empty">No items yet! Buy from the shop </div>';
        return;
    }
    Object.entries(GS.inventory).forEach(([key, qty]) => {
        if (qty <= 0) return;
        const item = allItems[key];
        if (!item) return;
        const div = document.createElement('div');
        div.className = 'inv-item';
        div.innerHTML = `
            <div class="inv-qty">x${qty}</div>
            <div class="inv-icon">${item.icon}</div>
            <div class="inv-name">${item.name}</div>
        `;
        div.onclick = () => startPlacement(key);
        grid.appendChild(div);
    });
}

function startPlacement(key) {
    const allItems = { ...FURNITURE, ...DECORATIONS };
    const item = allItems[key];
    if (!item || (GS.inventory[key] || 0) <= 0) return;
    const cat = FURNITURE[key] ? 'furniture' : 'decorations';
    GS.placementMode = { type: key, category: cat };
    GS.placementPos = null;
    GS.placementValid = false;
    GS.invOpen = false;
    document.getElementById('inv-panel').classList.remove('open');
    document.getElementById('placement-banner').classList.add('show');
    document.getElementById('placement-banner').textContent = ` Placing ${item.name}  Click to place, ESC/Right-click to cancel`;
    canvas.style.cursor = 'crosshair';
}

// ==================== KEYBOARD SHORTCUTS ====================
function handleKeyboard(e) {
    // Don't process if dialogue is active or typing in input
    if (GS.dialogueActive) {
        if (e.key === 'Enter' || e.key === ' ') advanceDialogue();
        return;
    }
    if (e.target.tagName === 'INPUT' || e.target.tagName === 'TEXTAREA') return;
    
    const key = e.key.toLowerCase();
    
    // ESC - Cancel placement / close panels
    if (e.key === 'Escape') {
        cancelPlacement();
        closeAllPanels();
        return;
    }
    
    // Number keys 1-9, 0 - Quick-select drinks from menu
    if (key >= '1' && key <= '9' && GS.drinkMenuOpen) {
        const idx = parseInt(key) - 1;
        const drinkBtns = document.querySelectorAll('.drink-btn:not(.locked)');
        if (drinkBtns[idx]) drinkBtns[idx].click();
        return;
    }
    
    // SPACE - Serve nearest ready customer
    if (key === ' ') {
        e.preventDefault();
        serveNearestReady();
        return;
    }
    
    // S - Toggle shop
    if (key === 's' && !e.ctrlKey) {
        const shopPanel = document.getElementById('shop-panel');
        if (shopPanel) shopPanel.classList.toggle('show');
        return;
    }
    
    // Q - Toggle quest log
    if (key === 'q') {
        const questPanel = document.getElementById('quest-panel');
        if (questPanel) questPanel.classList.toggle('show');
        return;
    }
    
    // R - Toggle recipe book
    if (key === 'r') {
        toggleRecipeBook();
        return;
    }
    
    // T - Toggle stats
    if (key === 't') {
        const statsPanel = document.getElementById('stats-panel');
        if (statsPanel) statsPanel.classList.toggle('show');
        return;
    }
    
    // A - Toggle achievements
    if (key === 'a') {
        const achPanel = document.getElementById('achievements-panel');
        if (achPanel) achPanel.classList.toggle('show');
        return;
    }
    
    // + / - Speed controls
    if (key === '=' || key === '+') {
        GS.gameSpeed = Math.min(3, GS.gameSpeed + 0.5);
        showNotification(` Speed: ${GS.gameSpeed}x`);
        return;
    }
    if (key === '-') {
        GS.gameSpeed = Math.max(0.5, GS.gameSpeed - 0.5);
        showNotification(` Speed: ${GS.gameSpeed}x`);
        return;
    }
    
    // H - Show help/shortcuts
    if (key === 'h') {
        showShortcutsHelp();
        return;
    }
    
    // Ability hotkeys Z, X, V
    for (let i = 0; i < ABILITIES.length; i++) {
        if (key === ABILITIES[i].key) {
            activateAbility(i);
            return;
        }
    }
}

function serveNearestReady() {
    // Find the nearest customer with a ready drink
    let nearest = null;
    let nearestDist = Infinity;
    
    for (const c of GS.customers) {
        if (c.state === 'ordered' && c.drinkProgress >= 1) {
            // Use screen position for "nearest to center"
            const s = w2s(c.pos.x, c.pos.y);
            const dist = Math.sqrt((s.x - W/2) ** 2 + (s.y - H/2) ** 2);
            if (dist < nearestDist) {
                nearestDist = dist;
                nearest = c;
            }
        }
    }
    
    if (nearest) {
        serveDrink(nearest);
    } else {
        showNotification('No drinks ready to serve!');
    }
}

function closeAllPanels() {
    jukeboxOpen = false;
    const jp = document.getElementById('jukebox-panel');
    if (jp) jp.classList.remove('open');
    const sp = document.getElementById('staff-panel');
    if (sp) sp.style.display = 'none';
    ['shop-panel', 'quest-panel', 'stats-panel', 'achievements-panel', 'recipe-book', 'pet-panel', 'loyalty-panel'].forEach(id => {
        const el = document.getElementById(id);
        if (el) el.classList.remove('show');
    });
}

function showShortcutsHelp() {
    showNotification(
        ' SHORTCUTS: [Space] Serve | [S] Shop | [Q] Quests | [R] Recipes | [T] Stats | [A] Achievements | [H] Help | [+/-] Speed | [Esc] Close'
    );
}

function cancelPlacement() {
    if (!GS.placementMode) return;
    GS.placementMode = null;
    GS.placementPos = null;
    document.getElementById('placement-banner').classList.remove('show');
    canvas.style.cursor = 'grab';
    showNotification(' Placement cancelled');
}

function isValidPlacement(pos) {
    if (!imgs.map) return false;
    // Must be within map bounds
    if (pos.x < 50 || pos.x > imgs.map.width - 50 || pos.y < 100 || pos.y > imgs.map.height - 50) return false;
    // Not too close to bar area
    const bdx = pos.x - BAR_CENTER.x, bdy = pos.y - BAR_CENTER.y;
    if (Math.sqrt(bdx*bdx + bdy*bdy) < 120) return false;
    // Not too close to other placed furniture
    for (const f of GS.placedFurniture) {
        const dx = pos.x - f.x, dy = pos.y - f.y;
        if (Math.sqrt(dx*dx + dy*dy) < 60) return false;
    }
    return true;
}

function placeFurnitureAt(placement, pos) {
    const key = placement.type;
    if ((GS.inventory[key] || 0) <= 0) { cancelPlacement(); return; }
    GS.inventory[key]--;
    const item = FURNITURE[key] || DECORATIONS[key];
    GS.placedFurniture.push({ type: key, x: pos.x, y: pos.y });

    // Apply effects
    if (FURNITURE[key]) {
        // Add as a table spot for customers
        GS.tables.push({ type: key, spotIndex: GS.tables.length });
        TABLE_SPOTS.push({ x: pos.x, y: pos.y, seats: FURNITURE[key].seats || 2 });
        addLog(` Placed ${item.name}  +${FURNITURE[key].seats} seats!`, 'earn');
    } else if (DECORATIONS[key]) {
        GS.decorations.push(key);
        GS.reputation = Math.min(100, GS.reputation + (item.rep || 5));
        addLog(` Placed ${item.name}! +${item.rep || 5} rep`, 'earn');
    }

    showNotification(` ${item.name} placed!`);
    playSound('buy');
    updateHUD();
    checkAchievements(); // Check for furniture placement achievements
    save();

    // Continue placing if more in inventory
    if ((GS.inventory[key] || 0) > 0) {
        // Stay in placement mode
    } else {
        cancelPlacement();
    }
}

function drawPlacedFurniture() {
    ctx.globalAlpha = 1.0;
    const allItems = { ...FURNITURE, ...DECORATIONS };
    for (const f of GS.placedFurniture) {
        const item = allItems[f.type];
        if (!item) continue;
        const s = w2s(f.x, f.y);
        // Shadow
        ctx.fillStyle = 'rgba(0,0,0,0.3)';
        ctx.beginPath();
        ctx.ellipse(s.x, s.y + 2*cam.zoom, 20*cam.zoom, 8*cam.zoom, 0, 0, Math.PI*2);
        ctx.fill();
        // Icon
        ctx.font = `${32*cam.zoom}px Arial`;
        ctx.textAlign = 'center';
        ctx.fillText(item.icon, s.x, s.y);
        // Label
        ctx.font = `bold ${9*cam.zoom}px Nunito`;
        ctx.fillStyle = '#ffd700';
        ctx.fillText(item.name, s.x, s.y + 16*cam.zoom);
    }
}

function drawPlacementGhost() {
    if (!GS.placementMode || !GS.placementPos) return;
    const allItems = { ...FURNITURE, ...DECORATIONS };
    const item = allItems[GS.placementMode.type];
    if (!item) return;
    const s = w2s(GS.placementPos.x, GS.placementPos.y);
    const valid = GS.placementValid;

    ctx.globalAlpha = 0.6;
    // Highlight circle
    ctx.fillStyle = valid ? 'rgba(0,255,136,0.25)' : 'rgba(255,50,50,0.25)';
    ctx.beginPath();
    ctx.arc(s.x, s.y, 30*cam.zoom, 0, Math.PI*2);
    ctx.fill();
    ctx.strokeStyle = valid ? '#00ff88' : '#ff3333';
    ctx.lineWidth = 2*cam.zoom;
    ctx.stroke();
    // Icon
    ctx.font = `${32*cam.zoom}px Arial`;
    ctx.textAlign = 'center';
    ctx.fillText(item.icon, s.x, s.y);
    ctx.globalAlpha = 1;
}

// ==================== RENDERING ====================
let lastTime = performance.now();

function gameLoop(now) {
    const rawDt = Math.min(now - lastTime, 100);
    const dt = rawDt * GS.gameSpeed;
    lastTime = now;
    
    // Pause if dialogue is active
    if (GS.dialogueActive) {
        render(); // Still draw the game
        requestAnimationFrame(gameLoop);
        return;
    }
    
    if (GS.started) {
        update(dt);
        updateDayNight(dt);
        updateRandomEvents(dt);
        // Combo timer decay
        if (comboTimer > 0) { comboTimer -= rawDt; if (comboTimer <= 0) comboCount = 0; }
        // Periodic achievement & quest check
        if (Math.floor(now / 2000) !== Math.floor((now - rawDt) / 2000)) {
            checkAchievements();
            checkQuests();
        }
        // Check for random happy hour trigger
        checkHappyHourTrigger();
    }
    // Ambient characters always update (even before game start)
    updateAmbientChars(rawDt);
    render();
    requestAnimationFrame(gameLoop);
}

function update(dt) {
    // Spawn check - modified by rush events
    GS.lastSpawn += dt;
    let spawnInterval = 2000;
    const now = performance.now();
    
    // Mega rush = spawn every 500ms (4x faster)
    if (GS._megaRushUntil && now < GS._megaRushUntil) {
        spawnInterval = 500;
    }
    // Tourist wave = spawn every 1000ms (2x faster)
    else if (GS._rushHourUntil && now < GS._rushHourUntil) {
        spawnInterval = 1000;
    }
    
    // Space weather spawn rate modifier
    spawnInterval = Math.floor(spawnInterval / getWeatherMult('spawnRate'));
    
    if (GS.lastSpawn > spawnInterval) {
        spawnCustomer();
        GS.lastSpawn = 0;
    }
    
    updateCustomers(dt);
    updateCustomerConversations(dt);
    updatePet(dt);
    updateStaff(dt);
    
    // Helper Droid auto-serve
    if (GS.upgrades.includes('helper_bot')) {
        if (!GS._helperTimer) GS._helperTimer = 0;
        GS._helperTimer += dt;
        const helperInterval = GS.upgrades.includes('quantum_mixer') ? 10000 : 15000;
        if (GS._helperTimer >= helperInterval) {
            GS._helperTimer = 0;
            const ready = GS.customers.find(c => c.state === 'ordered' && c.drinkProgress >= 1);
            if (ready) {
                serveDrink(ready);
                addLog(` Helper Droid served ${DRINKS[ready.order].name} to ${CHAR_DATA[ready.char].name}!`, 'earn');
                spawnFloatingNumber(ready.pos.x, ready.pos.y - 30, '', 'combo');
            }
        }
    }
    
    // Update daily challenge reputation tracking
    if (dailyChallenges.length > 0) {
        for (const challenge of dailyChallenges) {
            if (challenge.id === 'reputation') {
                updateDailyChallengeProgress('reputation', GS.reputation);
            }
        }
    }
    
    // Auto-save every 10s
    if (Math.floor(now / 10000) !== Math.floor((now - dt) / 10000)) save();
    
    // Check for random special events
    updateSpecialEvents(dt);
    
    // Update space forecast
    updateSpaceForecast(dt);
    
    // Update rush meter
    updateRushMeter(dt);
    updateBounties(dt);
}

// ==================== SPECIAL RANDOM EVENTS ====================
const SPECIAL_EVENTS = {
    tip_tornado: {
        name: ' TIP TORNADO!',
        desc: 'All tips are DOUBLED for 30 seconds!',
        duration: 30000,
        color: '#ffd700',
        onStart: () => { GS._tipMultiplier = 2; },
        onEnd: () => { GS._tipMultiplier = 1; }
    },
    vip_party: {
        name: ' VIP PARTY!',
        desc: 'A group of VIPs just arrived!',
        duration: 0, // instant effect
        color: '#ff00ff',
        onStart: () => {
            for (let i = 0; i < 3; i++) {
                setTimeout(() => {
                    GS._forceVIP = true;
                    spawnCustomer();
                    GS._forceVIP = false;
                }, i * 500);
            }
        }
    },
    happy_surge: {
        name: ' HAPPY HOUR SURGE!',
        desc: 'All customers arrive extra happy! +20 starting happiness for 45 seconds.',
        duration: 45000,
        color: '#00ff88',
        onStart: () => { GS._happinessBonus = 20; },
        onEnd: () => { GS._happinessBonus = 0; }
    },
    speed_boost: {
        name: ' SPEED BOOST!',
        desc: 'Drinks prepare 50% faster for 30 seconds!',
        duration: 30000,
        color: '#00ffff',
        onStart: () => { GS._prepSpeedMult = 1.5; if (hasSkill('time_warp')) SPECIAL_EVENTS.speed_boost.duration = 60000; },
        onEnd: () => { GS._prepSpeedMult = 1; SPECIAL_EVENTS.speed_boost.duration = 30000; }
    },
    patience_aura: {
        name: ' PATIENCE AURA!',
        desc: 'Customers are extra patient for 40 seconds!',
        duration: 40000,
        color: '#aaffff',
        onStart: () => { GS._patienceBonus = 0.5; },
        onEnd: () => { GS._patienceBonus = 0; }
    },
    jackpot_customer: {
        name: ' JACKPOT CUSTOMER!',
        desc: 'Next customer tips 5x normal!',
        duration: 0,
        color: '#ff6600',
        onStart: () => { GS._nextJackpot = true; }
    },
    critic_visit: {
        name: ' FOOD CRITIC ARRIVES!',
        desc: 'Serve them well for +25 reputation, or lose -15!',
        duration: 0,
        color: '#ff4444',
        onStart: () => {
            GS._criticActive = true;
            GS._forceVIP = true;
            spawnCustomer();
            GS._forceVIP = false;
        }
    },
    double_xp: {
        name: ' DOUBLE XP!',
        desc: 'Earn double XP for 30 seconds!',
        duration: 30000,
        color: '#ffff00',
        onStart: () => { GS._xpMultiplier = 2; },
        onEnd: () => { GS._xpMultiplier = 1; }
    },
    combo_frenzy: {
        name: ' COMBO FRENZY!',
        desc: 'Combo timer extended! Build massive combos for 45 seconds!',
        duration: 45000,
        color: '#ff3300',
        onStart: () => { GS._comboTimerBonus = 3000; },
        onEnd: () => { GS._comboTimerBonus = 0; }
    },
    karaoke_night: {
        name: ' KARAOKE NIGHT!',
        desc: 'A customer is singing! +30% tips & everyone gains patience for 40 seconds!',
        duration: 40000,
        color: '#ff66cc',
        onStart: () => {
            GS._tipMultiplier = (GS._tipMultiplier || 1) * 1.3;
            GS._patienceBonus = (GS._patienceBonus || 0) + 0.3;
            // Pick a random present customer to be the singer
            const singers = GS.customers.filter(c => c.state !== 'leaving' && c.state !== 'walking');
            if (singers.length > 0) {
                const singer = singers[Math.floor(Math.random() * singers.length)];
                GS._karaokeSinger = singer.id;
            }
            GS._karaokeLyrics = [];
            GS._karaokeTimer = 0;
        },
        onEnd: () => {
            GS._tipMultiplier = Math.max(1, (GS._tipMultiplier || 1) / 1.3);
            GS._patienceBonus = Math.max(0, (GS._patienceBonus || 0) - 0.3);
            GS._karaokeSinger = null;
            GS._karaokeLyrics = [];
        }
    },
    meteor_rush: {
        name: ' METEOR RUSH!',
        desc: 'Incoming meteors! Customers flood in for 30 seconds  serve fast!',
        duration: 30000,
        color: '#ff8800',
        onStart: () => { GS._megaRushUntil = performance.now() + 30000; },
        onEnd: () => { GS._megaRushUntil = 0; }
    },
    bar_fight: {
        name: ' BAR FIGHT!',
        desc: 'Two customers are brawling! Click them to break it up! Patience drains 2x faster!',
        duration: 20000,
        color: '#ff2222',
        onStart: () => {
            GS._barFightActive = true;
            GS._barFightClicks = 0;
            GS._barFightNeeded = 5;
            GS._patienceRate = (GS._patienceRate || 1) * 2;
            // Pick two random present customers as fighters
            const present = GS.customers.filter(c => c.state !== 'leaving' && c.state !== 'walking');
            if (present.length >= 2) {
                const shuffled = present.sort(() => Math.random() - 0.5);
                GS._fighter1 = shuffled[0].id;
                GS._fighter2 = shuffled[1].id;
            } else if (present.length === 1) {
                GS._fighter1 = present[0].id;
                GS._fighter2 = null;
            }
        },
        onEnd: () => {
            if (GS._barFightClicks >= GS._barFightNeeded) {
                // Successfully broke up the fight!
                const bonus = 50 + GS.level * 10;
                GS.credits += bonus;
                GS.reputation = Math.min(100, GS.reputation + 5);
                spawnFloatingNumber(400, 300, `+${bonus}  BOUNCER BONUS!`, 'combo');
                addLog(` You broke up the fight! +${bonus} credits, +5 rep!`, 'earn');
            } else {
                GS.reputation = Math.max(0, GS.reputation - 10);
                addLog(' Bar fight ended badly... -10 reputation', 'bad');
            }
            GS._patienceRate = Math.max(1, (GS._patienceRate || 1) / 2);
            GS._barFightActive = false;
            GS._fighter1 = null;
            GS._fighter2 = null;
            updateHUD();
        }
    },
    gravity_glitch: {
        name: ' GRAVITY MALFUNCTION!',
        desc: 'Zero-G activated! Everything floats! Tips +25% (customers love it!)',
        duration: 25000,
        color: '#9966ff',
        onStart: () => {
            GS._gravityGlitch = true;
            GS._tipMultiplier = (GS._tipMultiplier || 1) * 1.25;
        },
        onEnd: () => {
            GS._gravityGlitch = false;
            GS._tipMultiplier = Math.max(1, (GS._tipMultiplier || 1) / 1.25);
        }
    },
    power_outage: {
        name: ' POWER OUTAGE!',
        desc: 'Lights flickering! Drink prep paused for 10 seconds! Keep calm!',
        duration: 10000,
        color: '#333333',
        onStart: () => {
            GS._powerOutage = true;
            GS._prepSpeedMult = (GS._prepSpeedMult || 1) * 0;
        },
        onEnd: () => {
            GS._powerOutage = false;
            GS._prepSpeedMult = 1;
            addLog(' Power restored! Back to work!', 'special');
        }
    }
};

let specialEventTimer = 60000; // First event after 60 seconds
let activeSpecialEvent = null;
let eventEndTime = 0;

function updateSpecialEvents(dt) {
    const now = performance.now();
    
    // Check if active event ended
    if (activeSpecialEvent && eventEndTime > 0 && now >= eventEndTime) {
        endSpecialEvent();
    }
    
    // Update timer bar
    if (activeSpecialEvent && eventEndTime > 0) {
        const event = SPECIAL_EVENTS[activeSpecialEvent];
        const remaining = Math.max(0, eventEndTime - now);
        const pct = (remaining / event.duration) * 100;
        const timerBar = document.getElementById('active-event-bar');
        timerBar.classList.add('show');
        document.getElementById('event-timer-name').textContent = event.name;
        document.getElementById('event-timer-fill').style.width = pct + '%';
        document.getElementById('event-timer-fill').style.background = event.color;
        document.getElementById('event-timer-time').textContent = Math.ceil(remaining / 1000) + 's';
    } else {
        document.getElementById('active-event-bar').classList.remove('show');
    }
    
    // Only trigger new events if no event is active and not in dialogue
    if (!activeSpecialEvent && !GS.dialogueActive) {
        specialEventTimer -= dt;
        
        if (specialEventTimer <= 0 && GS.level >= 3) {
            triggerRandomEvent();
            specialEventTimer = 90000 + Math.random() * 90000;
        }
    }
}

function triggerRandomEvent() {
    const eventKeys = Object.keys(SPECIAL_EVENTS);
    const eventKey = eventKeys[Math.floor(Math.random() * eventKeys.length)];
    const event = SPECIAL_EVENTS[eventKey];
    
    activeSpecialEvent = eventKey;
    
    // Start the event
    if (event.onStart) event.onStart();
    
    // Show dramatic announcement
    showEventBanner(event);
    
    // Play sound
    playSound('levelup');
    
    // Set end time if event has duration
    if (event.duration > 0) {
        eventEndTime = performance.now() + event.duration;
    } else {
        // Instant event, clear immediately
        setTimeout(() => { activeSpecialEvent = null; }, 3000);
        eventEndTime = 0;
    }
    
    // Add to log
    addLog(` ${event.name}: ${event.desc}`, 'special');
}

function endSpecialEvent() {
    const event = SPECIAL_EVENTS[activeSpecialEvent];
    if (event && event.onEnd) event.onEnd();
    
    showNotification(`${event.name} ended!`);
    activeSpecialEvent = null;
    eventEndTime = 0;
    document.getElementById('active-event-bar').classList.remove('show');
}

function showEventBanner(event) {
    // Create dramatic banner overlay
    const banner = document.createElement('div');
    banner.className = 'event-banner';
    banner.innerHTML = `
        <div class="event-banner-content" style="border-color: ${event.color}">
            <div class="event-name" style="color: ${event.color}">${event.name}</div>
            <div class="event-desc">${event.desc}</div>
        </div>
    `;
    document.getElementById('game-container').appendChild(banner);
    
    // Animate in
    setTimeout(() => banner.classList.add('show'), 10);
    
    // Remove after animation
    setTimeout(() => {
        banner.classList.remove('show');
        setTimeout(() => banner.remove(), 500);
    }, 3500);
}

let now = 0;
function render() {
    now = performance.now();
    ctx.clearRect(0, 0, W, H);
    
    // Starfield background
    drawStars();
    
    // Space weather overlay effects
    drawWeatherOverlay();
    
    // Map
    if (imgs.map) {
        const mw = imgs.map.width * cam.zoom, mh = imgs.map.height * cam.zoom;
        const mx = W/2 - mw/2 + cam.x, my = H/2 - mh/2 + cam.y;
        ctx.drawImage(imgs.map, mx, my, mw, mh);
    }
    
    // Collect all drawable entities sorted by Y
    const entities = [];
    
    // Mary (bartender)  always at bar
    entities.push({ type: 'mary', y: MARY_POS.y });
    
    // Customers
    GS.customers.forEach(c => {
        entities.push({ type: 'customer', data: c, y: c.pos.y });
    });
    
    entities.sort((a, b) => a.y - b.y);
    
    // Draw placed furniture (behind characters)
    drawPlacedFurniture();
    
    entities.forEach(e => {
        if (e.type === 'mary') drawMary();
        else if (e.type === 'customer') drawCustomer(e.data);
    });

    // Draw customer conversations (on top of characters)
    drawCustomerConversations();
    
    // Draw pet
    drawPet();
    
    // Draw ambient bar patrons (always visible)
    drawAmbientChars();
    
    // Draw placement ghost on top
    drawPlacementGhost();
    
    // Draw drink delivery trails
    drawDrinkTrails();
    
    // Draw karaoke effects on top of characters
    drawKaraokeEffects();
    
    // Draw dynamic lighting layer (night effects + decoration lights)
    drawLighting();
    
    // Combo fireworks on top of everything
    drawFireworks();
}

// ==================== DYNAMIC LIGHTING SYSTEM ====================
function drawLighting() {
    if (!currentPhase) return;
    
    // Parse current phase overlay for darkness intensity
    const overlay = currentPhase.overlay;
    if (!overlay || overlay === 'rgba(0,0,0,0)') return;
    
    // Night phases get lighting effects
    const isNightTime = currentPhase.name.includes('Night') || currentPhase.name === 'Evening' || currentPhase.name === 'Late Night';
    
    // Draw ambient overlay
    ctx.fillStyle = overlay;
    ctx.fillRect(0, 0, W, H);
    
    // If it's night, draw light sources
    if (isNightTime && GS.placedFurniture.length > 0) {
        ctx.globalCompositeOperation = 'lighter';
        
        for (const f of GS.placedFurniture) {
            // Check both decorations AND furniture for light property
            const deco = DECORATIONS[f.type] || FURNITURE[f.type];
            if (!deco || !deco.light) continue;
            
            const light = deco.light;
            const s = w2s(f.x, f.y);
            
            // Calculate light intensity with effects
            let intensity = 0.15;
            let radius = light.radius * cam.zoom;
            
            // Flicker effect
            if (light.flicker) {
                intensity *= 0.7 + 0.3 * (0.5 + 0.5 * Math.sin(now / 80 + f.x));
                radius *= 0.95 + 0.05 * Math.sin(now / 100 + f.y);
            }
            
            // Pulse effect
            if (light.pulse) {
                intensity *= 0.8 + 0.2 * (0.5 + 0.5 * Math.sin(now / 1000 + f.x));
            }
            
            // Disco ball rainbow effect
            if (light.color === 'rainbow') {
                const hue = (now / 50 + f.x) % 360;
                drawRadialLight(s.x, s.y, radius, `hsla(${hue}, 100%, 60%, ${intensity})`);
                // Disco beams
                if (light.spin) {
                    for (let i = 0; i < 6; i++) {
                        const angle = (now / 1500 + i * Math.PI / 3) % (Math.PI * 2);
                        const beamHue = (hue + i * 60) % 360;
                        drawDiscoBeam(s.x, s.y, angle, radius * 2, `hsla(${beamHue}, 100%, 60%, ${intensity * 0.4})`);
                    }
                }
            } else {
                drawRadialLight(s.x, s.y, radius, hexToRgba(light.color, intensity));
            }
        }
        
        // Bar area always has some ambient light
        const barS = w2s(BAR_CENTER.x, BAR_CENTER.y);
        drawRadialLight(barS.x, barS.y, 120 * cam.zoom, 'rgba(255, 200, 100, 0.08)');
        
        ctx.globalCompositeOperation = 'source-over';
    }
}

function drawRadialLight(x, y, radius, color) {
    const gradient = ctx.createRadialGradient(x, y, 0, x, y, radius);
    gradient.addColorStop(0, color);
    gradient.addColorStop(1, 'rgba(0,0,0,0)');
    ctx.fillStyle = gradient;
    ctx.beginPath();
    ctx.arc(x, y, radius, 0, Math.PI * 2);
    ctx.fill();
}

function drawDiscoBeam(x, y, angle, length, color) {
    const endX = x + Math.cos(angle) * length;
    const endY = y + Math.sin(angle) * length;
    const gradient = ctx.createLinearGradient(x, y, endX, endY);
    gradient.addColorStop(0, color);
    gradient.addColorStop(1, 'rgba(0,0,0,0)');
    
    ctx.beginPath();
    ctx.moveTo(x, y);
    ctx.lineTo(endX - Math.sin(angle) * 10, endY + Math.cos(angle) * 10);
    ctx.lineTo(endX + Math.sin(angle) * 10, endY - Math.cos(angle) * 10);
    ctx.closePath();
    ctx.fillStyle = gradient;
    ctx.fill();
}

function hexToRgba(hex, alpha) {
    // Handle common color names
    const colors = {
        '#ff00ff': [255, 0, 255],
        '#00ffff': [0, 255, 255],
        '#0088ff': [0, 136, 255],
        '#00ff88': [0, 255, 136],
        '#ffffaa': [255, 255, 170],
        '#aaffff': [170, 255, 255],
        '#ff0055': [255, 0, 85],
        '#ff6600': [255, 102, 0],
        '#00ff44': [0, 255, 68],
    };
    
    const rgb = colors[hex] || [255, 255, 255];
    return `rgba(${rgb[0]}, ${rgb[1]}, ${rgb[2]}, ${alpha})`;
}

// Stars (seeded)
const stars = [];
for (let i = 0; i < 120; i++) stars.push({ x: Math.random(), y: Math.random(), s: Math.random() * 2 + 0.5, b: Math.random() });

function drawStars() {
    ctx.fillStyle = '#070b1a';
    ctx.fillRect(0, 0, W, H);
    
    // Nebula clouds
    for (const nc of nebulaClouds) {
        nc.x += nc.speed;
        if (nc.x > 1.3) nc.x = -0.3;
        const grd = ctx.createRadialGradient(nc.x*W, nc.y*H, 0, nc.x*W, nc.y*H, nc.r);
        grd.addColorStop(0, nc.color + '0.06)');
        grd.addColorStop(1, nc.color + '0)');
        ctx.fillStyle = grd;
        ctx.fillRect(0, 0, W, H);
    }
    
    // Stars with color tinting
    const starColors = ['#fff', '#aaccff', '#ffddaa', '#ffaaaa', '#aaffcc'];
    for (const s of stars) {
        const twinkle = 0.3 + 0.7 * (0.5 + 0.5 * Math.sin(now / 1000 + s.b * 10));
        ctx.globalAlpha = twinkle;
        ctx.fillStyle = starColors[Math.floor(s.b * starColors.length)];
        ctx.fillRect(s.x * W, s.y * H, s.s, s.s);
        // Glow for brighter stars
        if (s.s > 1.5) {
            ctx.globalAlpha = twinkle * 0.15;
            ctx.beginPath();
            ctx.arc(s.x * W, s.y * H, s.s * 3, 0, Math.PI * 2);
            ctx.fill();
        }
    }
    ctx.globalAlpha = 1;
    
    // Shooting stars
    maybeSpawnShootingStar();
    for (let i = shootingStars.length - 1; i >= 0; i--) {
        const ss = shootingStars[i];
        if (ss.caught) continue;
        ss.x += ss.vx; ss.y += ss.vy; ss.life -= 0.015;
        ss.trail.push({ x: ss.x, y: ss.y });
        if (ss.trail.length > 12) ss.trail.shift();
        // Draw trail
        for (let j = 0; j < ss.trail.length; j++) {
            const a = (j / ss.trail.length) * ss.life * 0.6;
            ctx.globalAlpha = a;
            ctx.fillStyle = '#fff';
            const sz = (j / ss.trail.length) * 2;
            ctx.fillRect(ss.trail[j].x, ss.trail[j].y, sz, sz);
        }
        // Clickable glow hint on the head of the star
        const pulse = 0.3 + 0.3 * Math.sin(now / 200);
        ctx.globalAlpha = ss.life * pulse;
        ctx.beginPath();
        ctx.arc(ss.x, ss.y, 8, 0, Math.PI * 2);
        ctx.fillStyle = '#ffd700';
        ctx.fill();
        ctx.globalAlpha = 1;
        if (ss.life <= 0) shootingStars.splice(i, 1);
    }
    
    // Draw space weather effects
    drawSpaceWeather();
}

// ==================== SPACE WEATHER SYSTEM ====================
const spaceWeather = {
    comets: [],
    auroras: [],
    supernovas: [],
    spaceships: [],
    eventTimer: 0
};

function drawSpaceWeather() {
    // Tick event spawner
    spaceWeather.eventTimer -= 16;
    if (spaceWeather.eventTimer <= 0) {
        spawnSpaceEvent();
        spaceWeather.eventTimer = 15000 + Math.random() * 30000; // 15-45 seconds between events
    }
    
    // Draw comets (larger, slower than shooting stars with colorful tails)
    for (let i = spaceWeather.comets.length - 1; i >= 0; i--) {
        const comet = spaceWeather.comets[i];
        comet.x += comet.vx;
        comet.y += comet.vy;
        comet.trail.push({ x: comet.x, y: comet.y });
        if (comet.trail.length > 40) comet.trail.shift();
        
        // Draw comet trail with color gradient
        for (let j = 0; j < comet.trail.length; j++) {
            const progress = j / comet.trail.length;
            const alpha = progress * 0.6;
            ctx.globalAlpha = alpha;
            
            // Color gradient: blue core -> cyan -> white tail
            const r = Math.floor(100 + 155 * progress);
            const g = Math.floor(200 + 55 * progress);
            const b = 255;
            ctx.fillStyle = `rgb(${r},${g},${b})`;
            
            const sz = 1 + progress * 4;
            ctx.beginPath();
            ctx.arc(comet.trail[j].x, comet.trail[j].y, sz, 0, Math.PI * 2);
            ctx.fill();
        }
        
        // Comet head glow
        ctx.globalAlpha = 0.8;
        const headGlow = ctx.createRadialGradient(comet.x, comet.y, 0, comet.x, comet.y, 15);
        headGlow.addColorStop(0, 'rgba(200,230,255,0.8)');
        headGlow.addColorStop(0.5, 'rgba(100,180,255,0.3)');
        headGlow.addColorStop(1, 'rgba(50,100,200,0)');
        ctx.fillStyle = headGlow;
        ctx.beginPath();
        ctx.arc(comet.x, comet.y, 15, 0, Math.PI * 2);
        ctx.fill();
        
        ctx.globalAlpha = 1;
        
        // Remove if off screen
        if (comet.x < -50 || comet.x > W + 50 || comet.y > H + 50) {
            spaceWeather.comets.splice(i, 1);
        }
    }
    
    // Draw aurora effects (wavy colored bands at top of screen)
    for (let i = spaceWeather.auroras.length - 1; i >= 0; i--) {
        const aurora = spaceWeather.auroras[i];
        aurora.life -= 0.001;
        aurora.phase += 0.02;
        
        if (aurora.life > 0) {
            ctx.globalAlpha = aurora.life * 0.15;
            
            for (let band = 0; band < 3; band++) {
                const y = 20 + band * 25;
                const gradient = ctx.createLinearGradient(0, y, W, y);
                
                // Shifting aurora colors
                const hue1 = (aurora.hue + band * 40 + aurora.phase * 20) % 360;
                const hue2 = (hue1 + 60) % 360;
                gradient.addColorStop(0, `hsla(${hue1}, 100%, 60%, 0)`);
                gradient.addColorStop(0.3, `hsla(${hue1}, 100%, 60%, 1)`);
                gradient.addColorStop(0.7, `hsla(${hue2}, 100%, 60%, 1)`);
                gradient.addColorStop(1, `hsla(${hue2}, 100%, 60%, 0)`);
                
                ctx.fillStyle = gradient;
                ctx.beginPath();
                ctx.moveTo(0, y);
                for (let x = 0; x <= W; x += 20) {
                    const wave = Math.sin(x / 80 + aurora.phase + band) * 15;
                    ctx.lineTo(x, y + wave);
                }
                ctx.lineTo(W, y + 40);
                ctx.lineTo(0, y + 40);
                ctx.closePath();
                ctx.fill();
            }
        }
        
        ctx.globalAlpha = 1;
        if (aurora.life <= 0) spaceWeather.auroras.splice(i, 1);
    }
    
    // Draw distant supernovas (expanding rings of light)
    for (let i = spaceWeather.supernovas.length - 1; i >= 0; i--) {
        const nova = spaceWeather.supernovas[i];
        nova.radius += nova.speed;
        nova.life -= 0.008;
        
        if (nova.life > 0) {
            ctx.globalAlpha = nova.life * 0.4;
            
            // Inner bright core
            const coreGlow = ctx.createRadialGradient(nova.x, nova.y, 0, nova.x, nova.y, nova.radius * 0.3);
            coreGlow.addColorStop(0, `hsla(${nova.hue}, 100%, 90%, 0.8)`);
            coreGlow.addColorStop(1, `hsla(${nova.hue}, 100%, 60%, 0)`);
            ctx.fillStyle = coreGlow;
            ctx.beginPath();
            ctx.arc(nova.x, nova.y, nova.radius * 0.3, 0, Math.PI * 2);
            ctx.fill();
            
            // Expanding ring
            ctx.strokeStyle = `hsla(${nova.hue}, 100%, 70%, ${nova.life})`;
            ctx.lineWidth = 3 - nova.life * 2;
            ctx.beginPath();
            ctx.arc(nova.x, nova.y, nova.radius, 0, Math.PI * 2);
            ctx.stroke();
            
            // Outer glow ring
            ctx.strokeStyle = `hsla(${(nova.hue + 30) % 360}, 80%, 50%, ${nova.life * 0.3})`;
            ctx.lineWidth = 1;
            ctx.beginPath();
            ctx.arc(nova.x, nova.y, nova.radius * 1.2, 0, Math.PI * 2);
            ctx.stroke();
        }
        
        ctx.globalAlpha = 1;
        if (nova.life <= 0) spaceWeather.supernovas.splice(i, 1);
    }
    
    // Draw passing spaceships (silhouettes)
    for (let i = spaceWeather.spaceships.length - 1; i >= 0; i--) {
        const ship = spaceWeather.spaceships[i];
        ship.x += ship.vx;
        ship.y += ship.vy;
        
        ctx.globalAlpha = 0.3;
        ctx.fillStyle = '#1a1a2e';
        
        // Simple spaceship silhouette
        ctx.save();
        ctx.translate(ship.x, ship.y);
        ctx.scale(ship.size, ship.size);
        
        // Ship body
        ctx.beginPath();
        ctx.moveTo(-15, 0);
        ctx.lineTo(-8, -5);
        ctx.lineTo(15, -3);
        ctx.lineTo(20, 0);
        ctx.lineTo(15, 3);
        ctx.lineTo(-8, 5);
        ctx.closePath();
        ctx.fill();
        
        // Engine glow
        ctx.globalAlpha = 0.5;
        ctx.fillStyle = ship.engineColor;
        ctx.beginPath();
        ctx.arc(-18, 0, 3, 0, Math.PI * 2);
        ctx.fill();
        
        ctx.restore();
        ctx.globalAlpha = 1;
        
        // Remove if off screen
        if (ship.x < -50 || ship.x > W + 50) {
            spaceWeather.spaceships.splice(i, 1);
        }
    }
}

function spawnSpaceEvent() {
    const eventType = Math.random();
    
    if (eventType < 0.3) {
        // Spawn comet
        const fromLeft = Math.random() > 0.5;
        spaceWeather.comets.push({
            x: fromLeft ? -20 : W + 20,
            y: Math.random() * H * 0.4,
            vx: (fromLeft ? 1 : -1) * (1.5 + Math.random()),
            vy: 0.3 + Math.random() * 0.5,
            trail: []
        });
    } else if (eventType < 0.5) {
        // Spawn aurora
        spaceWeather.auroras.push({
            hue: Math.random() * 360,
            phase: 0,
            life: 1
        });
    } else if (eventType < 0.7) {
        // Spawn distant supernova
        spaceWeather.supernovas.push({
            x: 50 + Math.random() * (W - 100),
            y: 30 + Math.random() * (H * 0.3),
            radius: 5,
            speed: 0.5 + Math.random(),
            hue: Math.random() > 0.5 ? 200 + Math.random() * 60 : 0 + Math.random() * 40, // Blue or red
            life: 1
        });
    } else {
        // Spawn passing spaceship
        const fromLeft = Math.random() > 0.5;
        spaceWeather.spaceships.push({
            x: fromLeft ? -30 : W + 30,
            y: 20 + Math.random() * (H * 0.25),
            vx: (fromLeft ? 1 : -1) * (0.5 + Math.random() * 0.5),
            vy: (Math.random() - 0.5) * 0.1,
            size: 0.5 + Math.random() * 1.5,
            engineColor: ['#ff6600', '#00ff88', '#ff00ff', '#00ffff'][Math.floor(Math.random() * 4)]
        });
    }
}

function drawSprite(key, wx, wy, size, flipX) {
    const img = imgs[key];
    if (!img) return;
    const s = w2s(wx, wy);
    const w = size * cam.zoom;
    const h = (img.height / img.width) * w;
    
    ctx.save();
    if (flipX) {
        ctx.translate(s.x, s.y - h);
        ctx.scale(-1, 1);
        ctx.drawImage(img, -w/2, 0, w, h);
    } else {
        ctx.drawImage(img, s.x - w/2, s.y - h, w, h);
    }
    ctx.restore();
}

function drawMary() {
    const ms = w2s(MARY_POS.x, MARY_POS.y);
    
    // Check if any drinks are being prepared
    const activeDrink = GS.customers.find(c => c.state === 'ordered' && c.drinkProgress > 0 && c.drinkProgress < 1);
    const isMixing = !!activeDrink;
    
    // Shadow
    ctx.fillStyle = 'rgba(0,0,0,0.3)';
    ctx.beginPath();
    ctx.ellipse(ms.x, ms.y, 18*cam.zoom, 7*cam.zoom, 0, 0, Math.PI*2);
    ctx.fill();
    
    // Mixing animation: Mary shakes side to side
    const shakeX = isMixing ? Math.sin(now / 80) * 3 : 0;
    const shakeY = isMixing ? Math.abs(Math.sin(now / 120)) * -2 : 0;
    drawSprite('mary_sprite', MARY_POS.x + shakeX, MARY_POS.y + shakeY, 75);
    
    // Drink mixing visual effects on the bar counter
    if (isMixing && activeDrink.order) {
        const drink = DRINKS[activeDrink.order];
        if (drink) {
            const barX = ms.x;
            const barY = ms.y - 40 * cam.zoom;
            const prog = activeDrink.drinkProgress;
            
            // Shaker/glass on bar
            ctx.font = `${18*cam.zoom}px Arial`;
            ctx.textAlign = 'center';
            const shakerBob = Math.sin(now / 100) * 3 * cam.zoom;
            ctx.fillText(prog < 0.5 ? '' : '', barX + 25*cam.zoom, barY + shakerBob);
            
            // Colored splash particles during mixing
            if (Math.random() < 0.3) {
                const px = barX + 25*cam.zoom + (Math.random() - 0.5) * 20 * cam.zoom;
                const py = barY - 5*cam.zoom + (Math.random() - 0.5) * 10 * cam.zoom;
                ctx.globalAlpha = 0.5 + Math.random() * 0.3;
                ctx.fillStyle = drink.color;
                ctx.beginPath();
                ctx.arc(px, py, (1 + Math.random() * 2) * cam.zoom, 0, Math.PI * 2);
                ctx.fill();
                ctx.globalAlpha = 1;
            }
            
            // Steam/vapor rising when nearly done
            if (prog > 0.7) {
                for (let i = 0; i < 2; i++) {
                    const age = ((now / 600 + i * 0.5) % 1);
                    ctx.globalAlpha = (1 - age) * 0.3;
                    ctx.fillStyle = '#fff';
                    const sx = barX + 25*cam.zoom + Math.sin(age * 4 + i) * 6 * cam.zoom;
                    const sy = barY - (10 + age * 25) * cam.zoom;
                    ctx.beginPath();
                    ctx.arc(sx, sy, (2 + age * 3) * cam.zoom, 0, Math.PI * 2);
                    ctx.fill();
                }
                ctx.globalAlpha = 1;
            }
        }
    }
    
    // Name tag
    ctx.font = `bold ${11*cam.zoom}px Nunito`;
    ctx.fillStyle = '#ffd700';
    ctx.textAlign = 'center';
    const statusText = isMixing ? ' Mary ' : ' Mary';
    ctx.fillText(statusText, ms.x, ms.y - 82*cam.zoom);
}

function drawCustomer(c) {
    const s = w2s(c.pos.x, c.pos.y);
    let bob = c.state === 'waiting' ? Math.sin(now / 600 + c.id) * 2 : 0;
    // Gravity glitch: exaggerated floating
    if (GS._gravityGlitch) {
        bob += Math.sin(now / 300 + c.id * 3) * 12 + Math.cos(now / 500 + c.id * 7) * 6;
    }
    const charData = CHAR_DATA[c.char];
    // Bar fight: draw fight effects on fighters
    const isFighter = GS._barFightActive && (c.id === GS._fighter1 || c.id === GS._fighter2);
    if (isFighter) {
        // Shake effect
        s.x += Math.sin(now / 30 + c.id) * 5 * cam.zoom;
        s.y += Math.cos(now / 40 + c.id) * 3 * cam.zoom;
        // Red glow
        ctx.save();
        ctx.shadowColor = '#ff0000';
        ctx.shadowBlur = 20 * cam.zoom;
        // Draw punch/impact emojis
        const fightEmojis = ['', '', '', '', ''];
        const eidx = Math.floor(now / 200) % fightEmojis.length;
        ctx.font = `${20*cam.zoom}px Arial`;
        ctx.textAlign = 'center';
        ctx.fillText(fightEmojis[eidx], s.x + Math.sin(now/100)*15*cam.zoom, s.y - 100*cam.zoom + Math.cos(now/150)*10*cam.zoom);
    }
    
    // === TELEPORT BEAM-IN EFFECT ===
    if (c._beamIn) {
        c._beamTimer += 16;
        const bp = Math.min(1, c._beamTimer / c._beamDuration);
        const eType = c._entranceType || 'beam';
        
        if (eType === 'beam') {
            // Classic teleport beam from sky
            const beamWidth = (1 - bp) * 40 * cam.zoom;
            const beamAlpha = (1 - bp) * 0.6;
            if (beamWidth > 1) {
                const beamGrad = ctx.createLinearGradient(s.x, 0, s.x, s.y);
                beamGrad.addColorStop(0, `rgba(100,200,255,0)`);
                beamGrad.addColorStop(0.4, `rgba(100,200,255,${beamAlpha * 0.5})`);
                beamGrad.addColorStop(1, `rgba(200,240,255,${beamAlpha})`);
                ctx.fillStyle = beamGrad;
                ctx.fillRect(s.x - beamWidth/2, 0, beamWidth, s.y);
                for (let i = 0; i < 3; i++) {
                    const px = s.x + (Math.random() - 0.5) * beamWidth * 2;
                    const py = s.y - Math.random() * s.y * 0.8;
                    ctx.globalAlpha = beamAlpha * Math.random();
                    ctx.fillStyle = '#fff';
                    ctx.fillRect(px, py, 2 * cam.zoom, 2 * cam.zoom);
                }
                ctx.globalAlpha = 1;
                ctx.strokeStyle = `rgba(100,200,255,${beamAlpha})`;
                ctx.lineWidth = 2 * cam.zoom;
                ctx.beginPath();
                ctx.ellipse(s.x, s.y, (20 + beamWidth/2) * cam.zoom, (8 + beamWidth/4) * cam.zoom, 0, 0, Math.PI * 2);
                ctx.stroke();
            }
            ctx.globalAlpha = bp;
            const stretchY = 1 + (1 - bp) * 0.5;
            ctx.save();
            ctx.translate(s.x, s.y);
            ctx.scale(1, 1/stretchY);
            ctx.translate(-s.x, -s.y);
        } else if (eType === 'portal') {
            // Swirling purple portal that opens and spits them out
            const portalR = (1 - bp) * 50 * cam.zoom + 5 * cam.zoom;
            const portalAlpha = (1 - bp) * 0.8;
            if (portalR > 3) {
                // Portal ring
                ctx.save();
                ctx.translate(s.x, s.y - 30 * cam.zoom);
                ctx.rotate(now / 400);
                for (let ring = 0; ring < 3; ring++) {
                    const r = portalR * (1 - ring * 0.2);
                    const colors = ['rgba(180,60,255,', 'rgba(100,20,200,', 'rgba(220,100,255,'];
                    ctx.strokeStyle = colors[ring] + portalAlpha + ')';
                    ctx.lineWidth = (3 - ring) * cam.zoom;
                    ctx.beginPath();
                    ctx.ellipse(0, 0, r, r * 0.4, 0, 0, Math.PI * 2);
                    ctx.stroke();
                }
                // Inner glow
                const glow = ctx.createRadialGradient(0, 0, 0, 0, 0, portalR * 0.8);
                glow.addColorStop(0, `rgba(180,60,255,${portalAlpha * 0.4})`);
                glow.addColorStop(1, 'rgba(180,60,255,0)');
                ctx.fillStyle = glow;
                ctx.beginPath();
                ctx.ellipse(0, 0, portalR, portalR * 0.4, 0, 0, Math.PI * 2);
                ctx.fill();
                // Portal sparks
                for (let i = 0; i < 4; i++) {
                    const angle = (now / 200) + i * Math.PI / 2;
                    const sparkX = Math.cos(angle) * portalR * 0.9;
                    const sparkY = Math.sin(angle) * portalR * 0.35;
                    ctx.globalAlpha = portalAlpha * 0.8;
                    ctx.fillStyle = '#dd88ff';
                    ctx.fillRect(sparkX - 1, sparkY - 1, 3 * cam.zoom, 3 * cam.zoom);
                }
                ctx.restore();
                ctx.globalAlpha = 1;
            }
            // Character pops out with scale bounce
            const popScale = bp < 0.7 ? bp / 0.7 : 1 + Math.sin((bp - 0.7) / 0.3 * Math.PI) * 0.15;
            ctx.globalAlpha = Math.min(1, bp * 1.5);
            ctx.save();
            ctx.translate(s.x, s.y);
            ctx.scale(popScale, popScale);
            ctx.translate(-s.x, -s.y);
        } else if (eType === 'crashland') {
            // Crash landing from upper-right with smoke and bounce
            const landPhase = Math.min(1, bp);
            const fallDone = landPhase > 0.5;
            if (!fallDone) {
                const fp = landPhase / 0.5;
                // Fire trail
                for (let t = 0; t < 8; t++) {
                    const tt = t / 8;
                    const tx = s.x + 200 * cam.zoom * (1 - fp) * tt + (Math.random() - 0.5) * 8;
                    const ty = s.y - 300 * cam.zoom * (1 - fp) * tt + (Math.random() - 0.5) * 8;
                    ctx.globalAlpha = (1 - tt) * (1 - fp) * 0.6;
                    ctx.fillStyle = t % 2 === 0 ? '#ff6600' : '#ffaa00';
                    ctx.beginPath();
                    ctx.arc(tx, ty, (3 + t * 0.5) * cam.zoom, 0, Math.PI * 2);
                    ctx.fill();
                }
                ctx.globalAlpha = fp;
                const crashOffX = 200 * cam.zoom * (1 - fp);
                const crashOffY = -300 * cam.zoom * (1 - fp);
                ctx.save();
                ctx.translate(crashOffX, crashOffY);
            } else {
                const bounceP = (landPhase - 0.5) / 0.5;
                const bounceY = Math.abs(Math.sin(bounceP * Math.PI * 2)) * 20 * (1 - bounceP);
                // Impact smoke
                if (bounceP < 0.5) {
                    const smokeAlpha = (1 - bounceP * 2) * 0.4;
                    for (let i = 0; i < 5; i++) {
                        const angle = (i / 5) * Math.PI * 2 + now / 500;
                        const dist = (bounceP * 2) * 40 * cam.zoom;
                        ctx.globalAlpha = smokeAlpha * (1 - i * 0.15);
                        ctx.fillStyle = '#888';
                        ctx.beginPath();
                        ctx.arc(s.x + Math.cos(angle) * dist, s.y + Math.sin(angle) * dist * 0.4, (8 + i * 2) * cam.zoom, 0, Math.PI * 2);
                        ctx.fill();
                    }
                }
                if (bounceP < 0.3) {
                    for (let i = 0; i < 3; i++) {
                        ctx.globalAlpha = (1 - bounceP / 0.3) * 0.7;
                        ctx.fillStyle = '#ffdd44';
                        const sx2 = s.x + (Math.random() - 0.5) * 50 * cam.zoom;
                        const sy2 = s.y + (Math.random() - 0.5) * 15 * cam.zoom;
                        ctx.fillRect(sx2, sy2, 2 * cam.zoom, 2 * cam.zoom);
                    }
                }
                ctx.globalAlpha = 1;
                ctx.save();
                ctx.translate(0, -bounceY * cam.zoom);
            }
        } else if (eType === 'wormhole') {
            // Wormhole  spiraling in from a central point with distortion
            const spiralP = bp;
            const wormR = (1 - spiralP) * 60 * cam.zoom;
            // Wormhole circle (teal/cyan)
            if (wormR > 2) {
                ctx.save();
                ctx.translate(s.x, s.y - 30 * cam.zoom);
                // Concentric distortion rings
                for (let r = 0; r < 4; r++) {
                    const rr = wormR * (0.3 + r * 0.2);
                    const alpha = (1 - spiralP) * (0.5 - r * 0.1);
                    ctx.strokeStyle = `rgba(0,${200 + r * 15},${220 + r * 10},${Math.max(0, alpha)})`;
                    ctx.lineWidth = (2 - r * 0.3) * cam.zoom;
                    ctx.beginPath();
                    ctx.arc(0, 0, rr, 0, Math.PI * 2);
                    ctx.stroke();
                }
                // Center bright point
                const centerGlow = ctx.createRadialGradient(0, 0, 0, 0, 0, wormR * 0.4);
                centerGlow.addColorStop(0, `rgba(150,255,255,${(1 - spiralP) * 0.6})`);
                centerGlow.addColorStop(1, 'rgba(0,200,220,0)');
                ctx.fillStyle = centerGlow;
                ctx.beginPath();
                ctx.arc(0, 0, wormR * 0.4, 0, Math.PI * 2);
                ctx.fill();
                ctx.restore();
            }
            // Character spirals in  rotates and scales up
            const spinAngle = (1 - spiralP) * Math.PI * 4; // 2 full rotations
            const charScale = spiralP;
            ctx.globalAlpha = Math.min(1, spiralP * 2);
            ctx.save();
            ctx.translate(s.x, s.y - 30 * cam.zoom);
            ctx.rotate(spinAngle * 0.1); // Subtle rotation
            ctx.scale(charScale || 0.01, charScale || 0.01);
            ctx.translate(-s.x, -(s.y - 30 * cam.zoom));
        }
        
        if (bp >= 1) {
            c._beamIn = false;
        }
        c._entranceSaved = true; // Flag: we have an active ctx.save for entrance
    }
    
    // Shadow
    ctx.fillStyle = 'rgba(0,0,0,0.3)';
    ctx.beginPath();
    ctx.ellipse(s.x, s.y, 16*cam.zoom, 6*cam.zoom, 0, 0, Math.PI*2);
    ctx.fill();
    
    // Sprite
    const sprKey = charData.sprite;
    const img = imgs[sprKey];
    if (img) {
        const w = 65 * cam.zoom;
        const h = (img.height / img.width) * w;
        drawSprite(sprKey, c.pos.x, c.pos.y + bob / cam.zoom, 65, c.facingLeft);
    } else {
        // Fallback circle with emoji
        ctx.fillStyle = charData.color || '#aa55cc';
        ctx.beginPath();
        ctx.arc(s.x, s.y - 30*cam.zoom, 18*cam.zoom, 0, Math.PI*2);
        ctx.fill();
        // Draw character emoji
        if (charData.emoji) {
            ctx.font = `${24*cam.zoom}px Arial`;
            ctx.textAlign = 'center';
            ctx.fillText(charData.emoji, s.x, s.y - 22*cam.zoom);
        }
    }
    
    // Blorb happiness aura glow
    if (c.char === 'blorb' && c.state !== 'leaving' && c.state !== 'walking') {
        const auraPhase = Math.sin(now / 1200) * 0.15 + 0.2;
        const auraR = 45 * cam.zoom;
        const auraGrad = ctx.createRadialGradient(s.x, s.y - 30*cam.zoom, 5, s.x, s.y - 30*cam.zoom, auraR);
        auraGrad.addColorStop(0, `rgba(136,255,204,${auraPhase})`);
        auraGrad.addColorStop(1, 'rgba(136,255,204,0)');
        ctx.fillStyle = auraGrad;
        ctx.beginPath();
        ctx.arc(s.x, s.y - 30*cam.zoom, auraR, 0, Math.PI*2);
        ctx.fill();
    }
    
    // Zix sparking effect (nervous robot)
    if (c.char === 'zix' && Math.random() < 0.03) {
        const sparkX = s.x + (Math.random() - 0.5) * 20 * cam.zoom;
        const sparkY = s.y - (30 + Math.random() * 40) * cam.zoom;
        ctx.fillStyle = '#55ddff';
        ctx.globalAlpha = 0.8;
        ctx.fillRect(sparkX, sparkY, 2*cam.zoom, 2*cam.zoom);
        ctx.globalAlpha = 1;
    }
    
    // VIP crown
    if (c.isVip) {
        ctx.font = `${18*cam.zoom}px Arial`;
        ctx.textAlign = 'center';
        ctx.fillText('', s.x, s.y - 92*cam.zoom + bob*cam.zoom);
        // VIP glow ring
        ctx.strokeStyle = 'rgba(255,215,0,0.4)';
        ctx.lineWidth = 2*cam.zoom;
        ctx.beginPath();
        ctx.arc(s.x, s.y - 35*cam.zoom, 25*cam.zoom, 0, Math.PI*2);
        ctx.stroke();
    }

    // Name
    ctx.font = `bold ${11*cam.zoom}px Nunito`;
    ctx.fillStyle = c.isVip ? '#ffd700' : '#fff';
    ctx.textAlign = 'center';
    ctx.fillText(c.isVip ? ` ${charData.name} ` : charData.name, s.x, s.y - 75*cam.zoom + bob*cam.zoom);
    
    // Loyalty tier badge (Bronze+)
    const _lt = getLoyaltyTier((GS._loyalty && GS._loyalty[c.char]) ? GS._loyalty[c.char].visits : 0);
    if (_lt.minVisits >= 5) {
        ctx.font = `${9*cam.zoom}px Nunito`;
        ctx.fillStyle = _lt.color;
        ctx.fillText(_lt.icon + ' ' + _lt.name, s.x, s.y - 64*cam.zoom + bob*cam.zoom);
    }
    
    // State indicators
    if (c.state === 'waiting') {
        // Thought bubble with craved drink hint
        const bubbleX = s.x + 22*cam.zoom;
        const bubbleY = s.y - 95*cam.zoom + bob*cam.zoom;
        const bubbleR = 18*cam.zoom;
        const breathe = 1 + 0.03 * Math.sin(now / 800 + c.id);
        
        // Small connecting circles
        ctx.fillStyle = 'rgba(255,255,255,0.85)';
        ctx.beginPath();
        ctx.arc(s.x + 8*cam.zoom, s.y - 72*cam.zoom + bob*cam.zoom, 3*cam.zoom, 0, Math.PI*2);
        ctx.fill();
        ctx.beginPath();
        ctx.arc(s.x + 14*cam.zoom, s.y - 80*cam.zoom + bob*cam.zoom, 5*cam.zoom, 0, Math.PI*2);
        ctx.fill();
        
        // Main bubble
        ctx.beginPath();
        ctx.ellipse(bubbleX, bubbleY, bubbleR * breathe * 1.2, bubbleR * breathe, 0, 0, Math.PI*2);
        ctx.fillStyle = 'rgba(255,255,255,0.9)';
        ctx.fill();
        ctx.strokeStyle = 'rgba(0,0,0,0.15)';
        ctx.lineWidth = 1;
        ctx.stroke();
        
        // Show a drink icon hint (pick from favorites or random)
        if (!c._thoughtDrink) {
            const favs = CHAR_DATA[c.char].favorites || [];
            const unlockedFavs = favs.filter(f => GS.unlockedDrinks.includes(f));
            const pool = unlockedFavs.length > 0 ? unlockedFavs : GS.unlockedDrinks;
            c._thoughtDrink = pool[Math.floor(Math.random() * pool.length)];
        }
        const thoughtDrink = DRINKS[c._thoughtDrink];
        if (thoughtDrink) {
            ctx.font = `${16*cam.zoom}px Arial`;
            ctx.textAlign = 'center';
            ctx.fillText(thoughtDrink.icon, bubbleX, bubbleY + 5*cam.zoom);
        }
        
        // Urgency - if patience low, tint bubble
        const hp = Math.max(0, c.happiness) / 100;
        if (hp < 0.4) {
            ctx.fillStyle = `rgba(255,0,0,${0.15 * (1 - hp)})`;
            ctx.beginPath();
            ctx.ellipse(bubbleX, bubbleY, bubbleR * breathe * 1.2, bubbleR * breathe, 0, 0, Math.PI*2);
            ctx.fill();
        }
    } else if (c.state === 'ordered') {
        // Drink progress ring
        const drink = DRINKS[c.order];
        const prog = Math.min(1, c.drinkProgress);
        const cx2 = s.x + 30*cam.zoom, cy2 = s.y - 60*cam.zoom;
        const r = 12*cam.zoom;
        
        // BG circle
        ctx.fillStyle = 'rgba(0,0,0,0.6)';
        ctx.beginPath(); ctx.arc(cx2, cy2, r+2, 0, Math.PI*2); ctx.fill();
        
        // Progress arc
        ctx.strokeStyle = prog >= 1 ? '#00ff88' : drink.color;
        ctx.lineWidth = 3*cam.zoom;
        ctx.beginPath();
        ctx.arc(cx2, cy2, r, -Math.PI/2, -Math.PI/2 + prog * Math.PI*2);
        ctx.stroke();
        
        // Icon
        ctx.font = `${14*cam.zoom}px Arial`;
        ctx.fillStyle = '#fff';
        ctx.fillText(drink.icon, cx2, cy2 + 5*cam.zoom);
        
        if (prog >= 1) {
            // "SERVE!" indicator
            const blink = Math.sin(now / 200) > 0;
            if (blink) {
                ctx.font = `bold ${13*cam.zoom}px Nunito`;
                ctx.fillStyle = '#00ff88';
                ctx.fillText('SERVE!', s.x, s.y - 90*cam.zoom);
            }
        }
    } else if (c.state === 'drinking') {
        ctx.font = `${16*cam.zoom}px Arial`;
        ctx.fillText('', s.x, s.y - 85*cam.zoom);
    }
    
    // Enhanced Happiness/Patience bar (for waiting/ordered states)
    if (c.state === 'waiting' || c.state === 'ordered') {
        const bw = 40*cam.zoom, bh = 5*cam.zoom;
        const bx = s.x - bw/2, by = s.y - 68*cam.zoom + bob*cam.zoom;
        const hp = Math.max(0, c.happiness) / 100;
        
        // Outer border (thicker when impatient)
        const borderWidth = hp < 0.3 ? 2 : 1;
        ctx.fillStyle = hp < 0.3 ? '#ff3333' : 'rgba(0,0,0,0.5)';
        ctx.fillRect(bx - borderWidth, by - borderWidth, bw + borderWidth*2, bh + borderWidth*2);
        
        // Bar background
        ctx.fillStyle = 'rgba(30,30,30,0.8)';
        ctx.fillRect(bx, by, bw, bh);
        
        // Fill color based on happiness
        if (hp > 0.6) {
            ctx.fillStyle = '#00ff88';
        } else if (hp > 0.3) {
            ctx.fillStyle = '#ffaa00';
        } else {
            // Pulsing red for critical patience
            const pulse = 0.7 + 0.3 * Math.sin(now / 150);
            ctx.fillStyle = `rgba(255, ${Math.floor(50 * pulse)}, ${Math.floor(50 * pulse)}, 1)`;
        }
        ctx.fillRect(bx, by, bw * hp, bh);
        
        // Urgency indicators for low patience
        if (hp < 0.3 && hp > 0) {
            // Warning emoji
            const urgencyPulse = Math.sin(now / 200);
            if (urgencyPulse > 0) {
                ctx.font = `${14*cam.zoom}px Arial`;
                ctx.fillText('', s.x - 28*cam.zoom, by + 4*cam.zoom);
            }
            // Danger border glow
            ctx.shadowColor = '#ff3333';
            ctx.shadowBlur = 10 * cam.zoom;
            ctx.strokeStyle = '#ff3333';
            ctx.lineWidth = 1;
            ctx.strokeRect(bx, by, bw, bh);
            ctx.shadowBlur = 0;
        } else if (hp < 0.5 && hp >= 0.3) {
            // Mild warning
            ctx.font = `${12*cam.zoom}px Arial`;
            ctx.fillText('', s.x - 26*cam.zoom, by + 3*cam.zoom);
        }
        
        // Happy indicator for high patience
        if (hp > 0.9 && c.state === 'waiting') {
            ctx.font = `${12*cam.zoom}px Arial`;
            ctx.fillText('', s.x + 22*cam.zoom, by + 3*cam.zoom);
        }
    }
    
    // Speech bubble (suppress if in a conversation)
    const _inConvo = _activeConversations.some(conv => conv.charIds.includes(c.id));
    if (c.quip && c.quipTimer > 0 && !_inConvo) {
        drawSpeechBubble(s.x, s.y - 100*cam.zoom + bob*cam.zoom, c.quip);
    }
    
    // Mood emote bubble (periodic emotional reactions)
    drawMoodEmote(c, s.x, s.y + bob*cam.zoom);
    
    // Close beam-in transform if still active
    if (c._beamIn) {
        ctx.restore();
        ctx.globalAlpha = 1;
    }
    
    // === DEPARTURE STAR RATING ===
    if (c._departRating && c._departRatingTimer > 0) {
        c._departRatingTimer -= 16;
        const dp = 1 - (c._departRatingTimer / 2500);
        const floatUp = dp * 40 * cam.zoom;
        const fadeAlpha = dp < 0.1 ? dp * 10 : (dp > 0.7 ? (1 - dp) * 3.33 : 1);
        
        ctx.globalAlpha = fadeAlpha;
        ctx.font = `bold ${14 * cam.zoom}px Nunito`;
        ctx.textAlign = 'center';
        ctx.fillStyle = '#ffd700';
        ctx.fillText(c._departRating, s.x, s.y - 100 * cam.zoom - floatUp);
        ctx.globalAlpha = 1;
    }
    // Close bar fight glow context
    if (isFighter) { ctx.restore(); }
    // Close entrance animation transform
    if (c._entranceSaved) { ctx.restore(); ctx.globalAlpha = 1; c._entranceSaved = false; }
}

// ==================== MOOD EMOTE SYSTEM ====================
function drawMoodEmote(customer, sx, sy) {
    // Don't show emotes while speaking or walking
    if (customer.quip && customer.quipTimer > 0) return;
    if (customer.state === 'walking' || customer.state === 'leaving') return;
    
    // Initialize emote state
    if (!customer._emoteTimer) customer._emoteTimer = Math.random() * 5000;
    if (!customer._currentEmote) customer._currentEmote = null;
    if (!customer._emoteShowTime) customer._emoteShowTime = 0;
    
    // Tick emote timer
    const dt = 16; // approximate frame time
    customer._emoteTimer -= dt;
    
    // Time to show a new emote?
    if (customer._emoteTimer <= 0 && !customer._currentEmote) {
        customer._currentEmote = getMoodEmote(customer);
        customer._emoteShowTime = 2000; // show for 2 seconds
        customer._emoteTimer = 4000 + Math.random() * 6000; // next emote in 4-10s
    }
    
    // Draw current emote
    if (customer._currentEmote && customer._emoteShowTime > 0) {
        customer._emoteShowTime -= dt;
        
        // Animate the emote
        const progress = 1 - (customer._emoteShowTime / 2000);
        const floatY = Math.sin(progress * Math.PI) * 15 * cam.zoom;
        const scale = progress < 0.1 ? progress * 10 : (progress > 0.9 ? (1 - progress) * 10 : 1);
        const alpha = progress < 0.1 ? progress * 10 : (progress > 0.85 ? (1 - progress) * 6.67 : 1);
        
        // Emote bubble background
        const emoteX = sx + 35 * cam.zoom;
        const emoteY = sy - 50 * cam.zoom - floatY;
        
        ctx.globalAlpha = alpha * 0.9;
        ctx.fillStyle = 'rgba(255,255,255,0.95)';
        ctx.beginPath();
        ctx.arc(emoteX, emoteY, 14 * cam.zoom * scale, 0, Math.PI * 2);
        ctx.fill();
        
        // Bubble pointer
        ctx.beginPath();
        ctx.moveTo(emoteX - 6 * cam.zoom, emoteY + 10 * cam.zoom);
        ctx.lineTo(emoteX - 10 * cam.zoom, emoteY + 18 * cam.zoom);
        ctx.lineTo(emoteX, emoteY + 12 * cam.zoom);
        ctx.closePath();
        ctx.fill();
        
        // Emote emoji
        ctx.font = `${18 * cam.zoom * scale}px Arial`;
        ctx.textAlign = 'center';
        ctx.fillStyle = '#000';
        ctx.globalAlpha = alpha;
        ctx.fillText(customer._currentEmote, emoteX, emoteY + 6 * cam.zoom);
        
        ctx.globalAlpha = 1;
        
        // Clear emote when done
        if (customer._emoteShowTime <= 0) {
            customer._currentEmote = null;
        }
    }
}

function getMoodEmote(customer) {
    const hp = customer.happiness;
    const state = customer.state;
    const char = customer.char;
    
    // State-specific emotes
    if (state === 'drinking') {
        const drinkEmotes = ['', '', '', '', '', '', ''];
        return drinkEmotes[Math.floor(Math.random() * drinkEmotes.length)];
    }
    
    if (state === 'ordered' && customer.drinkProgress >= 1) {
        return ['', '', '', ''][Math.floor(Math.random() * 4)];
    }
    
    // Mood-based emotes
    if (hp > 90) {
        const happyEmotes = ['', '', '', '', '', ''];
        return happyEmotes[Math.floor(Math.random() * happyEmotes.length)];
    } else if (hp > 70) {
        const contentEmotes = ['', '', '', ''];
        return contentEmotes[Math.floor(Math.random() * contentEmotes.length)];
    } else if (hp > 50) {
        const neutralEmotes = ['', '', '', ''];
        return neutralEmotes[Math.floor(Math.random() * neutralEmotes.length)];
    } else if (hp > 30) {
        const annoyedEmotes = ['', '', '', ''];
        return annoyedEmotes[Math.floor(Math.random() * annoyedEmotes.length)];
    } else {
        const angryEmotes = ['', '', '', '', ''];
        return angryEmotes[Math.floor(Math.random() * angryEmotes.length)];
    }
}

function drawSpeechBubble(sx, sy, text) {
    ctx.font = `${11*cam.zoom}px Nunito`;
    const lines = wrapText(text, 130*cam.zoom);
    const lineH = 14*cam.zoom;
    const bw = 140*cam.zoom, bh = lines.length * lineH + 10*cam.zoom;
    const bx = sx - bw/2, by = sy - bh - 5*cam.zoom;
    
    // Bubble
    ctx.fillStyle = 'rgba(255,255,255,0.92)';
    ctx.beginPath();
    const r = 6*cam.zoom;
    ctx.moveTo(bx+r, by);
    ctx.lineTo(bx+bw-r, by);
    ctx.quadraticCurveTo(bx+bw, by, bx+bw, by+r);
    ctx.lineTo(bx+bw, by+bh-r);
    ctx.quadraticCurveTo(bx+bw, by+bh, bx+bw-r, by+bh);
    // Tail
    ctx.lineTo(sx+8*cam.zoom, by+bh);
    ctx.lineTo(sx, by+bh+8*cam.zoom);
    ctx.lineTo(sx-4*cam.zoom, by+bh);
    ctx.lineTo(bx+r, by+bh);
    ctx.quadraticCurveTo(bx, by+bh, bx, by+bh-r);
    ctx.lineTo(bx, by+r);
    ctx.quadraticCurveTo(bx, by, bx+r, by);
    ctx.fill();
    
    ctx.strokeStyle = 'rgba(0,0,0,0.2)';
    ctx.lineWidth = 1;
    ctx.stroke();
    
    // Text
    ctx.fillStyle = '#222';
    ctx.textAlign = 'center';
    lines.forEach((line, i) => {
        ctx.fillText(line, sx, by + 12*cam.zoom + i*lineH);
    });
}

function wrapText(text, maxW) {
    const words = text.split(' ');
    const lines = []; let line = '';
    for (const w of words) {
        const test = line ? line + ' ' + w : w;
        if (ctx.measureText(test).width > maxW && line) {
            lines.push(line); line = w;
        } else { line = test; }
    }
    if (line) lines.push(line);
    return lines;
}

// ==================== UI HELPERS ====================
function updateHUD() {
    updateAbilityBar();
    document.getElementById('hud-credits').textContent = GS.credits;
    document.getElementById('hud-level').textContent = GS.level;
    document.getElementById('hud-xp').textContent = GS.xp;
    document.getElementById('hud-xpmax').textContent = GS.xpNeeded;
    document.getElementById('hud-rep').textContent = Math.floor(GS.reputation);
    document.getElementById('rep-bar-inner').style.width = GS.reputation + '%';
    document.getElementById('hud-streak').textContent = GS._loginStreak || 0;
    document.getElementById('hud-prestige').textContent = GS._prestigePoints || 0;
    updateActiveBonuses();
    updatePersonalRecords(); // Track stats for records
}

function updateActiveBonuses() {
    const panel = document.getElementById('active-bonuses');
    const list = document.getElementById('bonus-list');
    const effects = getActiveDecorationEffects();
    
    if (effects.length === 0) {
        panel.classList.remove('show');
        return;
    }
    
    list.innerHTML = effects.map(e => `
        <div class="bonus-item">
            <span class="bonus-icon">${e.icon}</span>
            <span>${e.desc}</span>
        </div>
    `).join('');
    panel.classList.add('show');
}

function showNotification(msg) {
    const n = document.getElementById('notification');
    n.textContent = msg;
    n.classList.remove('show');
    requestAnimationFrame(() => { n.classList.add('show'); });
    clearTimeout(n._t);
    n._t = setTimeout(() => n.classList.remove('show'), 3500);
}

function addLog(msg, cls) {
    const log = document.getElementById('event-log');
    const div = document.createElement('div');
    div.className = 'log-entry' + (cls ? ' ' + cls : '');
    div.textContent = msg;
    log.appendChild(div);
    if (log.children.length > 8) log.removeChild(log.firstChild);
    setTimeout(() => { if (div.parentNode) div.remove(); }, 8000);
}

// ==================== AUDIO ====================
let audioCtx;
function getAudio() {
    if (!audioCtx) audioCtx = new (window.AudioContext || window.webkitAudioContext)();
    return audioCtx;
}

// ===== SPACE JUKEBOX SYSTEM =====
let musicPlaying = false;
let musicNodes = [];
let jukeboxOpen = false;
let currentStation = null;
let jukeboxVolume = 0.04;

const JUKEBOX_STATIONS = [
    {
        id: 'deep_space', name: 'Deep Space FM', icon: '',
        buff: '+10% patience', buffType: 'patience', buffValue: 0.9,
        desc: 'Ambient cosmic drones',
        play: function(ac, master) {
            const chords = [[65.41,130.81,196],[73.42,146.83,220],[61.74,123.47,185],[55,110,164.81]];
            let idx = 0;
            function loop() {
                if (!musicPlaying || currentStation !== 'deep_space') return;
                const chord = chords[idx++ % chords.length];
                chord.forEach((freq, i) => {
                    const osc = ac.createOscillator(), g = ac.createGain();
                    const lfo = ac.createOscillator(), lg = ac.createGain();
                    osc.type = i===0?'sine':'triangle'; osc.frequency.value = freq;
                    lfo.type='sine'; lfo.frequency.value=0.15+i*0.05; lg.gain.value=freq*0.008;
                    lfo.connect(lg); lg.connect(osc.frequency); osc.connect(g); g.connect(master);
                    const t=ac.currentTime;
                    g.gain.setValueAtTime(0.001,t); g.gain.exponentialRampToValueAtTime(0.5,t+2);
                    g.gain.setValueAtTime(0.5,t+6); g.gain.exponentialRampToValueAtTime(0.001,t+8);
                    osc.start(t); osc.stop(t+8.5); lfo.start(t); lfo.stop(t+8.5);
                    musicNodes.push(osc,lfo);
                });
                setTimeout(loop, 8000);
            }
            loop();
        }
    },
    {
        id: 'cantina_jazz', name: 'Cantina Jazz', icon: '',
        buff: '+15% tips', buffType: 'tips', buffValue: 1.15,
        desc: 'Swinging alien jazz club',
        play: function(ac, master) {
            const scale = [261.63,293.66,329.63,349.23,392,440,493.88,523.25];
            let beat = 0;
            function loop() {
                if (!musicPlaying || currentStation !== 'cantina_jazz') return;
                const t = ac.currentTime;
                // Walking bass
                const bassNote = scale[beat % scale.length] / 2;
                const bass = ac.createOscillator(), bg = ac.createGain();
                bass.type='triangle'; bass.frequency.value=bassNote;
                bass.connect(bg); bg.connect(master);
                bg.gain.setValueAtTime(0.6,t); bg.gain.exponentialRampToValueAtTime(0.001,t+0.3);
                bass.start(t); bass.stop(t+0.35); musicNodes.push(bass);
                // Melody  random jazzy notes
                if (beat%2===0) {
                    const note = scale[Math.floor(Math.random()*scale.length)] * (Math.random()>0.5?2:1);
                    const mel = ac.createOscillator(), mg = ac.createGain();
                    mel.type='sine'; mel.frequency.value=note;
                    mel.connect(mg); mg.connect(master);
                    mg.gain.setValueAtTime(0.3,t+0.05); mg.gain.exponentialRampToValueAtTime(0.001,t+0.25);
                    mel.start(t+0.05); mel.stop(t+0.3); musicNodes.push(mel);
                }
                // Hi-hat
                const noise = ac.createBufferSource();
                const buf = ac.createBuffer(1,ac.sampleRate*0.05,ac.sampleRate);
                const d = buf.getChannelData(0);
                for(let i=0;i<d.length;i++) d[i]=(Math.random()*2-1)*0.3;
                noise.buffer=buf;
                const hg=ac.createGain(); noise.connect(hg); hg.connect(master);
                const hp=ac.createBiquadFilter(); hp.type='highpass'; hp.frequency.value=8000;
                noise.disconnect(); noise.connect(hp); hp.connect(hg);
                hg.gain.setValueAtTime(0.15,t); hg.gain.exponentialRampToValueAtTime(0.001,t+0.05);
                noise.start(t); noise.stop(t+0.06); musicNodes.push(noise);
                beat++;
                setTimeout(loop, 280);
            }
            loop();
        }
    },
    {
        id: 'synthwave', name: 'Neon Synthwave', icon: '',
        buff: '+10% XP', buffType: 'xp', buffValue: 1.1,
        desc: 'Retro-futuristic beats',
        play: function(ac, master) {
            const bassLine = [55,55,73.42,65.41, 55,55,82.41,73.42];
            let step = 0;
            function loop() {
                if (!musicPlaying || currentStation !== 'synthwave') return;
                const t = ac.currentTime;
                // Pulsing bass
                const bass = ac.createOscillator(), bg = ac.createGain();
                bass.type='sawtooth'; bass.frequency.value=bassLine[step%bassLine.length];
                const lp=ac.createBiquadFilter(); lp.type='lowpass'; lp.frequency.value=200;
                bass.connect(lp); lp.connect(bg); bg.connect(master);
                bg.gain.setValueAtTime(0.5,t); bg.gain.exponentialRampToValueAtTime(0.001,t+0.2);
                bass.start(t); bass.stop(t+0.25); musicNodes.push(bass);
                // Arpeggiated synth
                if (step%2===0) {
                    const arpNotes = [329.63,440,523.25,659.25];
                    const n = arpNotes[(step/2)%arpNotes.length];
                    const s=ac.createOscillator(), sg=ac.createGain();
                    s.type='square'; s.frequency.value=n;
                    const f2=ac.createBiquadFilter(); f2.type='lowpass'; f2.frequency.value=2000;
                    s.connect(f2); f2.connect(sg); sg.connect(master);
                    sg.gain.setValueAtTime(0.2,t); sg.gain.exponentialRampToValueAtTime(0.001,t+0.15);
                    s.start(t); s.stop(t+0.18); musicNodes.push(s);
                }
                // Kick on every 4th
                if (step%4===0) {
                    const kick=ac.createOscillator(), kg=ac.createGain();
                    kick.type='sine'; kick.frequency.setValueAtTime(150,t);
                    kick.frequency.exponentialRampToValueAtTime(30,t+0.1);
                    kick.connect(kg); kg.connect(master);
                    kg.gain.setValueAtTime(0.7,t); kg.gain.exponentialRampToValueAtTime(0.001,t+0.15);
                    kick.start(t); kick.stop(t+0.2); musicNodes.push(kick);
                }
                step++;
                setTimeout(loop, 200);
            }
            loop();
        }
    },
    {
        id: 'cosmic_lofi', name: 'Cosmic Lo-Fi', icon: '',
        buff: '+20% happiness', buffType: 'happiness', buffValue: 20,
        desc: 'Chill beats to serve drinks to',
        play: function(ac, master) {
            const chords = [[261.63,329.63,392],[220,277.18,329.63],[246.94,311.13,369.99],[261.63,329.63,415.30]];
            let idx = 0, tick = 0;
            function loop() {
                if (!musicPlaying || currentStation !== 'cosmic_lofi') return;
                const t = ac.currentTime;
                const chord = chords[idx % chords.length];
                if (tick%8===0) idx++;
                // Soft Rhodes-like chord
                if (tick%8===0 || tick%8===3 || tick%8===6) {
                    chord.forEach(f => {
                        const o=ac.createOscillator(), g=ac.createGain();
                        o.type='sine'; o.frequency.value=f;
                        const lp=ac.createBiquadFilter(); lp.type='lowpass'; lp.frequency.value=1200;
                        o.connect(lp); lp.connect(g); g.connect(master);
                        g.gain.setValueAtTime(0.25,t); g.gain.exponentialRampToValueAtTime(0.001,t+0.5);
                        o.start(t); o.stop(t+0.55); musicNodes.push(o);
                    });
                }
                // Vinyl crackle
                if (Math.random()>0.7) {
                    const nb=ac.createBuffer(1,ac.sampleRate*0.03,ac.sampleRate);
                    const nd=nb.getChannelData(0);
                    for(let i=0;i<nd.length;i++) nd[i]=(Math.random()*2-1)*0.04;
                    const ns=ac.createBufferSource(); ns.buffer=nb;
                    const ng=ac.createGain(); ns.connect(ng); ng.connect(master);
                    ng.gain.value=0.3; ns.start(t); ns.stop(t+0.03); musicNodes.push(ns);
                }
                // Soft kick
                if (tick%4===0) {
                    const k=ac.createOscillator(), kg=ac.createGain();
                    k.type='sine'; k.frequency.setValueAtTime(80,t); k.frequency.exponentialRampToValueAtTime(30,t+0.08);
                    k.connect(kg); kg.connect(master);
                    kg.gain.setValueAtTime(0.4,t); kg.gain.exponentialRampToValueAtTime(0.001,t+0.1);
                    k.start(t); k.stop(t+0.15); musicNodes.push(k);
                }
                tick++;
                setTimeout(loop, 350);
            }
            loop();
        }
    },
    {
        id: 'warp_metal', name: 'Warp Core Metal', icon: '',
        buff: '+20% speed', buffType: 'speed', buffValue: 0.8,
        desc: 'Heavy riffs from the void',
        play: function(ac, master) {
            const riff = [82.41,82.41,110,98,82.41,73.42,82.41,110];
            let step = 0;
            function loop() {
                if (!musicPlaying || currentStation !== 'warp_metal') return;
                const t = ac.currentTime;
                // Distorted power chord
                const f = riff[step%riff.length];
                [f, f*1.498, f*2].forEach(freq => {
                    const o=ac.createOscillator(), g=ac.createGain();
                    o.type='sawtooth'; o.frequency.value=freq;
                    const ws=ac.createWaveShaper();
                    const curve=new Float32Array(256);
                    for(let i=0;i<256;i++){const x=i*2/256-1; curve[i]=Math.tanh(x*4);}
                    ws.curve=curve;
                    const lp=ac.createBiquadFilter(); lp.type='lowpass'; lp.frequency.value=1500;
                    o.connect(ws); ws.connect(lp); lp.connect(g); g.connect(master);
                    g.gain.setValueAtTime(0.15,t); g.gain.exponentialRampToValueAtTime(0.001,t+0.12);
                    o.start(t); o.stop(t+0.15); musicNodes.push(o);
                });
                // Double kick
                if (step%2===0) {
                    const k=ac.createOscillator(), kg=ac.createGain();
                    k.type='sine'; k.frequency.setValueAtTime(200,t); k.frequency.exponentialRampToValueAtTime(40,t+0.05);
                    k.connect(kg); kg.connect(master);
                    kg.gain.setValueAtTime(0.7,t); kg.gain.exponentialRampToValueAtTime(0.001,t+0.07);
                    k.start(t); k.stop(t+0.1); musicNodes.push(k);
                }
                step++;
                setTimeout(loop, 150);
            }
            loop();
        }
    }
];

function toggleJukebox() {
    jukeboxOpen = !jukeboxOpen;
    const panel = document.getElementById('jukebox-panel');
    panel.classList.toggle('open', jukeboxOpen);
    if (jukeboxOpen) buildJukeboxUI();
}

function buildJukeboxUI() {
    const container = document.getElementById('jukebox-stations');
    container.innerHTML = '';
    JUKEBOX_STATIONS.forEach(s => {
        const div = document.createElement('div');
        div.className = 'juke-station' + (currentStation === s.id ? ' active' : '');
        div.innerHTML = `<span class="juke-icon">${s.icon}</span>
            <div class="juke-info"><div class="juke-name">${s.name}</div><div class="juke-buff">${s.buff}</div></div>
            <div class="juke-eq"><span></span><span></span><span></span><span></span></div>`;
        div.onclick = () => playStation(s.id);
        container.appendChild(div);
    });
}

function playStation(stationId) {
    const ac = getAudio(); ac.resume();
    // Stop current
    musicNodes.forEach(n => { try { n.stop(); } catch(e){} });
    musicNodes = [];
    musicPlaying = false;
    
    const station = JUKEBOX_STATIONS.find(s => s.id === stationId);
    if (!station || currentStation === stationId) {
        // Toggle off if clicking same station
        currentStation = null;
        musicPlaying = false;
        document.getElementById('jukebox-btn').classList.remove('playing');
        document.getElementById('jukebox-btn').textContent = ' Jukebox';
        buildJukeboxUI();
        return;
    }
    
    currentStation = stationId;
    musicPlaying = true;
    
    const masterGain = ac.createGain();
    masterGain.gain.value = jukeboxVolume;
    masterGain.connect(ac.destination);
    window._jukeMaster = masterGain;
    
    station.play(ac, masterGain);
    
    document.getElementById('jukebox-btn').classList.add('playing');
    document.getElementById('jukebox-btn').textContent = ` ${station.icon} ${station.name}`;
    buildJukeboxUI();
    logEvent(` Now playing: ${station.icon} ${station.name}  ${station.buff}`, 'info');
}

function stopJukebox() {
    musicNodes.forEach(n => { try { n.stop(); } catch(e){} });
    musicNodes = [];
    musicPlaying = false;
    currentStation = null;
    document.getElementById('jukebox-btn').classList.remove('playing');
    document.getElementById('jukebox-btn').textContent = ' Jukebox';
    buildJukeboxUI();
    jukeboxOpen = false;
    document.getElementById('jukebox-panel').classList.remove('open');
}

function setJukeboxVolume(val) {
    jukeboxVolume = (val / 100) * 0.1; // 0 to 0.1
    if (window._jukeMaster) window._jukeMaster.gain.value = jukeboxVolume;
}

function getJukeboxBuff(type) {
    if (!musicPlaying || !currentStation) return type === 'happiness' ? 0 : 1;
    const station = JUKEBOX_STATIONS.find(s => s.id === currentStation);
    if (!station || station.buffType !== type) return type === 'happiness' ? 0 : 1;
    return station.buffValue;
}

// Legacy compat
function toggleMusic() { if (musicPlaying) stopJukebox(); else playStation('deep_space'); }
function startMusic() { playStation('deep_space'); }
function stopMusic() { stopJukebox(); }

// ===== SOUND EFFECTS =====
function playSound(type) {
    try {
        const ac = getAudio();
        const t = ac.currentTime;

        if (type === 'order') {
            // Blip + subtle whoosh
            playTone(ac, 660, 'sine', 0.08, t, 0.06);
            playTone(ac, 880, 'sine', 0.05, t + 0.06, 0.08);
        } else if (type === 'ready') {
            // Ding-ding!
            playTone(ac, 1200, 'sine', 0.07, t, 0.1);
            playTone(ac, 1500, 'sine', 0.07, t + 0.1, 0.15);
        } else if (type === 'serve') {
            // Cash register arpeggio
            [523, 659, 784, 1047].forEach((f, i) => playTone(ac, f, 'sine', 0.07, t + i*0.06, 0.12));
            // Add a shimmer
            playNoise(ac, 0.02, t + 0.1, 0.15);
        } else if (type === 'buy') {
            playTone(ac, 440, 'triangle', 0.06, t, 0.08);
            playTone(ac, 660, 'triangle', 0.06, t + 0.08, 0.1);
        } else if (type === 'levelup') {
            // Fanfare!
            [523, 659, 784, 1047, 1319].forEach((f, i) => playTone(ac, f, 'sine', 0.09, t + i*0.1, 0.25));
            playNoise(ac, 0.03, t + 0.3, 0.3);
        } else if (type === 'angry') {
            // Sad descending
            playTone(ac, 400, 'sawtooth', 0.04, t, 0.15);
            playTone(ac, 300, 'sawtooth', 0.04, t + 0.1, 0.2);
        } else if (type === 'combo') {
            // Sparkle ascending
            [880, 1100, 1320, 1760].forEach((f, i) => playTone(ac, f, 'sine', 0.06, t + i*0.05, 0.15));
        } else if (type === 'click') {
            playTone(ac, 1000, 'square', 0.03, t, 0.03);
        } else if (type === 'gift') {
            // Magical chime  ascending sparkle with shimmer
            [784, 988, 1175, 1568, 1976].forEach((f, i) => playTone(ac, f, 'sine', 0.06, t + i*0.07, 0.2));
            playTone(ac, 2093, 'sine', 0.04, t + 0.35, 0.4);
            playNoise(ac, 0.015, t + 0.2, 0.25);
        } else if (type === 'bounty') {
            // Dramatic completion  brass-like fanfare
            playTone(ac, 349, 'sawtooth', 0.04, t, 0.2);
            playTone(ac, 440, 'sawtooth', 0.04, t + 0.15, 0.2);
            playTone(ac, 523, 'sawtooth', 0.05, t + 0.3, 0.3);
            playTone(ac, 698, 'triangle', 0.06, t + 0.45, 0.4);
            playNoise(ac, 0.02, t + 0.4, 0.2);
        } else if (type === 'spin') {
            // Roulette tick
            playTone(ac, 1200, 'square', 0.04, t, 0.02);
        } else if (type === 'spinwin') {
            // Jackpot celebration
            [523, 659, 784].forEach((f, i) => playTone(ac, f, 'sine', 0.08, t + i*0.08, 0.15));
            [1047, 1319, 1568].forEach((f, i) => playTone(ac, f, 'sine', 0.06, t + 0.3 + i*0.08, 0.2));
            playNoise(ac, 0.03, t + 0.5, 0.3);
        } else if (type === 'whoosh') {
            // Quick whoosh for panel open/close
            playNoise(ac, 0.03, t, 0.12);
        } else if (type === 'bubble') {
            // Bubbly pop for Blorb interactions
            playTone(ac, 300 + Math.random() * 400, 'sine', 0.04, t, 0.08);
            playTone(ac, 500 + Math.random() * 300, 'sine', 0.03, t + 0.05, 0.06);
        }
    } catch(e) {}
}

function playTone(ac, freq, type, vol, startTime, dur) {
    const osc = ac.createOscillator();
    const g = ac.createGain();
    osc.connect(g); g.connect(ac.destination);
    osc.type = type;
    osc.frequency.value = freq;
    g.gain.setValueAtTime(vol, startTime);
    g.gain.exponentialRampToValueAtTime(0.001, startTime + dur);
    osc.start(startTime);
    osc.stop(startTime + dur + 0.01);
}

function playNoise(ac, vol, startTime, dur) {
    const bufSize = ac.sampleRate * dur;
    const buf = ac.createBuffer(1, bufSize, ac.sampleRate);
    const data = buf.getChannelData(0);
    for (let i = 0; i < bufSize; i++) data[i] = (Math.random() * 2 - 1) * 0.5;
    const src = ac.createBufferSource();
    src.buffer = buf;
    const g = ac.createGain();
    src.connect(g); g.connect(ac.destination);
    g.gain.setValueAtTime(vol, startTime);
    g.gain.exponentialRampToValueAtTime(0.001, startTime + dur);
    src.start(startTime);
    src.stop(startTime + dur + 0.01);
}

// ==================== COMBO SYSTEM ====================
let comboCount = 0;
let comboTimer = 0;

function showCombo(count, bonus) {
    // Track max combo for achievements
    GS._maxCombo = Math.max(GS._maxCombo || 0, count);
    
    const el = document.getElementById('combo-display');
    el.textContent = ` ${count}x COMBO! +${bonus} bonus!`;
    el.classList.add('show');
    clearTimeout(el._t);
    el._t = setTimeout(() => el.classList.remove('show'), 2500);
    
    // ===== COMBO VISUAL EFFECTS =====
    // Sparkles and particles scale with combo count
    const intensity = Math.min(count, 10);
    spawnSparkles(BAR_CENTER.x, BAR_CENTER.y, intensity);
    spawnParticleBurst(BAR_CENTER.x, BAR_CENTER.y, '#ff00ff', intensity * 2);
    spawnFloatingNumber(BAR_CENTER.x, BAR_CENTER.y, `+${bonus}`, 'combo');
    
    // Screen shake for big combos
    if (count >= 5) {
        screenShake();
    }
    
    // Extra effects for milestone combos
    if (count === 10) {
        setTimeout(() => spawnParticleBurst(BAR_CENTER.x, BAR_CENTER.y, '#ffd700', 25), 150);
        setTimeout(() => spawnSparkles(BAR_CENTER.x, BAR_CENTER.y, 15), 300);
    }
    
    checkAchievements(); // Check for combo achievements
}

// ==================== FLOATING EMOJIS ====================
function spawnFloatingEmojis(wx, wy, emojis) {
    const s = w2s(wx, wy);
    emojis.forEach((emoji, i) => {
        const el = document.createElement('div');
        el.className = 'float-emoji';
        el.textContent = emoji;
        el.style.left = (s.x + (Math.random() - 0.5) * 60) + 'px';
        el.style.top = (s.y - 50 - i * 15) + 'px';
        el.style.animationDelay = (i * 0.15) + 's';
        document.getElementById('game-container').appendChild(el);
        setTimeout(() => el.remove(), 2000);
    });
}

// ==================== FLOATING NUMBERS ====================
function spawnFloatingNumber(wx, wy, text, type = 'credits') {
    const s = w2s(wx, wy);
    const el = document.createElement('div');
    el.className = `float-number ${type}`;
    el.textContent = text;
    el.style.left = (s.x + (Math.random() - 0.5) * 40) + 'px';
    el.style.top = (s.y - 40) + 'px';
    document.getElementById('game-container').appendChild(el);
    setTimeout(() => el.remove(), 1200);
}

function spawnFlyingCoin(wx, wy) {
    const s = w2s(wx, wy);
    const el = document.createElement('div');
    el.className = 'flying-coin';
    el.textContent = '';
    el.style.left = s.x + 'px';
    el.style.top = s.y + 'px';
    document.getElementById('game-container').appendChild(el);
    
    // Target: HUD Credits (approx top-left)
    setTimeout(() => {
        el.style.left = '30px';
        el.style.top = '15px';
        el.style.transform = 'scale(0.5)';
        el.style.opacity = '0';
    }, 50);
    
    setTimeout(() => el.remove(), 900);
}

// ==================== PARTICLE BURST ====================
function spawnParticleBurst(wx, wy, color, count = 12) {
    const s = w2s(wx, wy);
    for (let i = 0; i < count; i++) {
        const angle = (Math.PI * 2 / count) * i + (Math.random() - 0.5) * 0.5;
        const speed = 40 + Math.random() * 40;
        const px = Math.cos(angle) * speed;
        const py = Math.sin(angle) * speed;
        
        const particle = document.createElement('div');
        particle.className = 'particle';
        particle.style.left = s.x + 'px';
        particle.style.top = s.y + 'px';
        particle.style.background = color;
        particle.style.setProperty('--px', px + 'px');
        particle.style.setProperty('--py', py + 'px');
        
        document.getElementById('game-container').appendChild(particle);
        setTimeout(() => particle.remove(), 800);
    }
}

// ==================== SPARKLE EFFECT ====================
function spawnSparkles(wx, wy, count = 5) {
    const s = w2s(wx, wy);
    for (let i = 0; i < count; i++) {
        const sparkle = document.createElement('div');
        sparkle.className = 'sparkle';
        sparkle.textContent = '';
        sparkle.style.left = (s.x + (Math.random() - 0.5) * 50) + 'px';
        sparkle.style.top = (s.y + (Math.random() - 0.5) * 50) + 'px';
        sparkle.style.animationDelay = (i * 0.1) + 's';
        
        document.getElementById('game-container').appendChild(sparkle);
        setTimeout(() => sparkle.remove(), 600);
    }
}

// ==================== COMBO FIREWORKS ====================
const fireworks = [];

function spawnComboFireworks(comboLevel) {
    // More fireworks for higher combos
    const count = comboLevel >= 25 ? 8 : comboLevel >= 15 ? 6 : comboLevel >= 10 ? 4 : 3;
    const colors = [
        ['#ff4444', '#ff8866', '#ffaa44'],  // Red/orange
        ['#44ff88', '#88ffcc', '#aaffee'],  // Green/teal
        ['#4488ff', '#66aaff', '#88ccff'],  // Blue
        ['#ff44ff', '#ff88dd', '#ffaaff'],  // Pink/magenta
        ['#ffd700', '#ffee44', '#ffffff'],  // Gold/white
        ['#00ffff', '#44ffff', '#88ffff'],  // Cyan
    ];
    for (let i = 0; i < count; i++) {
        const delay = i * 200 + Math.random() * 300;
        setTimeout(() => {
            const palette = colors[Math.floor(Math.random() * colors.length)];
            fireworks.push({
                x: W * 0.15 + Math.random() * W * 0.7,
                y: H * 0.1 + Math.random() * H * 0.35,
                particles: Array.from({ length: 30 + comboLevel }, () => {
                    const angle = Math.random() * Math.PI * 2;
                    const speed = 1 + Math.random() * 3;
                    return {
                        x: 0, y: 0,
                        vx: Math.cos(angle) * speed,
                        vy: Math.sin(angle) * speed,
                        color: palette[Math.floor(Math.random() * palette.length)],
                        life: 1,
                        size: 1 + Math.random() * 2,
                    };
                }),
                trail: [],
                phase: 'burst',
                age: 0,
            });
            try { playSound('combo'); } catch(e) {}
        }, delay);
    }
    // Screen shake for big combos
    if (comboLevel >= 10) screenShake('normal');
}

function drawFireworks() {
    for (let i = fireworks.length - 1; i >= 0; i--) {
        const fw = fireworks[i];
        fw.age += 16;
        let allDead = true;
        for (const p of fw.particles) {
            if (p.life <= 0) continue;
            allDead = false;
            p.x += p.vx;
            p.y += p.vy;
            p.vy += 0.03; // Gravity
            p.vx *= 0.98; // Air resistance
            p.life -= 0.015;
            ctx.globalAlpha = Math.max(0, p.life);
            ctx.fillStyle = p.color;
            ctx.beginPath();
            ctx.arc(fw.x + p.x, fw.y + p.y, p.size, 0, Math.PI * 2);
            ctx.fill();
            // Trailing glow
            if (p.life > 0.3) {
                ctx.globalAlpha = p.life * 0.3;
                ctx.beginPath();
                ctx.arc(fw.x + p.x, fw.y + p.y, p.size * 3, 0, Math.PI * 2);
                ctx.fill();
            }
        }
        ctx.globalAlpha = 1;
        if (allDead) fireworks.splice(i, 1);
    }
}

// ==================== SCREEN SHAKE ====================
function screenShake(intensity = 'normal') {
    const container = document.getElementById('game-container');
    container.classList.add('shake');
    setTimeout(() => container.classList.remove('shake'), 400);
}

// ==================== CUSTOMER HAPPINESS INDICATOR ====================
function showHappinessChange(customer, change) {
    if (change > 0) {
        spawnFloatingEmojis(customer.pos.x, customer.pos.y, ['']);
    } else if (change < -10) {
        spawnFloatingEmojis(customer.pos.x, customer.pos.y, ['']);
    }
}

// ==================== ENHANCED STAR PARTICLES ====================
const nebulaClouds = [];
for (let i = 0; i < 5; i++) {
    nebulaClouds.push({
        x: Math.random(), y: Math.random(),
        r: 80 + Math.random() * 120,
        color: ['rgba(0,100,255,', 'rgba(100,0,200,', 'rgba(0,200,100,', 'rgba(200,50,100,', 'rgba(50,150,200,'][i],
        speed: 0.00002 + Math.random() * 0.00003
    });
}

// Shooting stars
const shootingStars = [];
let starCatchStreak = 0;
let lastStarCatchTime = 0;
function maybeSpawnShootingStar() {
    if (Math.random() < 0.002 && shootingStars.length < 2) {
        shootingStars.push({
            x: Math.random() * W, y: Math.random() * H * 0.3,
            vx: 3 + Math.random() * 4, vy: 1 + Math.random() * 2,
            life: 1.0, trail: [], caught: false
        });
    }
}

// ==================== CLICKABLE SHOOTING STARS ====================
function tryClickShootingStar(cx, cy) {
    for (let i = shootingStars.length - 1; i >= 0; i--) {
        const ss = shootingStars[i];
        if (ss.caught) continue;
        const dx = cx - ss.x, dy = cy - ss.y;
        if (Math.sqrt(dx*dx + dy*dy) < 35) {
            catchShootingStar(ss, i);
            return true;
        }
    }
    // Also check comets
    for (let i = spaceWeather.comets.length - 1; i >= 0; i--) {
        const c = spaceWeather.comets[i];
        if (c.caught) continue;
        const dx = cx - c.x, dy = cy - c.y;
        if (Math.sqrt(dx*dx + dy*dy) < 45) {
            catchComet(c, i);
            return true;
        }
    }
    return false;
}

function catchShootingStar(ss, idx) {
    ss.caught = true;
    const now = performance.now();
    // Streak: catch within 10s of last catch
    if (now - lastStarCatchTime < 10000) {
        starCatchStreak++;
    } else {
        starCatchStreak = 1;
    }
    lastStarCatchTime = now;
    
    const baseReward = 5 + Math.floor(Math.random() * 21); // 5-25 credits
    const streakBonus = Math.min(starCatchStreak - 1, 5); // up to 5x streak
    const reward = baseReward + (streakBonus * 5);
    
    GS.credits += reward;
    GS.totalEarned += reward;
    GS._starsCaught = (GS._starsCaught || 0) + 1;
    
    // Visual feedback
    spawnFloatingNumber(ss.x, ss.y, `+${reward}`, 'combo');
    spawnParticleBurst(ss.x, ss.y, '#ffd700', 15);
    spawnSparkles(ss.x, ss.y, 10);
    playSound('combo');
    
    if (starCatchStreak >= 3) {
        showNotification(` Star Streak x${starCatchStreak}! +${reward} credits!`);
    } else {
        showNotification(` Caught a shooting star! +${reward} credits!`);
    }
    
    // Achievement tracking
    if (GS._starsCaught === 10) {
        showNotification(' STARGAZER! Caught 10 shooting stars!');
        spawnParticleBurst(W/2, H/2, '#ffff00', 30);
    } else if (GS._starsCaught === 50) {
        showNotification(' STAR COLLECTOR! Caught 50 shooting stars!');
        GS.credits += 200;
        spawnParticleBurst(W/2, H/2, '#ff00ff', 40);
    } else if (GS._starsCaught === 100) {
        showNotification(' COSMIC CATCHER! 100 stars! +500 credits!');
        GS.credits += 500;
        spawnParticleBurst(W/2, H/2, '#00ffff', 50);
    }
    
    // Remove after brief flash
    setTimeout(() => { shootingStars.splice(shootingStars.indexOf(ss), 1); }, 100);
}

function catchComet(comet, idx) {
    comet.caught = true;
    const reward = 20 + Math.floor(Math.random() * 31); // 20-50 credits (comets worth more)
    GS.credits += reward;
    GS.totalEarned += reward;
    GS._starsCaught = (GS._starsCaught || 0) + 1;
    
    spawnFloatingNumber(comet.x, comet.y, `+${reward}`, 'combo');
    spawnParticleBurst(comet.x, comet.y, comet.color || '#ffaa33', 20);
    spawnSparkles(comet.x, comet.y, 12);
    playSound('levelup');
    showNotification(` Caught a comet! +${reward} credits!`);
    
    setTimeout(() => { spaceWeather.comets.splice(spaceWeather.comets.indexOf(comet), 1); }, 100);
}

// ==================== DAY/NIGHT CYCLE ====================
const DAY_CYCLE_MS = 120000; // 2 min = 1 full day
const TIME_PHASES = [
    { name: 'Dawn',        icon: '', start: 0.00, overlay: 'rgba(80,50,20,0.15)', spawnMod: 0.7 },
    { name: 'Morning',     icon: '', start: 0.10, overlay: 'rgba(0,0,0,0)',        spawnMod: 0.8 },
    { name: 'Afternoon',   icon: '', start: 0.30, overlay: 'rgba(0,0,0,0)',        spawnMod: 1.0 },
    { name: 'Happy Hour',  icon: '', start: 0.55, overlay: 'rgba(255,100,0,0.08)', spawnMod: 1.5 },
    { name: 'Evening',     icon: '', start: 0.65, overlay: 'rgba(40,20,80,0.15)',  spawnMod: 1.3 },
    { name: 'Night Shift', icon: '', start: 0.80, overlay: 'rgba(0,0,40,0.25)',    spawnMod: 0.6 },
    { name: 'Late Night',  icon: '', start: 0.90, overlay: 'rgba(0,0,50,0.35)',    spawnMod: 0.4 },
];

let dayTimer = 0;
let currentPhase = TIME_PHASES[0];

function updateDayNight(dt) {
    dayTimer = (dayTimer + dt) % DAY_CYCLE_MS;
    const progress = dayTimer / DAY_CYCLE_MS;
    // Find current phase
    let phase = TIME_PHASES[0];
    for (let i = TIME_PHASES.length - 1; i >= 0; i--) {
        if (progress >= TIME_PHASES[i].start) { phase = TIME_PHASES[i]; break; }
    }
    if (phase !== currentPhase) {
        currentPhase = phase;
        document.getElementById('daynight-overlay').style.background = phase.overlay;
        document.getElementById('time-display').textContent = `${phase.icon} ${phase.name}`;
        if (phase.name === 'Happy Hour') {
            showNotification(' HAPPY HOUR! More customers incoming!');
            addLog(' Happy Hour started!', 'tip');
        }
    }
}

// ==================== VIP CUSTOMERS ====================
let vipChance = 0.08; // 8% chance per spawn

function isVipSpawn() {
    // Ambassador event = guaranteed super-VIP
    if (GS._nextIsAmbassador) {
        GS._nextIsAmbassador = false;
        return 'ambassador';
    }
    // SPECIAL EVENT - Forced VIP spawn
    if (GS._forceVIP) {
        return true;
    }
    // DECORATION BONUS - Apply VIP spawn chance multiplier
    const decoBonuses = getDecorationBonuses();
    const baseChance = vipChance + (GS.level * 0.005);
    const beaconMult = GS.upgrades.includes('vip_beacon') ? 1.5 : 1;
    return Math.random() < (baseChance * decoBonuses.vip * beaconMult);
}

function makeVip(customer) {
    const isAmbassador = customer._isAmbassador || false;
    customer.isVip = true;
    customer.tipMultiplier = isAmbassador ? 5.0 : 2.5;
    customer.happiness = 100;
    customer.patienceRate *= isAmbassador ? 0.4 : 0.6; // Ambassadors very patient
    
    if (isAmbassador) {
        addLog(` ALIEN AMBASSADOR ${CHAR_DATA[customer.char].name} arrived! 5x tips!`, 'tip');
        spawnSparkles(customer.pos.x, customer.pos.y, 10);
        spawnParticleBurst(customer.pos.x, customer.pos.y, '#9d4edd', 15);
    } else {
        addLog(` VIP ${CHAR_DATA[customer.char].name} arrived!`, 'tip');
    }
}

// ==================== RANDOM EVENTS ====================
const RANDOM_EVENTS = [
    // ===== NEGATIVE EVENTS =====
    {
        id: 'bar_fight', name: 'Bar Fight!', icon: '',
        desc: 'Dick started a brawl! Customers flee but Dick tips extra out of guilt.',
        effect(gs) {
            const nonDick = gs.customers.filter(c => c.char !== 'dick' && c.state !== 'leaving');
            const toKick = nonDick.slice(0, Math.ceil(nonDick.length / 2));
            toKick.forEach(c => { 
                c.state = 'leaving'; 
                c.targetPos = { ...ENTRY_POS };
                spawnFloatingEmojis(c.pos.x, c.pos.y, ['', '']);
            });
            gs.reputation = Math.max(0, gs.reputation - 8);
            gs.credits += 30;
            addLog(' Bar fight! Dick pays 30 Cr in damages', 'bad');
            screenShake();
        },
        duration: 5000,
    },
    {
        id: 'power_surge', name: 'Power Surge!', icon: '',
        desc: 'A power surge knocked out the lights! Drinks take longer for 20 seconds.',
        effect(gs) {
            gs._slowDrinksUntil = performance.now() + 20000;
            addLog(' Power surge! Drinks slowed for 20s', 'bad');
        },
        duration: 3500,
    },
    {
        id: 'space_pirates', name: 'Space Pirates!', icon: '',
        desc: 'Pirates demanding "protection money"! Pay 50 credits or lose 15 reputation!',
        effect(gs) {
            if (gs.credits >= 50) {
                gs.credits -= 50;
                addLog(' Paid off pirates: -50 Cr', 'bad');
            } else {
                gs.reputation = Math.max(0, gs.reputation - 15);
                addLog(' Pirates trashed the bar! -15 rep', 'bad');
                screenShake();
            }
        },
        duration: 4000,
    },
    {
        id: 'asteroid_scare', name: 'Asteroid Scare!', icon: '',
        desc: 'Proximity alert! Everyone panics for a moment. All customers lose 20 happiness.',
        effect(gs) {
            gs.customers.forEach(c => { 
                c.happiness = Math.max(0, c.happiness - 20);
                showHappinessChange(c, -20);
            });
            addLog(' Asteroid near-miss! Everyone spooked (-20 mood)', 'bad');
            screenShake();
        },
        duration: 3500,
    },
    {
        id: 'hangover_epidemic', name: 'Hangover Epidemic!', icon: '',
        desc: 'Everyone\'s hungover from last night! Customers more impatient for 30 seconds.',
        effect(gs) {
            gs._impatientUntil = performance.now() + 30000;
            gs.customers.forEach(c => { c.patienceRate *= 1.5; });
            addLog(' Everyone\'s hungover! Patience -50% for 30s', 'bad');
        },
        duration: 4000,
    },
    
    // ===== POSITIVE EVENTS =====
    {
        id: 'celebrity', name: 'Celebrity Visit!', icon: '',
        desc: 'A famous Space DJ just walked in! Double tips for 30 seconds!',
        effect(gs) {
            gs._doubleTipsUntil = performance.now() + 30000;
            gs.reputation = Math.min(100, gs.reputation + 5);
            addLog(' Celebrity in the house! Double tips for 30s!', 'tip');
            spawnSparkles(BAR_CENTER.x, BAR_CENTER.y, 15);
        },
        duration: 4000,
    },
    {
        id: 'supply_drop', name: 'Supply Drop!', icon: '',
        desc: 'A cargo ship dropped some free supplies! +75 Credits!',
        effect(gs) {
            gs.credits += 75;
            addLog(' Free supplies! +75 Cr', 'earn');
            spawnParticleBurst(BAR_CENTER.x, BAR_CENTER.y, '#ffd700', 15);
            spawnFloatingNumber(BAR_CENTER.x, BAR_CENTER.y, '+75', 'credits');
        },
        duration: 3500,
    },
    {
        id: 'karaoke', name: 'Karaoke Night!', icon: '',
        desc: 'Walter grabbed the mic! All customers get +30 happiness!',
        effect(gs) {
            gs.customers.forEach(c => { 
                c.happiness = Math.min(100, c.happiness + 30);
                showHappinessChange(c, 30);
                spawnSparkles(c.pos.x, c.pos.y, 3);
            });
            gs.reputation = Math.min(100, gs.reputation + 3);
            addLog(' Walter singing! Everyone\'s happy (+30 mood)', 'earn');
        },
        duration: 4000,
    },
    {
        id: 'tourist_wave', name: 'Tourist Wave!', icon: '',
        desc: 'A tour group just docked! Spawn rate doubled for 30 seconds!',
        effect(gs) {
            gs._rushHourUntil = performance.now() + 30000;
            gs.reputation = Math.min(100, gs.reputation + 5);
            addLog(' Tourist wave incoming! Get ready for a rush!', 'tip');
        },
        duration: 4000,
    },
    {
        id: 'lucky_night', name: 'Lucky Night!', icon: '',
        desc: 'The cosmos align! +50 XP and +30 Credits!',
        effect(gs) {
            gs.credits += 30;
            gs.xp += 50;
            addLog(' Lucky night! +30 Cr, +50 XP', 'earn');
            spawnParticleBurst(BAR_CENTER.x, BAR_CENTER.y, '#00ff88', 20);
            spawnFloatingNumber(BAR_CENTER.x - 30, BAR_CENTER.y, '+30', 'credits');
            spawnFloatingNumber(BAR_CENTER.x + 30, BAR_CENTER.y, '+50 XP', 'xp');
            checkLevelUp();
        },
        duration: 3500,
    },
    {
        id: 'cosmic_aurora', name: 'Cosmic Aurora!', icon: '',
        desc: 'Beautiful space aurora outside! All customers mesmerized. +20 happiness, slower patience drain.',
        effect(gs) {
            gs._auroraUntil = performance.now() + 40000;
            gs.customers.forEach(c => { 
                c.happiness = Math.min(100, c.happiness + 20);
                c.patienceRate *= 0.6; // 40% slower drain
                showHappinessChange(c, 20);
            });
            gs.reputation = Math.min(100, gs.reputation + 8);
            addLog(' Cosmic aurora! Everyone enchanted (+20 mood, +patience)', 'earn');
        },
        duration: 5000,
    },
    
    // ===== NEUTRAL / STORY EVENTS =====
    {
        id: 'health_inspection', name: 'Health Inspection!', icon: '',
        desc: 'A Galactic Health Inspector is here! Pass with 40+ reputation or pay a fine!',
        effect(gs) {
            if (gs.reputation >= 40) {
                gs.credits += 50;
                gs.reputation = Math.min(100, gs.reputation + 10);
                addLog(' Passed inspection! +50 Cr bonus, +10 rep', 'earn');
                spawnFloatingEmojis(BAR_CENTER.x, BAR_CENTER.y, ['', '']);
            } else {
                const fine = 80;
                gs.credits = Math.max(0, gs.credits - fine);
                addLog(` Failed inspection! -${fine} Cr fine`, 'bad');
                spawnFloatingEmojis(BAR_CENTER.x, BAR_CENTER.y, ['', '']);
            }
        },
        duration: 4000,
    },
    {
        id: 'carl_dog_dream', name: 'Carl\'s Dog Dream!', icon: '',
        desc: 'Carl is rambling about Earth dogs AGAIN! He\'ll tip extra if you listen.',
        effect(gs) {
            const carl = gs.customers.find(c => c.char === 'carl');
            if (carl) {
                carl.happiness = Math.min(100, carl.happiness + 40);
                carl.tipMultiplier = (carl.tipMultiplier || 1) + 1.5;
                carl.quip = "Did you know Golden Retrievers can fetch?!";
                carl.quipTimer = 4000;
                showHappinessChange(carl, 40);
                addLog(' Carl is SO happy! Next drink = huge tip!', 'tip');
            } else {
                gs.credits += 20;
                addLog(' Carl left a tip note about dogs: +20 Cr', 'earn');
            }
        },
        duration: 4500,
    },
    {
        id: 'mary_pep_talk', name: 'Mary\'s Pep Talk!', icon: '',
        desc: 'Mary gives you an encouraging speech! Drink speed +25% for 40 seconds!',
        effect(gs) {
            gs._speedBoostUntil = performance.now() + 40000;
            gs.reputation = Math.min(100, gs.reputation + 5);
            addLog(' Mary\'s pep talk! Drinks 25% faster for 40s!', 'earn');
            spawnFloatingEmojis(MARY_POS.x, MARY_POS.y, ['', '', '']);
        },
        duration: 4000,
    },
    {
        id: 'meteor_shower', name: 'Meteor Shower!', icon: '',
        desc: 'Spectacular meteor shower outside! Customers stay longer to watch.',
        effect(gs) {
            gs.customers.forEach(c => {
                if (c.state === 'drinking') {
                    c.drinkTimer += 3000; // Stay 3s longer
                }
                c.quip = "*watching the meteors in awe*";
                c.quipTimer = 5000;
            });
            gs.reputation = Math.min(100, gs.reputation + 6);
            addLog(' Meteor shower! Customers staying to watch', 'tip');
        },
        duration: 5000,
    },
    {
        id: 'alien_ambassador', name: 'Alien Ambassador!', icon: '',
        desc: 'An Intergalactic Ambassador wants to try our drinks! Serve well for huge tip!',
        effect(gs) {
            // Next customer to arrive is a super-VIP
            gs._nextIsAmbassador = true;
            addLog(' Ambassador incoming! Make it perfect for 5x tip!', 'tip');
        },
        duration: 4000,
    },
    {
        id: 'happy_hour_boost', name: 'Impromptu Happy Hour!', icon: '',
        desc: 'Word spreads fast! Customer spawn rate tripled for 25 seconds!',
        effect(gs) {
            gs._megaRushUntil = performance.now() + 25000;
            gs.reputation = Math.min(100, gs.reputation + 4);
            addLog(' Happy Hour rush! Brace yourself!', 'tip');
        },
        duration: 3500,
    },
    {
        id: 'dino_memory', name: 'Dinosaur Memory!', icon: '',
        desc: 'Walter remembers THAT DAY with the asteroid... Everyone fascinated! +15 rep.',
        effect(gs) {
            gs.reputation = Math.min(100, gs.reputation + 15);
            gs.customers.forEach(c => {
                c.happiness = Math.min(100, c.happiness + 25);
                c.quip = "Tell us about the dinosaurs again!";
                c.quipTimer = 4500;
            });
            addLog(' Walter\'s asteroid story! Everyone loves it (+15 rep)', 'earn');
        },
        duration: 5000,
    },
    {
        id: 'quantum_fluctuation', name: 'Quantum Fluctuation!', icon: '',
        desc: 'Reality hiccups! Random effect: credits, XP, or reputation boost!',
        effect(gs) {
            const roll = Math.random();
            if (roll < 0.33) {
                gs.credits += 100;
                addLog(' Quantum flux! +100 Cr materialized!', 'earn');
                spawnFloatingNumber(BAR_CENTER.x, BAR_CENTER.y, '+100', 'credits');
            } else if (roll < 0.66) {
                gs.xp += 80;
                addLog(' Quantum flux! +80 XP gained!', 'earn');
                spawnFloatingNumber(BAR_CENTER.x, BAR_CENTER.y, '+80 XP', 'xp');
                checkLevelUp();
            } else {
                gs.reputation = Math.min(100, gs.reputation + 20);
                addLog(' Quantum flux! +20 reputation!', 'earn');
            }
            spawnParticleBurst(BAR_CENTER.x, BAR_CENTER.y, '#9d4edd', 25);
            spawnSparkles(BAR_CENTER.x, BAR_CENTER.y, 12);
        },
        duration: 4000,
    },
    {
        id: 'rush_challenge', name: 'The Rush Challenge!', icon: '',
        desc: 'Can you serve 5 drinks in 60 seconds? Succeed for 150 Cr bonus!',
        effect(gs) {
            gs._rushChallengeStart = performance.now();
            gs._rushChallengeServed = 0;
            gs._rushChallengeActive = true;
            addLog(' RUSH CHALLENGE: Serve 5 drinks in 60s for 150 Cr!', 'tip');
        },
        duration: 4500,
    },
];

let nextEventTimer = 30000 + Math.random() * 30000; // First event 30-60s in

function updateRandomEvents(dt) {
    nextEventTimer -= dt;
    if (nextEventTimer <= 0 && GS.level >= 2) {
        triggerOldRandomEvent();
        nextEventTimer = 60000 + Math.random() * 60000; // 60-120s between story events
    }
}

function triggerOldRandomEvent() {
    // 25% chance to trigger a bar story dialogue instead of a gameplay event
    const storyKeys = Object.keys(DIALOGUE_DATA).filter(k => k.startsWith('story_') && !k.includes('2'));
    if (storyKeys.length > 0 && Math.random() < 0.25) {
        const storyKey = storyKeys[Math.floor(Math.random() * storyKeys.length)];
        showDialogue(storyKey);
        return;
    }
    
    const evt = RANDOM_EVENTS[Math.floor(Math.random() * RANDOM_EVENTS.length)];
    // Use new dramatic banner system
    const color = (evt.id === 'bar_fight' || evt.id === 'power_surge' || evt.id === 'space_pirates' || evt.id === 'asteroid_scare' || evt.id === 'hangover_epidemic') ? '#ff4444' : '#ffd700';
    showEventBanner({ name: `${evt.icon} ${evt.name}`, desc: evt.desc, color });
    playSound('levelup');
    setTimeout(() => { evt.effect(GS); updateHUD(); }, 1500);
}

// ==================== DAILY CHALLENGES ====================
const CHALLENGE_TYPES = [
    { id: 'serve_drinks', name: 'Rush Hour', icon: '', desc: 'Serve {target} drinks today', target: [15, 20, 25], reward: [50, 75, 100] },
    { id: 'earn_credits', name: 'Money Maker', icon: '', desc: 'Earn {target} credits today', target: [300, 500, 800], reward: [60, 90, 120] },
    { id: 'happy_customers', name: 'Happy Hour', icon: '', desc: 'Keep {target} customers at 80+ happiness', target: [10, 15, 20], reward: [50, 75, 100] },
    { id: 'combo_streak', name: 'Combo Master', icon: '', desc: 'Get a {target}x combo', target: [5, 7, 10], reward: [80, 120, 150] },
    { id: 'fast_serve', name: 'Speed Demon', icon: '', desc: 'Serve {target} drinks in under 3 minutes', target: [10, 15, 20], reward: [70, 100, 130] },
    { id: 'vip_serve', name: 'VIP Treatment', icon: '', desc: 'Serve {target} VIP customers', target: [3, 5, 7], reward: [100, 150, 200] },
    { id: 'reputation', name: 'Popular Place', icon: '', desc: 'Maintain {target}+ reputation for 5 minutes', target: [60, 75, 90], reward: [60, 90, 120] },
    { id: 'perfect_serve', name: 'Perfectionist', icon: '', desc: 'Serve {target} customers with 100% happiness', target: [5, 8, 12], reward: [80, 110, 140] },
];

let dailyChallenges = [];
let dailyProgress = {};
let dailyDate = '';
let dailyBonusClaimed = false;

function generateDailyChallenges() {
    const today = new Date().toDateString();
    
    // Check if we need new challenges
    if (dailyDate === today && dailyChallenges.length === 3) return;
    
    // Generate seed from date for consistent daily challenges
    const seed = today.split(' ').join('').charCodeAt(0) + new Date().getDate();
    const seededRandom = () => {
        let x = Math.sin(seed++) * 10000;
        return x - Math.floor(x);
    };
    
    // Pick 3 random challenge types
    const types = [...CHALLENGE_TYPES];
    const selected = [];
    for (let i = 0; i < 3 && types.length > 0; i++) {
        const idx = Math.floor(seededRandom() * types.length);
        const type = types.splice(idx, 1)[0];
        const difficulty = Math.floor(seededRandom() * 3); // 0=easy, 1=medium, 2=hard
        selected.push({
            ...type,
            target: type.target[difficulty],
            reward: type.reward[difficulty],
            difficulty: ['Easy', 'Medium', 'Hard'][difficulty]
        });
    }
    
    dailyChallenges = selected;
    dailyDate = today;
    dailyProgress = {
        serve_drinks: 0,
        earn_credits: 0,
        happy_customers: 0,
        combo_streak: 0,
        fast_serve: 0,
        vip_serve: 0,
        reputation: 0,
        reputation_timer: 0,
        perfect_serve: 0,
    };
    dailyBonusClaimed = false;
    save();
    buildDailyChallenges();
}

function checkDailyChallenges() {
    if (dailyChallenges.length === 0) return;
    
    const challenges = dailyChallenges;
    let allComplete = true;
    
    for (const challenge of challenges) {
        const progress = dailyProgress[challenge.id] || 0;
        const complete = progress >= challenge.target;
        
        if (!complete) {
            allComplete = false;
        } else if (complete && !challenge.rewarded) {
            // Award challenge completion reward
            challenge.rewarded = true;
            GS.credits += challenge.reward;
            GS.xp += challenge.reward / 2;
            addLog(` Challenge complete! +${challenge.reward} Cr`, 'earn');
            playSound('levelup');
            
            // ===== CHALLENGE COMPLETION EFFECTS =====
            spawnSparkles(BAR_CENTER.x, BAR_CENTER.y, 7);
            spawnParticleBurst(BAR_CENTER.x, BAR_CENTER.y, '#9d4edd', 12);
            spawnFloatingNumber(BAR_CENTER.x, BAR_CENTER.y, `+${challenge.reward}`, 'credits');
            
            save();
        }
    }
    
    // Award bonus if all complete
    if (allComplete && !dailyBonusClaimed) {
        dailyBonusClaimed = true;
        const bonusCredits = 200;
        const bonusXP = 100;
        GS.credits += bonusCredits;
        GS.xp += bonusXP;
        
        // Track daily completions for achievements
        GS._dailiesCompleted = (GS._dailiesCompleted || 0) + 1;
        
        // Track perfect day streak
        checkPerfectDayStreak();
        
        showNotification(` All Daily Challenges Complete! +${bonusCredits} Cr, +${bonusXP} XP!`);
        playSound('levelup');
        
        // ===== ALL CHALLENGES COMPLETE EFFECTS =====
        screenShake();
        spawnParticleBurst(BAR_CENTER.x, BAR_CENTER.y, '#9d4edd', 20);
        spawnParticleBurst(BAR_CENTER.x, BAR_CENTER.y, '#ffd700', 18);
        spawnSparkles(BAR_CENTER.x, BAR_CENTER.y, 15);
        spawnFloatingNumber(BAR_CENTER.x - 40, BAR_CENTER.y, `+${bonusCredits}`, 'credits');
        spawnFloatingNumber(BAR_CENTER.x + 40, BAR_CENTER.y, `+${bonusXP} XP`, 'xp');
        setTimeout(() => spawnParticleBurst(BAR_CENTER.x, BAR_CENTER.y, '#00ff88', 15), 200);
        
        checkAchievements(); // Check for daily challenge achievements
        save();
    }
    
    buildDailyChallenges();
}

function updateDailyChallengeProgress(type, value) {
    if (dailyChallenges.length === 0) return;
    
    if (type === 'reputation' && GS.reputation >= value) {
        dailyProgress.reputation_timer = (dailyProgress.reputation_timer || 0) + (performance.now() - (dailyProgress.reputation_last_check || performance.now()));
        if (dailyProgress.reputation_timer >= 300000) { // 5 minutes
            dailyProgress.reputation = value;
        }
    } else {
        dailyProgress[type] = Math.max(dailyProgress[type] || 0, value);
    }
    dailyProgress.reputation_last_check = performance.now();
    
    checkDailyChallenges();
}

function buildDailyChallenges() {
    const list = document.getElementById('daily-list');
    if (!list) return;
    
    list.innerHTML = '';
    
    if (dailyChallenges.length === 0) {
        list.innerHTML = '<div class="inv-empty">No challenges today!</div>';
        return;
    }
    
    for (const challenge of dailyChallenges) {
        const progress = dailyProgress[challenge.id] || 0;
        const complete = progress >= challenge.target;
        const percent = Math.min(100, (progress / challenge.target) * 100);
        
        const div = document.createElement('div');
        div.className = 'challenge-item' + (complete ? ' completed' : '');
        
        const desc = challenge.desc.replace('{target}', challenge.target);
        
        div.innerHTML = `
            <div class="challenge-header">
                <div class="challenge-icon">${challenge.icon}</div>
                <div class="challenge-info">
                    <div class="challenge-name">${challenge.name} (${challenge.difficulty})</div>
                    <div class="challenge-desc">${desc}</div>
                    <div class="challenge-reward">Reward: ${challenge.reward} Credits</div>
                </div>
            </div>
            <div class="challenge-progress">
                <div class="progress-bar-outer">
                    <div class="progress-bar-inner" style="width: ${percent}%"></div>
                </div>
                <div class="progress-text">${progress} / ${challenge.target}</div>
                ${complete ? '<div class="challenge-complete-badge"> COMPLETE!</div>' : ''}
            </div>
        `;
        
        list.appendChild(div);
    }
}

// ==================== LEADERBOARD ====================
function saveToLeaderboard() {
    try {
        const lb = JSON.parse(localStorage.getItem('ob_leaderboard') || '[]');
        // Add/update current run
        const entry = {
            name: 'You',
            score: GS.totalEarned,
            level: GS.level,
            served: GS.totalServed,
            date: new Date().toLocaleDateString(),
        };
        // Keep best score per name, plus current
        const existing = lb.findIndex(e => e.name === 'You');
        if (existing >= 0) {
            if (entry.score > lb[existing].score) lb[existing] = entry;
        } else {
            lb.push(entry);
        }
        // Add some fun AI bar names if empty
        if (lb.length < 3) {
            const bots = [
                { name: 'Zyx-9 Bar', score: 800, level: 4, served: 30, date: '' },
                { name: 'Nebula Lounge', score: 1500, level: 6, served: 55, date: '' },
                { name: 'Black Hole Pub', score: 3200, level: 9, served: 110, date: '' },
                { name: 'Comet Cantina', score: 450, level: 3, served: 18, date: '' },
                { name: "Quasar's Den", score: 5500, level: 12, served: 180, date: '' },
            ];
            for (const b of bots) {
                if (!lb.find(e => e.name === b.name)) lb.push(b);
            }
        }
        lb.sort((a, b) => b.score - a.score);
        localStorage.setItem('ob_leaderboard', JSON.stringify(lb.slice(0, 20)));
    } catch(e) {}
}

function buildLeaderboard() {
    saveToLeaderboard();
    const lb = JSON.parse(localStorage.getItem('ob_leaderboard') || '[]');
    const list = document.getElementById('lb-list');
    list.innerHTML = '';
    const medals = ['', '', ''];
    lb.forEach((entry, i) => {
        const div = document.createElement('div');
        div.className = 'lb-entry' + (entry.name === 'You' ? ' current' : '');
        div.innerHTML = `
            <div class="lb-rank">${medals[i] || '#' + (i+1)}</div>
            <div class="lb-info">
                <div class="lb-name">${entry.name}</div>
                <div class="lb-score"> ${entry.score} Cr | Lv ${entry.level} | ${entry.served} served</div>
            </div>
        `;
        list.appendChild(div);
    });
}

// ==================== STORY QUESTS ====================
const STORY_QUESTS = [
    {
        id: 'q1_welcome',
        title: 'Welcome to Orion\'s Barrel!',
        giver: 'Walter (Hungover Boss)',
        icon: '',
        story: 'Walter groans from behind the bar. "Ugh... my head. Listen, I need help running this place. Serve a few drinks and maybe I\'ll remember your name."',
        objective: 'Serve 5 drinks to any customers',
        checkProgress: (gs) => gs.totalServed >= 5,
        rewards: { credits: 100, xp: 50 },
        unlocks: ['q2_reputation']
    },
    {
        id: 'q2_reputation',
        title: 'Building a Rep',
        giver: 'Mary (Station Manager)',
        icon: '',
        story: 'Mary stops by. "Word spreads fast in space. Get your reputation up and the good customers will come. Also, maybe clean up a bit?"',
        objective: 'Reach 50 reputation',
        checkProgress: (gs) => gs.reputation >= 50,
        rewards: { credits: 150, xp: 75 },
        unlocks: ['q3_vip']
    },
    {
        id: 'q3_vip',
        title: 'VIP Treatment',
        giver: 'Carl (Regular Customer)',
        icon: '',
        story: 'Carl leans in conspiratorially. "Hey, I know some important folks. Serve them well and they\'ll make it worth your while. VIPs have GOLD names!"',
        objective: 'Serve 3 VIP customers',
        checkProgress: (gs) => (gs._vipServed || 0) >= 3,
        rewards: { credits: 250, xp: 100, unlock: 'rocket_fuel' },
        unlocks: ['q4_furniture']
    },
    {
        id: 'q4_furniture',
        title: 'More Seats, More Money',
        giver: 'Walter',
        icon: '',
        story: 'Walter waves you over. "We need more tables. Buy some furniture from the shop and place it around. More seats = more customers = more tips!"',
        objective: 'Place 2 furniture items in the bar',
        checkProgress: (gs) => gs.placedFurniture.length >= 2,
        rewards: { credits: 200, xp: 80 },
        unlocks: ['q5_upgrade']
    },
    {
        id: 'q5_upgrade',
        title: 'Work Smarter',
        giver: 'Scally (Tech Specialist)',
        icon: '',
        story: 'Scally taps on a datapad. "You\'re working too hard. Buy an upgrade from the shop. Auto-greet is a game-changer."',
        objective: 'Purchase any upgrade',
        checkProgress: (gs) => gs.upgrades.length >= 1,
        rewards: { credits: 300, xp: 120 },
        unlocks: ['q6_combo']
    },
    {
        id: 'q6_combo',
        title: 'Speed is Key',
        giver: 'Dick (Competitive Bartender)',
        icon: '',
        story: 'Dick smirks. "Think you\'re fast? Prove it. Get a 5x combo by serving drinks quickly in a row. Don\'t mess up!"',
        objective: 'Achieve a 5x combo streak',
        checkProgress: () => comboCount >= 5,
        rewards: { credits: 350, xp: 150 },
        unlocks: ['q7_level']
    },
    {
        id: 'q7_level',
        title: 'Rising Through the Ranks',
        giver: 'Mary',
        icon: '',
        story: 'Mary nods approvingly. "You\'re making real progress. Reach level 5 and I\'ll put in a good word with the Station Board."',
        objective: 'Reach level 5',
        checkProgress: (gs) => gs.level >= 5,
        rewards: { credits: 400, xp: 200 },
        unlocks: ['q8_wealth']
    },
    {
        id: 'q8_wealth',
        title: 'The Galactic Grind',
        giver: 'Toni (Investor)',
        icon: '',
        story: 'Toni eyes the bar. "You want to make it big? Prove you can earn. Show me 2000 total credits earned and we\'ll talk expansion."',
        objective: 'Earn 2000 total credits',
        checkProgress: (gs) => gs.totalEarned >= 2000,
        rewards: { credits: 500, xp: 250 },
        unlocks: ['q9_night']
    },
    {
        id: 'q9_night',
        title: 'Creatures of the Night',
        giver: 'Walter',
        icon: '',
        story: 'Walter yawns. "The late-night crowd is... different. Strange aliens, weird requests. Serve someone during the Night Shift and see what I mean."',
        objective: 'Serve 1 customer during Late Night phase',
        checkProgress: (gs) => (gs._nightOwlServed || 0) >= 1,
        rewards: { credits: 300, xp: 150 },
        unlocks: ['q10_master']
    },
    {
        id: 'q10_master',
        title: 'Legend of the Barrel',
        giver: 'All the Crew',
        icon: '',
        story: 'Everyone gathers around. "You\'ve really turned this place around! Serve 100 total drinks and you\'ll be a true legend of Orion\'s Barrel!"',
        objective: 'Serve 100 total drinks',
        checkProgress: (gs) => gs.totalServed >= 100,
        rewards: { credits: 1000, xp: 500 },
        unlocks: ['q11_decor']
    },
    // === CHAPTER 2: EXPANSION ===
    {
        id: 'q11_decor',
        title: 'Interior Design',
        giver: 'Scally (Design Enthusiast)',
        icon: '',
        story: 'Scally extends all their tentacles dramatically. "This place needs STYLE! Buy some decorations. I recommend the neon sign - very retro-futuristic."',
        objective: 'Buy and place 3 decorations',
        checkProgress: (gs) => gs.decorations.length >= 3,
        rewards: { credits: 800, xp: 400 },
        unlocks: ['q12_combo_master']
    },
    {
        id: 'q12_combo_master',
        title: 'Combo Royale',
        giver: 'Dick (Still Competitive)',
        icon: '',
        story: 'Dick slams his glass down. "That 5x combo was nothing! Real bartenders hit 10x. I bet you can\'t do it. Prove me wrong."',
        objective: 'Achieve a 10x combo streak',
        checkProgress: (gs) => (gs._maxCombo || 0) >= 10,
        rewards: { credits: 1200, xp: 600 },
        unlocks: ['q13_favorites']
    },
    {
        id: 'q13_favorites',
        title: 'Know Your Regulars',
        giver: 'Mary (Head Bartender)',
        icon: '',
        story: 'Mary pulls you aside. "A good bartender remembers what their regulars like. Each alien has favorite drinks. Serve them right for bonus tips!"',
        objective: 'Serve 5 characters their favorite drinks',
        checkProgress: (gs) => (gs._favoritesServed || []).length >= 5,
        rewards: { credits: 1500, xp: 750 },
        unlocks: ['q14_prestige']
    },
    {
        id: 'q14_prestige',
        title: 'The Prestige Path',
        giver: 'Walter (Sobering Up)',
        icon: '',
        story: 'Walter looks surprisingly sober. "Kid, you\'ve got talent. Ever thought about going prestige? Reset your progress for permanent bonuses. Reach level 10 first though."',
        objective: 'Reach level 10',
        checkProgress: (gs) => gs.level >= 10,
        rewards: { credits: 2000, xp: 1000 },
        unlocks: ['q15_galactic']
    },
    {
        id: 'q15_galactic',
        title: 'Galactic Fame',
        giver: 'Toni (Alien Ambassador)',
        icon: '',
        story: 'Toni\'s antennae glow with excitement. "You\'re famous across three star systems! Earn 10,000 total credits and the Galactic Council will recognize Orion\'s Barrel officially!"',
        objective: 'Earn 10,000 total credits',
        checkProgress: (gs) => gs.totalEarned >= 10000,
        rewards: { credits: 5000, xp: 2500, rep: 50 },
        unlocks: []
    }
];

let completedQuests = [];
let activeQuests = [];

function initQuests() {
    // Start with first quest active
    if (activeQuests.length === 0 && completedQuests.length === 0) {
        activeQuests.push('q1_welcome');
    }
}

function checkQuests() {
    let updated = false;
    
    // Check active quests for completion
    for (const questId of [...activeQuests]) {
        const quest = STORY_QUESTS.find(q => q.id === questId);
        if (!quest) continue;
        
        if (quest.checkProgress(GS)) {
            // Quest complete!
            completeQuest(questId);
            updated = true;
        }
    }
    
    if (updated) {
        buildQuests();
        save();
    }
}

function completeQuest(questId) {
    const quest = STORY_QUESTS.find(q => q.id === questId);
    if (!quest) return;
    
    // Remove from active
    activeQuests = activeQuests.filter(q => q !== questId);
    
    // Add to completed
    if (!completedQuests.includes(questId)) {
        completedQuests.push(questId);
    }
    
    // Award rewards
    if (quest.rewards.credits) {
        GS.credits += quest.rewards.credits;
        addLog(` Quest reward: +${quest.rewards.credits} credits`, 'earn');
    }
    if (quest.rewards.xp) {
        GS.xp += quest.rewards.xp;
        addLog(` Quest reward: +${quest.rewards.xp} XP`, 'earn');
        checkLevelUp();
    }
    if (quest.rewards.unlock) {
        const drink = DRINKS[quest.rewards.unlock];
        if (drink && !GS.unlockedDrinks.includes(quest.rewards.unlock)) {
            GS.unlockedDrinks.push(quest.rewards.unlock);
            addLog(` Unlocked: ${drink.name}!`, 'tip');
        }
    }
    
    showNotification(` Quest Complete: ${quest.title}!`);
    playSound('levelup');
    
    // ===== QUEST COMPLETION VISUAL EFFECTS =====
    screenShake();
    spawnFloatingEmojis(BAR_CENTER.x, BAR_CENTER.y, ['', '', '']);
    spawnParticleBurst(BAR_CENTER.x, BAR_CENTER.y, '#ffd700', 18);
    spawnSparkles(BAR_CENTER.x, BAR_CENTER.y, 10);
    if (quest.rewards.credits) {
        spawnFloatingNumber(BAR_CENTER.x - 30, BAR_CENTER.y, `+${quest.rewards.credits}`, 'credits');
    }
    if (quest.rewards.xp) {
        spawnFloatingNumber(BAR_CENTER.x + 30, BAR_CENTER.y, `+${quest.rewards.xp} XP`, 'xp');
    }
    
    // Unlock next quests
    if (quest.unlocks && quest.unlocks.length > 0) {
        for (const nextId of quest.unlocks) {
            if (!activeQuests.includes(nextId) && !completedQuests.includes(nextId)) {
                activeQuests.push(nextId);
                const nextQuest = STORY_QUESTS.find(q => q.id === nextId);
                if (nextQuest) {
                    showNotification(` New Quest: ${nextQuest.title}`);
                    // Trigger quest start dialogue if exists
                    const diagId = nextId.replace('_', '') + '_start'; // q2_reputation -> q2reputation_start OR match manually
                    // Actually, let's just map IDs manually or check simple pattern
                    // Try q2_start for q2_reputation
                    const simpleId = nextId.split('_')[0] + '_start'; 
                    if (DIALOGUE_DATA[simpleId]) {
                        setTimeout(() => showDialogue(simpleId), 1500);
                    }
                }
            }
        }
    }
    
    updateHUD();
    checkAchievements(); // Check for quest achievements
}

function buildQuests() {
    const list = document.getElementById('quest-list');
    if (!list) return;
    
    list.innerHTML = '';
    
    if (STORY_QUESTS.length === 0) {
        list.innerHTML = '<div class="inv-empty">No quests available!</div>';
        return;
    }
    
    // Show quests in order: active first, then locked, then completed at bottom
    const active = STORY_QUESTS.filter(q => activeQuests.includes(q.id));
    const locked = STORY_QUESTS.filter(q => !activeQuests.includes(q.id) && !completedQuests.includes(q.id));
    const completed = STORY_QUESTS.filter(q => completedQuests.includes(q.id));
    
    const all = [...active, ...locked, ...completed];
    
    for (const quest of all) {
        const isActive = activeQuests.includes(quest.id);
        const isCompleted = completedQuests.includes(quest.id);
        const isLocked = !isActive && !isCompleted;
        
        let status = '';
        let statusClass = '';
        if (isCompleted) {
            status = ' COMPLETED';
            statusClass = 'completed';
        } else if (isActive) {
            status = ' ACTIVE';
            statusClass = 'active';
        } else {
            status = ' LOCKED';
            statusClass = 'locked';
        }
        
        const div = document.createElement('div');
        div.className = 'quest-item ' + statusClass;
        
        // Build rewards text
        let rewardsHTML = '';
        if (quest.rewards.credits) {
            rewardsHTML += `<div class="quest-reward-item"> ${quest.rewards.credits} Credits</div>`;
        }
        if (quest.rewards.xp) {
            rewardsHTML += `<div class="quest-reward-item"> ${quest.rewards.xp} XP</div>`;
        }
        if (quest.rewards.unlock) {
            const drink = DRINKS[quest.rewards.unlock];
            if (drink) {
                rewardsHTML += `<div class="quest-reward-item"> Unlock ${drink.name}</div>`;
            }
        }
        
        div.innerHTML = `
            <div class="quest-header">
                <div class="quest-icon">${quest.icon}</div>
                <div class="quest-info">
                    <div class="quest-title">${quest.title}</div>
                    <div class="quest-giver"> ${quest.giver}</div>
                </div>
            </div>
            <div class="quest-story">"${quest.story}"</div>
            <div class="quest-objective">
                <div class="quest-objective-text"> ${quest.objective}</div>
            </div>
            <div class="quest-rewards">${rewardsHTML}</div>
            <div class="quest-status ${statusClass}">${status}</div>
        `;
        
        list.appendChild(div);
    }
}

// ==================== ACHIEVEMENTS ====================
function checkAchievements() {
    for (const [id, ach] of Object.entries(ACHIEVEMENTS)) {
        if (!unlockedAchievements.includes(id) && ach.check()) {
            unlockAchievement(id);
        }
    }
}

function unlockAchievement(id) {
    const ach = ACHIEVEMENTS[id];
    if (!ach || unlockedAchievements.includes(id)) return;
    
    unlockedAchievements.push(id);
    
    // Grant rewards
    let rewardText = '';
    if (ach.reward.cr) {
        GS.credits += ach.reward.cr;
        rewardText += `+${ach.reward.cr} `;
    }
    if (ach.reward.xp) {
        GS.xp += ach.reward.xp;
        rewardText += `+${ach.reward.xp}XP `;
        checkLevelUp();
    }
    if (ach.reward.rep) {
        GS.reputation += ach.reward.rep;
        rewardText += `+${ach.reward.rep} `;
    }
    
    // Show toast notification
    const toast = document.getElementById('ach-toast');
    const toastIcon = document.getElementById('toast-icon');
    const toastText = document.getElementById('toast-text');
    
    toastIcon.textContent = ach.icon;
    toastText.innerHTML = `<strong>${ach.name}</strong><br><small>${rewardText.trim()}</small>`;
    
    toast.classList.add('show');
    setTimeout(() => toast.classList.remove('show'), 4000);
    
    // Sound & visual effects
    playSound('levelup');
    spawnParticleBurst(BAR_CENTER.x, BAR_CENTER.y, '#ffd700', 18);
    spawnSparkles(BAR_CENTER.x, BAR_CENTER.y, 10);
    
    if (ach.reward.cr) spawnFloatingNumber(BAR_CENTER.x - 30, BAR_CENTER.y, `+${ach.reward.cr}`, 'credits');
    if (ach.reward.xp) spawnFloatingNumber(BAR_CENTER.x + 30, BAR_CENTER.y, `+${ach.reward.xp}XP`, 'xp');
    
    addLog(` ${ach.name}! ${rewardText}`, 'tip');
    updateHUD();
    
    // Update achievements UI if open
    const panel = document.getElementById('achievements-panel');
    if (panel && panel.classList.contains('open')) {
        buildAchievements();
    }
}

function buildAchievements() {
    const list = document.getElementById('ach-list');
    list.innerHTML = '';
    
    const locked = [];
    const unlocked = [];
    
    Object.entries(ACHIEVEMENTS).forEach(([id, ach]) => {
        const isUnlocked = unlockedAchievements.includes(id);
        (isUnlocked ? unlocked : locked).push({ id, ach, isUnlocked });
    });
    
    // Show unlocked first, then locked
    [...unlocked, ...locked].forEach(({ id, ach, isUnlocked }) => {
        const div = document.createElement('div');
        div.className = 'ach-item' + (isUnlocked ? ' unlocked' : '');
        
        let rewardHTML = '';
        if (ach.reward.cr) rewardHTML += `<span class="ach-reward"> ${ach.reward.cr}</span>`;
        if (ach.reward.xp) rewardHTML += `<span class="ach-reward"> ${ach.reward.xp}XP</span>`;
        if (ach.reward.rep) rewardHTML += `<span class="ach-reward"> +${ach.reward.rep}</span>`;
        
        div.innerHTML = `
            <div class="ach-icon">${isUnlocked ? ach.icon : ''}</div>
            <div class="ach-info">
                <div class="ach-name">${ach.name}</div>
                <div class="ach-desc">${ach.desc}</div>
                <div class="ach-rewards">${rewardHTML}</div>
            </div>
            ${isUnlocked ? '<div class="ach-check"></div>' : ''}
        `;
        
        list.appendChild(div);
    });
    
    // Show count at top
    const count = unlockedAchievements.length;
    const total = Object.keys(ACHIEVEMENTS).length;
    const h3 = document.querySelector('#achievements-panel h3');
    h3.textContent = ` ACHIEVEMENTS (${count}/${total})`;
}

// ==================== STREAK SYSTEM ====================
const STREAK_MILESTONES = [
    { day: 3, reward: { cr: 100, xp: 50 } },
    { day: 7, reward: { cr: 300, xp: 150 } },
    { day: 14, reward: { cr: 750, xp: 400 } },
    { day: 30, reward: { cr: 2000, xp: 1000, rep: 25 } },
    { day: 60, reward: { cr: 5000, xp: 2500, rep: 50 } },
    { day: 100, reward: { cr: 10000, xp: 5000, rep: 100 } },
];

function checkLoginStreak() {
    const today = new Date().toDateString();
    const lastLogin = GS._lastLogin;
    
    if (!lastLogin) {
        // First time playing
        GS._loginStreak = 1;
        GS._totalLogins = 1;
        GS._lastLogin = today;
        GS._longestLoginStreak = 1;
        showNotification(' Login Streak Started! Come back tomorrow to keep it going!');
        save();
        return;
    }
    
    if (lastLogin === today) {
        // Already logged in today
        return;
    }
    
    const yesterday = new Date(Date.now() - 86400000).toDateString();
    
    if (lastLogin === yesterday) {
        // Continued streak!
        GS._loginStreak++;
        GS._totalLogins++;
        GS._lastLogin = today;
        
        if (GS._loginStreak > GS._longestLoginStreak) {
            GS._longestLoginStreak = GS._loginStreak;
        }
        
        showNotification(` ${GS._loginStreak} Day Streak! Keep it up!`);
        
        // Check for milestone rewards
        checkStreakMilestone();
        
        save();
    } else {
        // Streak broken (missed more than 1 day)
        const oldStreak = GS._loginStreak;
        GS._loginStreak = 1;
        GS._totalLogins++;
        GS._lastLogin = today;
        
        if (oldStreak > 1) {
            showNotification(` Streak reset! You had ${oldStreak} days. Starting fresh!`);
            addLog(`Streak broken! Was ${oldStreak} days`, 'bad');
        }
        save();
    }
    
    updateHUD();
}

function checkStreakMilestone() {
    const streak = GS._loginStreak;
    
    for (const milestone of STREAK_MILESTONES) {
        if (streak === milestone.day) {
            // Check if already claimed
            if (!GS._streakRewardsClaimed) GS._streakRewardsClaimed = [];
            
            const rewardKey = `login_${milestone.day}`;
            if (GS._streakRewardsClaimed.includes(rewardKey)) continue;
            
            // Grant reward!
            GS._streakRewardsClaimed.push(rewardKey);
            
            let rewardText = '';
            if (milestone.reward.cr) {
                GS.credits += milestone.reward.cr;
                rewardText += `+${milestone.reward.cr} `;
                spawnFloatingNumber(BAR_CENTER.x - 30, BAR_CENTER.y, `+${milestone.reward.cr}`, 'credits');
            }
            if (milestone.reward.xp) {
                GS.xp += milestone.reward.xp;
                rewardText += `+${milestone.reward.xp}XP `;
                checkLevelUp();
                spawnFloatingNumber(BAR_CENTER.x + 30, BAR_CENTER.y, `+${milestone.reward.xp}XP`, 'xp');
            }
            if (milestone.reward.rep) {
                GS.reputation += milestone.reward.rep;
                rewardText += `+${milestone.reward.rep} `;
            }
            
            // Epic celebration!
            playSound('levelup');
            screenShake();
            spawnParticleBurst(BAR_CENTER.x, BAR_CENTER.y, '#ff00ff', 30);
            spawnSparkles(BAR_CENTER.x, BAR_CENTER.y, 15);
            
            showNotification(` ${streak} DAY STREAK MILESTONE! ${rewardText}`);
            addLog(` ${streak}-day streak reward: ${rewardText}`, 'tip');
            
            updateHUD();
            save();
        }
    }
}

function checkPerfectDayStreak() {
    // Called when all daily challenges complete
    GS._perfectDayStreak++;
    showNotification(` Perfect Day #${GS._perfectDayStreak}! All challenges complete!`);
    save();
}

function buildStreaks() {
    const list = document.getElementById('streak-list');
    list.innerHTML = '';
    
    const streak = GS._loginStreak || 0;
    const perfectDays = GS._perfectDayStreak || 0;
    const longest = GS._longestLoginStreak || 0;
    const totalLogins = GS._totalLogins || 0;
    
    // Active login streak card
    const loginCard = document.createElement('div');
    loginCard.className = 'streak-card';
    
    const nextMilestone = STREAK_MILESTONES.find(m => m.day > streak);
    const daysToNext = nextMilestone ? nextMilestone.day - streak : 0;
    
    loginCard.innerHTML = `
        <div class="streak-card-header">
            <div class="streak-card-icon"></div>
            <div class="streak-card-count">${streak}</div>
        </div>
        <div class="streak-card-title">Daily Login Streak</div>
        <div class="streak-card-desc">
            Come back every day to keep your streak alive!
            ${nextMilestone ? `<br><strong>${daysToNext} days</strong> until next milestone!` : '<br>You\'ve reached the max!'}
        </div>
        <div class="streak-card-progress">
            Total logins: ${totalLogins} | Best streak: ${longest} days
        </div>
    `;
    list.appendChild(loginCard);
    
    // Perfect day streak
    const perfectCard = document.createElement('div');
    perfectCard.className = 'streak-card';
    perfectCard.innerHTML = `
        <div class="streak-card-header">
            <div class="streak-card-icon"></div>
            <div class="streak-card-count">${perfectDays}</div>
        </div>
        <div class="streak-card-title">Perfect Days</div>
        <div class="streak-card-desc">
            Days where you completed ALL daily challenges.
            Quality over quantity!
        </div>
    `;
    list.appendChild(perfectCard);
    
    // Milestones section
    const milestonesTitle = document.createElement('div');
    milestonesTitle.style.cssText = 'color: #ffd700; font-weight: bold; font-size: 14px; margin: 15px 0 10px 0; text-align: center;';
    milestonesTitle.textContent = ' STREAK MILESTONES';
    list.appendChild(milestonesTitle);
    
    // Show all milestones
    for (const m of STREAK_MILESTONES) {
        const achieved = streak >= m.day;
        const claimed = GS._streakRewardsClaimed && GS._streakRewardsClaimed.includes(`login_${m.day}`);
        
        const mDiv = document.createElement('div');
        mDiv.className = 'streak-milestone' + (achieved ? ' achieved' : '');
        
        let rewardText = '';
        if (m.reward.cr) rewardText += `${m.reward.cr} `;
        if (m.reward.xp) rewardText += `${m.reward.xp}XP `;
        if (m.reward.rep) rewardText += `${m.reward.rep}`;
        
        mDiv.innerHTML = `
            <div class="sm-day">${achieved ? '' : ''} Day ${m.day}</div>
            <div class="sm-reward">${rewardText}</div>
        `;
        list.appendChild(mDiv);
    }
    
    // Show active streak reward if there's one pending
    const pendingMilestone = STREAK_MILESTONES.find(m => 
        m.day === streak && (!GS._streakRewardsClaimed || !GS._streakRewardsClaimed.includes(`login_${m.day}`))
    );
    
    if (pendingMilestone) {
        const banner = document.createElement('div');
        banner.className = 'streak-reward-banner';
        
        let rewardText = '';
        if (pendingMilestone.reward.cr) rewardText += `${pendingMilestone.reward.cr} `;
        if (pendingMilestone.reward.xp) rewardText += `${pendingMilestone.reward.xp}XP `;
        if (pendingMilestone.reward.rep) rewardText += `${pendingMilestone.reward.rep}`;
        
        banner.innerHTML = `
            <div class="srb-title"> MILESTONE REACHED!</div>
            <div class="srb-amount">${rewardText}</div>
        `;
        list.insertBefore(banner, list.firstChild);
    }
}

// ==================== RELATIONSHIP SYSTEM ====================
const RELATIONSHIP_LEVELS = [
    { name: 'Stranger',    icon: '', serves: 0,   reward: null },
    { name: 'Acquaintance', icon: '', serves: 5,   reward: { cr: 50, desc: '+50 credits' } },
    { name: 'Regular',     icon: '', serves: 15,  reward: { cr: 150, xp: 50, desc: '+150 credits, +50 XP' } },
    { name: 'Friend',      icon: '', serves: 30,  reward: { cr: 300, xp: 100, desc: '+300 credits, +100 XP' } },
    { name: 'Best Friend', icon: '', serves: 60,  reward: { cr: 500, xp: 200, rep: 5, desc: '+500 credits, +200 XP, +5 rep' } },
    { name: 'Soulmate',    icon: '', serves: 100, reward: { cr: 1000, xp: 500, rep: 10, desc: '+1000 credits, +500 XP, +10 rep' } },
];

const RELATIONSHIP_PERKS = {
    // At "Friend" level, each character gives a unique passive bonus
    walter: { level: 3, desc: ' Walter tells stories: +5% XP from all serves', type: 'xp', value: 1.05 },
    carl:   { level: 3, desc: ' Carl brings friends: +10% customer spawn rate', type: 'spawn', value: 1.1 },
    dick:   { level: 3, desc: ' Dick scares critics: -50% rep loss from angry customers', type: 'repLoss', value: 0.5 },
    scally:  { level: 3, desc: ' Scally imports goods: -10% shop prices', type: 'shopDiscount', value: 0.9 },
    toni:   { level: 3, desc: ' Toni broadcasts: +15% reputation gain', type: 'repGain', value: 1.15 },
    glorp:  { level: 3, desc: ' Glorp attracts VIPs: +20% VIP chance', type: 'vip', value: 1.2 },
    zix:    { level: 3, desc: ' Zix optimizes: -10% drink prep time', type: 'prepSpeed', value: 1.1 },
    blorb:  { level: 3, desc: ' Blorb vibes: +10 starting happiness for all', type: 'happiness', value: 10 },
    krax:   { level: 3, desc: ' Krax intimidates: +15% tips from all customers', type: 'tips', value: 1.15 },
    pip:    { level: 3, desc: ' Pip hypes: +20% combo duration', type: 'comboDuration', value: 1.2 },
};

function getCharServes(charKey) {
    return (GS._charServes || {})[charKey] || 0;
}

function trackCharServe(charKey) {
    if (!GS._charServes) GS._charServes = {};
    GS._charServes[charKey] = (GS._charServes[charKey] || 0) + 1;
    
    // Check for relationship level ups
    const serves = GS._charServes[charKey];
    if (!GS._charRelClaimed) GS._charRelClaimed = {};
    
    for (let i = 1; i < RELATIONSHIP_LEVELS.length; i++) {
        const rl = RELATIONSHIP_LEVELS[i];
        const claimKey = `${charKey}_${i}`;
        if (serves >= rl.serves && !GS._charRelClaimed[claimKey]) {
            GS._charRelClaimed[claimKey] = true;
            const charData = CHAR_DATA[charKey];
            // Grant rewards
            if (rl.reward) {
                if (rl.reward.cr) GS.credits += rl.reward.cr;
                if (rl.reward.xp) GS.xp += rl.reward.xp;
                if (rl.reward.rep) GS.reputation = Math.min(100, GS.reputation + rl.reward.rep);
            }
            showNotification(`${rl.icon} ${charData.name} is now your ${rl.name}! ${rl.reward ? rl.reward.desc : ''}`);
            playSound('levelup');
            updateHUD();
            
            // Check if relationship perk unlocked
            const perk = RELATIONSHIP_PERKS[charKey];
            if (perk && i === perk.level) {
                setTimeout(() => showNotification(` PERK UNLOCKED: ${perk.desc}`), 2000);
            }
        }
    }
}

function getRelationshipLevel(charKey) {
    const serves = getCharServes(charKey);
    let level = 0;
    for (let i = RELATIONSHIP_LEVELS.length - 1; i >= 0; i--) {
        if (serves >= RELATIONSHIP_LEVELS[i].serves) { level = i; break; }
    }
    return level;
}

function getRelationshipBonuses() {
    const b = { xp: 1, spawn: 1, repLoss: 1, shopDiscount: 1, repGain: 1, vip: 1, prepSpeed: 1, happiness: 0, tips: 1, comboDuration: 1 };
    for (const [charKey, perk] of Object.entries(RELATIONSHIP_PERKS)) {
        if (getRelationshipLevel(charKey) >= perk.level) {
            if (perk.type === 'happiness') b[perk.type] += perk.value;
            else b[perk.type] *= perk.value;
        }
    }
    return b;
}

function buildCharacterGuide() {
    const list = document.getElementById('char-list');
    list.innerHTML = '';
    
    const customerChars = ['walter', 'carl', 'dick', 'scally', 'toni', 'glorp', 'zix', 'blorb', 'krax', 'pip'];
    
    for (const charKey of customerChars) {
        const charData = CHAR_DATA[charKey];
        if (!charData) continue;
        
        const serves = getCharServes(charKey);
        const relLevel = getRelationshipLevel(charKey);
        const rl = RELATIONSHIP_LEVELS[relLevel];
        const nextRl = RELATIONSHIP_LEVELS[relLevel + 1];
        const progress = nextRl ? Math.min(1, (serves - rl.serves) / (nextRl.serves - rl.serves)) : 1;
        const perk = RELATIONSHIP_PERKS[charKey];
        const perkUnlocked = perk && relLevel >= perk.level;
        
        // Favorites
        let favsHTML = '';
        if (charData.favorites) {
            for (const drinkKey of charData.favorites) {
                const drink = DRINKS[drinkKey];
                if (drink) {
                    const discovered = GS._favoritesServed && GS._favoritesServed.includes(`${charKey}_${drinkKey}`);
                    favsHTML += `<span style="margin-right:4px">${discovered ? drink.icon : ''}</span>`;
                }
            }
        }
        
        const card = document.createElement('div');
        card.className = 'char-card';
        card.innerHTML = `
            <div class="char-card-header">
                <div class="char-card-emoji">${charData.emoji}</div>
                <div>
                    <div class="char-card-name">${charData.name}</div>
                    <div style="font-size:11px;color:${relLevel >= 4 ? '#ff66cc' : relLevel >= 3 ? '#ffd700' : '#aaa'}">${rl.icon} ${rl.name} (${serves} serves)</div>
                </div>
            </div>
            <div style="margin:6px 0">
                <div style="display:flex;justify-content:space-between;font-size:10px;color:#888">
                    <span>${rl.icon} ${rl.name}</span>
                    <span>${nextRl ? `${nextRl.icon} ${nextRl.name} (${nextRl.serves})` : ' MAX'}</span>
                </div>
                <div style="height:6px;background:rgba(0,0,0,0.4);border-radius:3px;overflow:hidden;margin-top:2px">
                    <div style="height:100%;width:${progress*100}%;background:linear-gradient(90deg,${charData.color},#ffd700);border-radius:3px;transition:width 0.3s"></div>
                </div>
            </div>
            <div style="font-size:11px;margin:4px 0"> Favorites: ${favsHTML}</div>
            ${perk ? `<div style="font-size:10px;padding:4px 6px;border-radius:6px;margin-top:4px;
                background:${perkUnlocked ? 'rgba(0,255,136,0.15)' : 'rgba(255,255,255,0.05)'};
                border:1px solid ${perkUnlocked ? '#00ff88' : 'rgba(255,255,255,0.1)'};
                color:${perkUnlocked ? '#00ff88' : '#666'}">
                ${perkUnlocked ? '' : ''} ${perk.desc}
            </div>` : ''}
        `;
        
        list.appendChild(card);
    }
}

// ==================== MINI-GAME SYSTEM ====================
const MINIGAME = {
    active: false,
    sequence: [],
    playerSequence: [],
    score: 0,
    round: 1,
    timer: null,
    timeLeft: 30,
    colors: [
        { id: 'red', emoji: '', class: 'red' },
        { id: 'blue', emoji: '', class: 'blue' },
        { id: 'green', emoji: '', class: 'green' },
        { id: 'yellow', emoji: '', class: 'yellow' }
    ]
};

function openMiniGame() {
    document.getElementById('minigame-overlay').classList.add('show');
    document.getElementById('minigame-select').style.display = 'block';
    document.getElementById('minigame-sequence').style.display = 'none';
    document.getElementById('minigame-catch').style.display = 'none';
    MINIGAME.active = false;
    CATCH_GAME.active = false;
    stopDartsGame();
}

function selectMiniGame(type) {
    document.getElementById('minigame-select').style.display = 'none';
    if (type === 'darts') {
        document.getElementById('minigame-darts').style.display = 'block';
        document.getElementById('darts-result').textContent = '';
        document.getElementById('darts-start-btn').textContent = 'THROW!';
        document.getElementById('darts-start-btn').onclick = startDartsGame;
        return;
    }
    if (type === 'sequence') {
        document.getElementById('minigame-sequence').style.display = 'block';
        MINIGAME.active = false;
        MINIGAME.score = 0;
        MINIGAME.round = 1;
        MINIGAME.timeLeft = 30;
        document.getElementById('minigame-timer').textContent = 'Ready...';
        document.getElementById('minigame-score').textContent = 'Score: 0';
        document.getElementById('sequence-display').innerHTML = '';
        document.getElementById('minigame-start').style.display = 'inline-block';
        document.getElementById('minigame-start').textContent = 'START CHALLENGE';
    } else if (type === 'catch') {
        document.getElementById('minigame-catch').style.display = 'block';
        initCatchGame();
    }
}

function backToArcade() {
    // Stop any running games
    if (MINIGAME.timer) { clearInterval(MINIGAME.timer); MINIGAME.timer = null; }
    MINIGAME.active = false;
    stopCatchGame();
    stopDartsGame();
    // Show selection
    document.getElementById('minigame-select').style.display = 'block';
    document.getElementById('minigame-sequence').style.display = 'none';
    document.getElementById('minigame-catch').style.display = 'none';
    document.getElementById('minigame-darts').style.display = 'none';
}

function closeMiniGame() {
    document.getElementById('minigame-overlay').classList.remove('show');
    if (MINIGAME.timer) {
        clearInterval(MINIGAME.timer);
        MINIGAME.timer = null;
    }
    MINIGAME.active = false;
    stopCatchGame();
}

function startMiniGame() {
    MINIGAME.active = true;
    MINIGAME.score = 0;
    MINIGAME.round = 1;
    MINIGAME.timeLeft = 30;
    document.getElementById('minigame-start').style.display = 'none';
    
    // Start timer
    MINIGAME.timer = setInterval(() => {
        MINIGAME.timeLeft--;
        document.getElementById('minigame-timer').textContent = ` ${MINIGAME.timeLeft}s`;
        
        if (MINIGAME.timeLeft <= 0) {
            endMiniGame();
        }
    }, 1000);
    
    nextMiniGameRound();
}

function nextMiniGameRound() {
    // Generate sequence based on round (gets longer)
    const length = Math.min(3 + Math.floor(MINIGAME.round / 2), 8);
    MINIGAME.sequence = [];
    for (let i = 0; i < length; i++) {
        MINIGAME.sequence.push(MINIGAME.colors[Math.floor(Math.random() * 4)]);
    }
    MINIGAME.playerSequence = [];
    
    // Show sequence
    showMiniGameSequence();
}

function showMiniGameSequence() {
    const display = document.getElementById('sequence-display');
    display.innerHTML = '';
    
    // Create buttons for each color
    MINIGAME.colors.forEach(color => {
        const btn = document.createElement('div');
        btn.className = `sequence-btn ${color.class}`;
        btn.textContent = color.emoji;
        btn.onclick = () => handleMiniGameInput(color);
        display.appendChild(btn);
    });
    
    // Briefly show the sequence
    let i = 0;
    const showInterval = setInterval(() => {
        if (i >= MINIGAME.sequence.length) {
            clearInterval(showInterval);
            return;
        }
        
        // Flash the button
        const color = MINIGAME.sequence[i];
        const btns = display.querySelectorAll('.sequence-btn');
        btns.forEach(btn => {
            if (btn.classList.contains(color.class)) {
                btn.classList.add('active');
                playSound('ready');
                setTimeout(() => btn.classList.remove('active'), 300);
            }
        });
        
        i++;
    }, 600);
}

function handleMiniGameInput(color) {
    if (!MINIGAME.active) return;
    
    MINIGAME.playerSequence.push(color);
    playSound('click');
    
    // Check if correct so far
    const idx = MINIGAME.playerSequence.length - 1;
    if (MINIGAME.playerSequence[idx].id !== MINIGAME.sequence[idx].id) {
        // Wrong!
        playSound('angry');
        addLog(' Wrong sequence! Round failed', 'bad');
        MINIGAME.timeLeft = Math.max(0, MINIGAME.timeLeft - 3);
        nextMiniGameRound(); // Try again
        return;
    }
    
    // Check if complete
    if (MINIGAME.playerSequence.length === MINIGAME.sequence.length) {
        // Correct!
        playSound('combo');
        const points = MINIGAME.sequence.length * 10 * MINIGAME.round;
        MINIGAME.score += points;
        MINIGAME.round++;
        document.getElementById('minigame-score').textContent = `Score: ${MINIGAME.score} `;
        
        // Bonus time
        MINIGAME.timeLeft = Math.min(30, MINIGAME.timeLeft + 2);
        
        spawnFloatingNumber(W / 2, H / 2, `+${points}`, 'xp');
        
        setTimeout(() => nextMiniGameRound(), 800);
    }
}

function endMiniGame() {
    clearInterval(MINIGAME.timer);
    MINIGAME.timer = null;
    MINIGAME.active = false;
    
    // Calculate rewards
    const credits = Math.floor(MINIGAME.score * 0.5);
    const xp = Math.floor(MINIGAME.score * 0.3);
    
    GS.credits += credits;
    GS.xp += xp;
    
    playSound('levelup');
    showNotification(` Mini-Game Complete!`, `Score: ${MINIGAME.score}\n+${credits} Cr, +${xp} XP`, 5000, '#00ff88');
    addLog(` Mini-game complete! Score: ${MINIGAME.score}  +${credits} Cr, +${xp} XP`, 'earn');
    
    checkLevelUp();
    updateHUD();
    save();
    
    document.getElementById('minigame-timer').textContent = 'Game Over!';
    document.getElementById('minigame-start').style.display = 'inline-block';
    document.getElementById('minigame-start').textContent = 'PLAY AGAIN';
    
    setTimeout(() => backToArcade(), 3000);
}

// ==================== INGREDIENT CATCH MINI-GAME ====================
const CATCH_GAME = {
    active: false,
    timer: null,
    animFrame: null,
    timeLeft: 45,
    score: 0,
    drinksMixed: 0,
    ingredients: [], // falling items on screen
    currentRecipe: null, // { name, icon, steps: [{emoji, name}] }
    nextStep: 0, // which ingredient to catch next
    spawnTimer: 0,
    canvas: null,
    ctx: null,
};

const CATCH_INGREDIENTS = [
    { emoji: '', name: 'Quantum Fizz' },
    { emoji: '', name: 'Nebula Bubbles' },
    { emoji: '', name: 'Comet Dust' },
    { emoji: '', name: 'Stardust' },
    { emoji: '', name: 'Cryo Ice' },
    { emoji: '', name: 'Plasma Citrus' },
    { emoji: '', name: 'Nova Pepper' },
    { emoji: '', name: 'Honey Nebula' },
    { emoji: '', name: 'Void Berries' },
    { emoji: '', name: 'Moon Salt' },
    { emoji: '', name: 'Astro Mint' },
    { emoji: '', name: 'Crystal Shard' },
];

const CATCH_RECIPES = [
    { name: 'Cosmic Martini', icon: '', steps: 3 },
    { name: 'Nebula Shot', icon: '', steps: 3 },
    { name: 'Rocket Fuel', icon: '', steps: 4 },
    { name: 'Starlight Fizz', icon: '', steps: 4 },
    { name: 'Void Brew', icon: '', steps: 5 },
    { name: 'Solar Punch', icon: '', steps: 5 },
    { name: 'Galaxy Swirl', icon: '', steps: 6 },
];

function generateRecipe() {
    const template = CATCH_RECIPES[Math.min(CATCH_GAME.drinksMixed, CATCH_RECIPES.length - 1)];
    const steps = [];
    const used = new Set();
    for (let i = 0; i < template.steps; i++) {
        let idx;
        do { idx = Math.floor(Math.random() * CATCH_INGREDIENTS.length); } while (used.has(idx));
        used.add(idx);
        steps.push(CATCH_INGREDIENTS[idx]);
    }
    return { name: template.name, icon: template.icon, steps };
}

function initCatchGame() {
    CATCH_GAME.score = 0;
    CATCH_GAME.drinksMixed = 0;
    CATCH_GAME.timeLeft = 45;
    CATCH_GAME.active = false;
    CATCH_GAME.ingredients = [];
    document.getElementById('catch-timer').textContent = ' 45s';
    document.getElementById('catch-score').textContent = 'Score: 0';
    document.getElementById('catch-drinks').textContent = ' 0';
    document.getElementById('catch-recipe').textContent = 'Press START to begin!';
    document.getElementById('catch-start-btn').style.display = 'inline-block';
    document.getElementById('catch-start-btn').textContent = 'START!';
}

function startCatchGame() {
    CATCH_GAME.active = true;
    CATCH_GAME.score = 0;
    CATCH_GAME.drinksMixed = 0;
    CATCH_GAME.timeLeft = 45;
    CATCH_GAME.ingredients = [];
    CATCH_GAME.spawnTimer = 0;
    CATCH_GAME.nextStep = 0;
    CATCH_GAME.currentRecipe = generateRecipe();
    document.getElementById('catch-start-btn').style.display = 'none';
    
    CATCH_GAME.canvas = document.getElementById('catch-canvas');
    CATCH_GAME.ctx = CATCH_GAME.canvas.getContext('2d');
    CATCH_GAME.canvas.onclick = catchGameClick;
    
    updateCatchRecipeDisplay();
    
    CATCH_GAME.timer = setInterval(() => {
        if (!CATCH_GAME.active) return;
        CATCH_GAME.timeLeft--;
        document.getElementById('catch-timer').textContent = ` ${CATCH_GAME.timeLeft}s`;
        if (CATCH_GAME.timeLeft <= 0) endCatchGame();
    }, 1000);
    
    catchGameLoop();
}

function updateCatchRecipeDisplay() {
    const r = CATCH_GAME.currentRecipe;
    let html = `${r.icon} <b>${r.name}</b>: `;
    r.steps.forEach((s, i) => {
        if (i < CATCH_GAME.nextStep) html += `<span style="opacity:0.4;text-decoration:line-through">${s.emoji}</span> `;
        else if (i === CATCH_GAME.nextStep) html += `<span style="font-size:22px;filter:drop-shadow(0 0 6px gold)">${s.emoji}</span> `;
        else html += `${s.emoji} `;
    });
    document.getElementById('catch-recipe').innerHTML = html;
}

function catchGameLoop() {
    if (!CATCH_GAME.active) return;
    const ctx = CATCH_GAME.ctx;
    const cw = CATCH_GAME.canvas.width;
    const ch = CATCH_GAME.canvas.height;
    
    ctx.clearRect(0, 0, cw, ch);
    
    // Spawn new ingredients
    CATCH_GAME.spawnTimer++;
    const spawnRate = Math.max(12, 30 - CATCH_GAME.drinksMixed * 2);
    if (CATCH_GAME.spawnTimer >= spawnRate) {
        CATCH_GAME.spawnTimer = 0;
        // Always spawn the needed ingredient sometimes, plus distractors
        const needed = CATCH_GAME.currentRecipe.steps[CATCH_GAME.nextStep];
        const isNeeded = Math.random() < 0.35;
        const ing = isNeeded ? needed : CATCH_INGREDIENTS[Math.floor(Math.random() * CATCH_INGREDIENTS.length)];
        CATCH_GAME.ingredients.push({
            x: 20 + Math.random() * (cw - 40),
            y: -20,
            speed: 1 + Math.random() * 1.5 + CATCH_GAME.drinksMixed * 0.15,
            emoji: ing.emoji,
            name: ing.name,
            isTarget: ing.emoji === needed.emoji,
            size: 28,
            wobble: Math.random() * Math.PI * 2,
        });
    }
    
    // Update & draw
    ctx.font = '28px serif';
    ctx.textAlign = 'center';
    ctx.textBaseline = 'middle';
    
    for (let i = CATCH_GAME.ingredients.length - 1; i >= 0; i--) {
        const ing = CATCH_GAME.ingredients[i];
        ing.y += ing.speed;
        ing.wobble += 0.05;
        const drawX = ing.x + Math.sin(ing.wobble) * 8;
        
        // Glow for target ingredients
        if (ing.isTarget) {
            ctx.save();
            ctx.shadowColor = '#ffd700';
            ctx.shadowBlur = 12;
            ctx.fillText(ing.emoji, drawX, ing.y);
            ctx.restore();
        } else {
            ctx.fillText(ing.emoji, drawX, ing.y);
        }
        
        // Remove if off screen
        if (ing.y > ch + 20) {
            // Penalty if it was the needed ingredient
            if (ing.isTarget) {
                CATCH_GAME.score = Math.max(0, CATCH_GAME.score - 5);
                document.getElementById('catch-score').textContent = `Score: ${CATCH_GAME.score}`;
            }
            CATCH_GAME.ingredients.splice(i, 1);
        }
    }
    
    CATCH_GAME.animFrame = requestAnimationFrame(catchGameLoop);
}

function catchGameClick(e) {
    if (!CATCH_GAME.active) return;
    const rect = CATCH_GAME.canvas.getBoundingClientRect();
    const scaleX = CATCH_GAME.canvas.width / rect.width;
    const scaleY = CATCH_GAME.canvas.height / rect.height;
    const mx = (e.clientX - rect.left) * scaleX;
    const my = (e.clientY - rect.top) * scaleY;
    
    // Find closest ingredient within click radius
    let closest = null, closestDist = 35;
    for (const ing of CATCH_GAME.ingredients) {
        const dx = ing.x + Math.sin(ing.wobble) * 8 - mx;
        const dy = ing.y - my;
        const d = Math.sqrt(dx * dx + dy * dy);
        if (d < closestDist) { closestDist = d; closest = ing; }
    }
    
    if (!closest) return;
    
    const needed = CATCH_GAME.currentRecipe.steps[CATCH_GAME.nextStep];
    if (closest.emoji === needed.emoji) {
        // Correct!
        playSound('click');
        CATCH_GAME.ingredients.splice(CATCH_GAME.ingredients.indexOf(closest), 1);
        CATCH_GAME.nextStep++;
        CATCH_GAME.score += 10 * (CATCH_GAME.drinksMixed + 1);
        
        if (CATCH_GAME.nextStep >= CATCH_GAME.currentRecipe.steps.length) {
            // Drink complete!
            playSound('combo');
            CATCH_GAME.drinksMixed++;
            const bonus = 50 * CATCH_GAME.drinksMixed;
            CATCH_GAME.score += bonus;
            CATCH_GAME.timeLeft = Math.min(45, CATCH_GAME.timeLeft + 3);
            
            // Next recipe
            CATCH_GAME.nextStep = 0;
            CATCH_GAME.currentRecipe = generateRecipe();
            document.getElementById('catch-drinks').textContent = ` ${CATCH_GAME.drinksMixed}`;
        }
        
        document.getElementById('catch-score').textContent = `Score: ${CATCH_GAME.score}`;
        updateCatchRecipeDisplay();
    } else {
        // Wrong ingredient - small penalty
        playSound('angry');
        CATCH_GAME.score = Math.max(0, CATCH_GAME.score - 10);
        CATCH_GAME.timeLeft = Math.max(0, CATCH_GAME.timeLeft - 1);
        document.getElementById('catch-score').textContent = `Score: ${CATCH_GAME.score}`;
        document.getElementById('catch-timer').textContent = ` ${CATCH_GAME.timeLeft}s`;
        // Flash the ingredient red
        closest.wrongFlash = 5;
    }
}

function endCatchGame() {
    CATCH_GAME.active = false;
    if (CATCH_GAME.timer) { clearInterval(CATCH_GAME.timer); CATCH_GAME.timer = null; }
    if (CATCH_GAME.animFrame) { cancelAnimationFrame(CATCH_GAME.animFrame); CATCH_GAME.animFrame = null; }
    
    const credits = Math.floor(CATCH_GAME.score * 0.6);
    const xp = Math.floor(CATCH_GAME.score * 0.4);
    
    GS.credits += credits;
    GS.xp += xp;
    
    playSound('levelup');
    showNotification(' Ingredient Catch Complete!', `Drinks mixed: ${CATCH_GAME.drinksMixed}\nScore: ${CATCH_GAME.score}\n+${credits} Cr, +${xp} XP`, 5000, '#ff66ff');
    addLog(` Ingredient Catch done! ${CATCH_GAME.drinksMixed} drinks, score ${CATCH_GAME.score}  +${credits} Cr, +${xp} XP`, 'earn');
    
    checkLevelUp();
    updateHUD();
    save();
    
    document.getElementById('catch-recipe').innerHTML = ` Game Over! ${CATCH_GAME.drinksMixed} drinks mixed!`;
    document.getElementById('catch-start-btn').style.display = 'inline-block';
    document.getElementById('catch-start-btn').textContent = 'PLAY AGAIN';
    
    setTimeout(() => backToArcade(), 3500);
}

function stopCatchGame() {
    CATCH_GAME.active = false;
    if (CATCH_GAME.timer) { clearInterval(CATCH_GAME.timer); CATCH_GAME.timer = null; }
    if (CATCH_GAME.animFrame) { cancelAnimationFrame(CATCH_GAME.animFrame); CATCH_GAME.animFrame = null; }
    if (CATCH_GAME.canvas) CATCH_GAME.canvas.onclick = null;
}

// ==================== SPACE DARTS MINI-GAME ====================
const DARTS = {
    active: false,
    canvas: null,
    ctx: null,
    animFrame: null,
    score: 0,
    round: 1,
    maxRounds: 3,
    throwNum: 0,
    throwsPerRound: 3,
    angle: 0,         // current marker angle (radians)
    speed: 0,         // radians per frame
    baseSpeed: 0.04,
    thrown: false,     // is dart in flight?
    dartX: 0, dartY: 0,
    dartTargetX: 0, dartTargetY: 0,
    dartProgress: 0,
    darts: [],        // {x, y, points} - landed darts
    cx: 150, cy: 150, // center
    boardRadius: 120,
    resultTimeout: null,
};

function startDartsGame() {
    const D = DARTS;
    D.canvas = document.getElementById('darts-canvas');
    D.ctx = D.canvas.getContext('2d');
    D.active = true;
    D.score = 0;
    D.round = 1;
    D.throwNum = 0;
    D.darts = [];
    D.thrown = false;
    D.angle = 0;
    D.speed = D.baseSpeed;
    document.getElementById('darts-start-btn').textContent = 'THROW!';
    document.getElementById('darts-start-btn').onclick = throwDart;
    D.canvas.onclick = throwDart;
    updateDartsInfo();
    dartsLoop();
}

function updateDartsInfo() {
    const D = DARTS;
    document.getElementById('darts-round-info').textContent = `Round ${D.round} / ${D.maxRounds}  Throw ${D.throwNum + 1} / ${D.throwsPerRound}`;
    document.getElementById('darts-score').textContent = `Score: ${D.score}`;
}

function throwDart() {
    const D = DARTS;
    if (!D.active || D.thrown) return;
    D.thrown = true;
    playSound('click');

    // Calculate where the marker is pointing
    const markerDist = D.boardRadius + 20;
    const mx = D.cx + Math.cos(D.angle) * markerDist;
    const my = D.cy + Math.sin(D.angle) * markerDist;

    // Dart travels from marker toward center, landing based on angle accuracy
    // How close is the marker to the top (bullseye direction = straight at center)?
    const dx = D.cx - mx;
    const dy = D.cy - my;
    const len = Math.sqrt(dx * dx + dy * dy);

    // Dart lands along the line from marker to center, with some scatter
    const scatter = (Math.random() - 0.5) * 15;
    D.dartX = mx;
    D.dartY = my;
    D.dartTargetX = D.cx + scatter;
    D.dartTargetY = D.cy + scatter;
    D.dartProgress = 0;
}

function landDart() {
    const D = DARTS;
    const x = D.dartTargetX;
    const y = D.dartTargetY;
    const dist = Math.sqrt((x - D.cx) ** 2 + (y - D.cy) ** 2);

    let points = 0;
    let label = '';
    const r = D.boardRadius;
    if (dist < r * 0.1) { points = 100; label = ' BULLSEYE! +100'; }
    else if (dist < r * 0.25) { points = 50; label = ' Inner ring! +50'; }
    else if (dist < r * 0.45) { points = 25; label = ' Middle ring! +25'; }
    else if (dist < r * 0.7) { points = 10; label = ' Outer ring! +10'; }
    else if (dist < r) { points = 5; label = ' Edge! +5'; }
    else { points = 0; label = ' Miss!'; }

    if (points === 100) playSound('combo');
    else if (points >= 25) playSound('serve');
    else if (points > 0) playSound('order');
    else playSound('angry');

    D.darts.push({ x, y, points });
    D.score += points;
    D.throwNum++;
    D.thrown = false;

    document.getElementById('darts-result').textContent = label;
    if (D.resultTimeout) clearTimeout(D.resultTimeout);
    D.resultTimeout = setTimeout(() => { document.getElementById('darts-result').textContent = ''; }, 1500);

    // Speed increases each throw
    D.speed = D.baseSpeed + D.throwNum * 0.008 + (D.round - 1) * 0.015;

    updateDartsInfo();

    if (D.throwNum >= D.throwsPerRound) {
        // End of round
        D.round++;
        D.throwNum = 0;
        D.darts = [];
        if (D.round > D.maxRounds) {
            endDartsGame();
            return;
        }
        D.speed = D.baseSpeed + (D.round - 1) * 0.015;
        updateDartsInfo();
    }
}

function endDartsGame() {
    const D = DARTS;
    D.active = false;
    if (D.animFrame) { cancelAnimationFrame(D.animFrame); D.animFrame = null; }
    D.canvas.onclick = null;

    const credits = Math.floor(D.score * 0.8);
    const xp = Math.floor(D.score * 0.5);
    GS.credits += credits;
    GS.xp += xp;

    playSound('levelup');
    showNotification(' Space Darts Complete!', `Final Score: ${D.score}\n+${credits} Cr, +${xp} XP`, 5000, '#ff6644');
    addLog(` Space Darts done! Score ${D.score}  +${credits} Cr, +${xp} XP`, 'earn');

    checkLevelUp();
    updateHUD();
    save();

    document.getElementById('darts-result').textContent = ` Final Score: ${D.score}!`;
    document.getElementById('darts-start-btn').textContent = 'PLAY AGAIN';
    document.getElementById('darts-start-btn').onclick = startDartsGame;

    setTimeout(() => backToArcade(), 3500);
}

function dartsLoop() {
    const D = DARTS;
    if (!D.active) return;

    const ctx = D.ctx;
    const w = D.canvas.width, h = D.canvas.height;
    ctx.clearRect(0, 0, w, h);

    // Draw board
    const rings = [
        { r: D.boardRadius, color: '#1a1a3e' },
        { r: D.boardRadius * 0.7, color: '#2a2a5e' },
        { r: D.boardRadius * 0.45, color: '#3a3a7e' },
        { r: D.boardRadius * 0.25, color: '#4a4a9e' },
        { r: D.boardRadius * 0.1, color: '#ff4444' },
    ];
    rings.forEach(ring => {
        ctx.beginPath();
        ctx.arc(D.cx, D.cy, ring.r, 0, Math.PI * 2);
        ctx.fillStyle = ring.color;
        ctx.fill();
        ctx.strokeStyle = 'rgba(0,255,136,0.3)';
        ctx.lineWidth = 1;
        ctx.stroke();
    });

    // Crosshairs
    ctx.strokeStyle = 'rgba(0,255,136,0.2)';
    ctx.lineWidth = 1;
    ctx.beginPath(); ctx.moveTo(D.cx - D.boardRadius, D.cy); ctx.lineTo(D.cx + D.boardRadius, D.cy); ctx.stroke();
    ctx.beginPath(); ctx.moveTo(D.cx, D.cy - D.boardRadius); ctx.lineTo(D.cx, D.cy + D.boardRadius); ctx.stroke();

    // Ring labels
    ctx.fillStyle = 'rgba(255,255,255,0.3)';
    ctx.font = '10px Nunito';
    ctx.textAlign = 'center';
    ctx.fillText('100', D.cx, D.cy + 4);
    ctx.fillText('50', D.cx + D.boardRadius * 0.17, D.cy + 4);
    ctx.fillText('25', D.cx + D.boardRadius * 0.35, D.cy + 4);
    ctx.fillText('10', D.cx + D.boardRadius * 0.57, D.cy + 4);
    ctx.fillText('5', D.cx + D.boardRadius * 0.85, D.cy + 4);

    // Draw landed darts
    D.darts.forEach(dart => {
        ctx.beginPath();
        ctx.arc(dart.x, dart.y, 4, 0, Math.PI * 2);
        ctx.fillStyle = dart.points >= 50 ? '#ffd700' : dart.points >= 10 ? '#00ff88' : '#ff6666';
        ctx.fill();
        ctx.strokeStyle = '#fff';
        ctx.lineWidth = 1.5;
        ctx.stroke();
    });

    if (!D.thrown) {
        // Rotating marker
        D.angle += D.speed;
        const markerDist = D.boardRadius + 15;
        const mx = D.cx + Math.cos(D.angle) * markerDist;
        const my = D.cy + Math.sin(D.angle) * markerDist;

        // Draw aim line
        ctx.strokeStyle = 'rgba(255,100,100,0.4)';
        ctx.lineWidth = 1;
        ctx.setLineDash([4, 4]);
        ctx.beginPath(); ctx.moveTo(mx, my); ctx.lineTo(D.cx, D.cy); ctx.stroke();
        ctx.setLineDash([]);

        // Marker
        ctx.beginPath();
        ctx.arc(mx, my, 8, 0, Math.PI * 2);
        ctx.fillStyle = '#ff4444';
        ctx.fill();
        ctx.strokeStyle = '#fff';
        ctx.lineWidth = 2;
        ctx.stroke();

        // Arrow pointing inward
        const aLen = 12;
        const toCenter = Math.atan2(D.cy - my, D.cx - mx);
        ctx.beginPath();
        ctx.moveTo(mx + Math.cos(toCenter) * aLen, my + Math.sin(toCenter) * aLen);
        ctx.lineTo(mx + Math.cos(toCenter + 0.4) * 5, my + Math.sin(toCenter + 0.4) * 5);
        ctx.lineTo(mx + Math.cos(toCenter - 0.4) * 5, my + Math.sin(toCenter - 0.4) * 5);
        ctx.closePath();
        ctx.fillStyle = '#ff4444';
        ctx.fill();
    } else {
        // Animate dart flight
        D.dartProgress += 0.08;
        if (D.dartProgress >= 1) {
            D.dartProgress = 1;
            landDart();
        } else {
            const cx = D.dartX + (D.dartTargetX - D.dartX) * D.dartProgress;
            const cy = D.dartY + (D.dartTargetY - D.dartY) * D.dartProgress;
            // Trail
            ctx.beginPath();
            ctx.arc(cx, cy, 5, 0, Math.PI * 2);
            ctx.fillStyle = '#ffd700';
            ctx.fill();
            ctx.beginPath();
            ctx.arc(cx, cy, 8, 0, Math.PI * 2);
            ctx.strokeStyle = 'rgba(255,215,0,0.4)';
            ctx.lineWidth = 2;
            ctx.stroke();
        }
    }

    D.animFrame = requestAnimationFrame(dartsLoop);
}

function stopDartsGame() {
    DARTS.active = false;
    if (DARTS.animFrame) { cancelAnimationFrame(DARTS.animFrame); DARTS.animFrame = null; }
    if (DARTS.canvas) DARTS.canvas.onclick = null;
}

// ==================== PRESTIGE SYSTEM ====================
const PRESTIGE_MIN_LEVEL = 8;  // Minimum level to prestige
const PRESTIGE_MIN_DRINKS = 50; // Minimum drinks served

function getPrestigeBonuses() {
    const points = GS._prestigePoints || 0;
    return {
        startingCredits: points * 50,
        xpMultiplier: 1 + (points * 0.05),
        tipMultiplier: 1 + (points * 0.03),
        startingReputation: points * 5
    };
}

function calculatePrestigePoints() {
    // Calculate points earned from current run
    const levelBonus = Math.floor(GS.level / 3);
    const drinkBonus = Math.floor(GS.totalServed / 25);
    const earnedBonus = Math.floor(GS.totalEarned / 1000);
    return Math.max(1, levelBonus + drinkBonus + earnedBonus);
}

function canPrestige() {
    return GS.level >= PRESTIGE_MIN_LEVEL && GS.totalServed >= PRESTIGE_MIN_DRINKS;
}

function openPrestigePanel() {
    const panel = document.getElementById('prestige-panel');
    const pointsToEarn = calculatePrestigePoints();
    const canDo = canPrestige();
    
    // Update stats display
    document.getElementById('p-level').textContent = GS.level;
    document.getElementById('p-drinks').textContent = GS.totalServed;
    document.getElementById('p-earned').textContent = GS.totalEarned.toLocaleString();
    document.getElementById('p-current').textContent = GS._prestigePoints || 0;
    document.getElementById('p-points').textContent = '+' + pointsToEarn;
    
    // Show requirements if not met
    const reqEl = document.getElementById('p-req');
    if (!canDo) {
        let reqs = [];
        if (GS.level < PRESTIGE_MIN_LEVEL) reqs.push(`Level ${PRESTIGE_MIN_LEVEL}+ (currently ${GS.level})`);
        if (GS.totalServed < PRESTIGE_MIN_DRINKS) reqs.push(`${PRESTIGE_MIN_DRINKS}+ drinks (currently ${GS.totalServed})`);
        reqEl.textContent = ' Requirements: ' + reqs.join(', ');
        reqEl.style.display = 'block';
    } else {
        reqEl.style.display = 'none';
    }
    
    // Enable/disable button
    const confirmBtn = document.getElementById('prestige-confirm');
    confirmBtn.disabled = !canDo;
    
    panel.classList.add('show');
}

function closePrestigePanel() {
    document.getElementById('prestige-panel').classList.remove('show');
}

function doPrestige() {
    if (!canPrestige()) return;
    
    const pointsEarned = calculatePrestigePoints();
    
    // Store values we want to keep
    const keepData = {
        prestigePoints: (GS._prestigePoints || 0) + pointsEarned,
        lifetimePrestige: (GS._lifetimePrestige || 0) + pointsEarned,
        prestigeCount: (GS._prestigeCount || 0) + 1,
        // Keep streaks
        loginStreak: GS._loginStreak,
        lastLogin: GS._lastLogin,
        perfectDayStreak: GS._perfectDayStreak,
        longestLoginStreak: GS._longestLoginStreak,
        totalLogins: GS._totalLogins,
        streakRewardsClaimed: GS._streakRewardsClaimed,
        // Keep favorites discovered
        favoritesServed: GS._favoritesServed || [],
    };
    
    // Keep achievements (they're in a separate variable)
    const keepAchievements = [...unlockedAchievements];
    
    // Apply prestige bonuses for starting values
    const bonuses = getPrestigeBonuses();
    bonuses.startingCredits += pointsEarned * 50; // Include new points
    bonuses.startingReputation += pointsEarned * 5;
    
    // Reset game state
    GS.credits = 100 + bonuses.startingCredits;
    GS.level = 1;
    GS.xp = 0;
    GS.xpNeeded = 100;
    GS.reputation = 50 + bonuses.startingReputation;
    GS.tables = [];
    GS.customers = [];
    GS.upgrades = [];
    GS.decorations = [];
    GS.unlockedDrinks = ['cosmic_martini', 'nebula_shot', 'rocket_fuel', 'aurora_ale'];
    GS.inventory = {};
    GS.placedFurniture = [];
    GS.totalServed = 0;
    GS.totalEarned = 0;
    GS.spawnInterval = 6000;
    GS._maxCombo = 0;
    GS._vipServed = 0;
    GS._perfectServes = 0;
    GS._dailiesCompleted = 0;
    GS._walterServed = 0;
    GS._carlServed = 0;
    GS._zixServed = 0;
    GS._blorbServed = 0;
    GS._nightOwlServed = 0;
    
    // Restore kept data
    GS._prestigePoints = keepData.prestigePoints;
    GS._lifetimePrestige = keepData.lifetimePrestige;
    GS._prestigeCount = keepData.prestigeCount;
    GS._loginStreak = keepData.loginStreak;
    GS._lastLogin = keepData.lastLogin;
    GS._perfectDayStreak = keepData.perfectDayStreak;
    GS._longestLoginStreak = keepData.longestLoginStreak;
    GS._totalLogins = keepData.totalLogins;
    GS._streakRewardsClaimed = keepData.streakRewardsClaimed;
    GS._favoritesServed = keepData.favoritesServed;
    
    // Restore achievements
    unlockedAchievements = keepAchievements;
    
    // Reset quests
    completedQuests = [];
    activeQuests = ['q1_welcome'];
    
    // Reset daily challenges
    dailyProgress = {};
    dailyBonusClaimed = false;
    generateDailyChallenges();
    
    // Visual celebration
    screenShake();
    spawnParticleBurst(BAR_CENTER.x, BAR_CENTER.y, '#ffaa00', 40);
    spawnParticleBurst(BAR_CENTER.x, BAR_CENTER.y, '#ffd700', 30);
    spawnSparkles(BAR_CENTER.x, BAR_CENTER.y, 20);
    spawnFloatingNumber(BAR_CENTER.x, BAR_CENTER.y, `+${pointsEarned} `, 'combo');
    playSound('levelup');
    
    showNotification(` PRESTIGE COMPLETE! +${pointsEarned} Prestige Points!`);
    addLog(` Prestiged! +${pointsEarned} points (Total: ${GS._prestigePoints})`, 'tip');
    
    closePrestigePanel();
    updateHUD();
    buildShop();
    save();
}

function updatePrestigeHUD() {
    const badge = document.getElementById('hud-prestige');
    if (badge) badge.textContent = GS._prestigePoints || 0;
}

// ==================== STATISTICS DASHBOARD ====================
function openStatsPanel() {
    updateStatsDisplay();
    document.getElementById('stats-panel').classList.add('show');
}

function closeStatsPanel() {
    document.getElementById('stats-panel').classList.remove('show');
}

function updateStatsDisplay() {
    // Lifetime service stats
    document.getElementById('stats-total-served').textContent = (GS.totalServed || 0).toLocaleString();
    document.getElementById('stats-total-earned').textContent = (GS.totalEarned || 0).toLocaleString();
    document.getElementById('stats-vips-served').textContent = (GS._vipServed || 0).toLocaleString();
    document.getElementById('stats-perfect-serves').textContent = (GS._perfectServes || 0).toLocaleString();
    
    // Personal records
    document.getElementById('stats-best-combo').textContent = (GS._maxCombo || 0) + 'x';
    document.getElementById('stats-highest-level').textContent = GS._highestLevel || GS.level || 1;
    document.getElementById('stats-max-credits').textContent = (GS._maxCreditsHeld || GS.credits || 0).toLocaleString();
    document.getElementById('stats-max-rep').textContent = Math.floor(GS._maxReputation || GS.reputation || 0);
    document.getElementById('stats-best-streak').textContent = (GS._longestLoginStreak || 0) + ' days';
    
    // Prestige & progress
    document.getElementById('stats-prestige-count').textContent = GS._prestigeCount || 0;
    document.getElementById('stats-prestige-points').textContent = GS._prestigePoints || 0;
    document.getElementById('stats-achievements').textContent = unlockedAchievements.length + '/' + Object.keys(ACHIEVEMENTS).length;
    document.getElementById('stats-stars-caught').textContent = GS._starsCaught || 0;
    document.getElementById('stats-quests').textContent = completedQuests.length + '/10';
    
    // Play time
    document.getElementById('stats-days-played').textContent = GS._totalLogins || 1;
    document.getElementById('stats-sessions').textContent = GS._sessionCount || 1;
}

// Track personal records
function updatePersonalRecords() {
    // Track highest values achieved
    if (GS.level > (GS._highestLevel || 0)) GS._highestLevel = GS.level;
    if (GS.credits > (GS._maxCreditsHeld || 0)) GS._maxCreditsHeld = GS.credits;
    if (GS.reputation > (GS._maxReputation || 0)) GS._maxReputation = GS.reputation;
    if (comboCount > (GS._maxCombo || 0)) GS._maxCombo = comboCount;
}

// ==================== SETTINGS MENU ====================
const DEFAULT_SETTINGS = {
    volume: 50,
    sfx: true,
    music: false,
    autosave: 60,
    tips: true,
    particles: true,
    eventlog: true,
    combo: true
};

let gameSettings = { ...DEFAULT_SETTINGS };

function openSettingsPanel() {
    loadSettingsToUI();
    document.getElementById('settings-panel').classList.add('show');
}

function closeSettingsPanel() {
    document.getElementById('settings-panel').classList.remove('show');
}

function loadSettingsToUI() {
    document.getElementById('setting-volume').value = gameSettings.volume;
    document.getElementById('volume-display').textContent = gameSettings.volume + '%';
    document.getElementById('setting-sfx').checked = gameSettings.sfx;
    document.getElementById('setting-music').checked = gameSettings.music;
    document.getElementById('setting-autosave').value = gameSettings.autosave;
    document.getElementById('setting-tips').checked = gameSettings.tips;
    document.getElementById('setting-particles').checked = gameSettings.particles;
    document.getElementById('setting-eventlog').checked = gameSettings.eventlog;
    document.getElementById('setting-combo').checked = gameSettings.combo;
}

function saveSettings() {
    gameSettings.volume = parseInt(document.getElementById('setting-volume').value);
    gameSettings.sfx = document.getElementById('setting-sfx').checked;
    gameSettings.music = document.getElementById('setting-music').checked;
    gameSettings.autosave = parseInt(document.getElementById('setting-autosave').value);
    gameSettings.tips = document.getElementById('setting-tips').checked;
    gameSettings.particles = document.getElementById('setting-particles').checked;
    gameSettings.eventlog = document.getElementById('setting-eventlog').checked;
    gameSettings.combo = document.getElementById('setting-combo').checked;
    
    // Apply settings
    applySettings();
    
    // Save to localStorage
    localStorage.setItem('ob_settings', JSON.stringify(gameSettings));
    
    showNotification(' Settings saved!');
    closeSettingsPanel();
}

function loadSettings() {
    try {
        const saved = localStorage.getItem('ob_settings');
        if (saved) {
            gameSettings = { ...DEFAULT_SETTINGS, ...JSON.parse(saved) };
        }
        applySettings();
    } catch(e) {
        console.warn('Failed to load settings:', e);
    }
}

function applySettings() {
    // Apply volume to audio context
    if (typeof masterVolume !== 'undefined') {
        masterVolume = gameSettings.volume / 100;
    }
    
    // Show/hide event log
    const eventLog = document.getElementById('event-log');
    if (eventLog) eventLog.style.display = gameSettings.eventlog ? 'block' : 'none';
    
    // Show/hide combo display based on setting
    const comboDisplay = document.getElementById('combo-display');
    if (comboDisplay && !gameSettings.combo) {
        comboDisplay.style.visibility = 'hidden';
    }
}

function resetAllData() {
    if (!confirm(' Are you sure you want to DELETE ALL your game data?\n\nThis cannot be undone!')) return;
    if (!confirm(' FINAL WARNING: All progress, achievements, and settings will be permanently deleted.\n\nClick OK to confirm deletion.')) return;
    
    localStorage.removeItem('ob_save2');
    localStorage.removeItem('ob_settings');
    localStorage.removeItem('ob_leaderboard');
    
    showNotification(' All data deleted. Refreshing...');
    setTimeout(() => location.reload(), 1500);
}

// ==================== TIP JAR SYSTEM ====================
const TIP_JAR_MAX = 500; // Maximum tips before auto-collection warning
let tipJarAmount = 0;
let reviewQueue = [];
let currentReviewTimeout = null;

// Customer reviews based on happiness
const REVIEWS = {
    great: [ // 80-100% happiness
        "Best bar in the galaxy! ",
        "Walter recommended this place. He was right!",
        "The drinks here are out of this world!",
        "I'll definitely be back!",
        "Five stars, no question!",
        "My tentacles are tingling with joy!",
        "Finally, a bartender who gets it!",
        "Service was stellar!",
        "Tell your friends about this place!",
        "Made my whole space trip worth it!"
    ],
    okay: [ // 50-79% happiness
        "Pretty good, could be faster.",
        "Decent drinks. Decent service.",
        "It was... okay I guess.",
        "The wait was a bit long.",
        "Not bad, not great.",
        "I've had better, I've had worse.",
        "Room for improvement here.",
        "Average experience overall."
    ],
    bad: [ // 0-49% happiness
        "What a waste of space credits!",
        "I've been waiting forever!",
        "Terrible service! ",
        "My drink was cold... it was supposed to be hot!",
        "I'll warn my friends about this dump.",
        "How is this place still open?!",
        "Never coming back!",
        "The worst bar in this quadrant!"
    ]
};

function initTipJar() {
    tipJarAmount = GS._tipJarAmount || 0;
    updateTipJarDisplay();
    
    // Click handler to collect tips
    document.getElementById('tip-jar').onclick = () => {
        if (tipJarAmount > 0) {
            collectTipJar();
        } else {
            showNotification(' Tip jar is empty!');
        }
    };
}

function addToTipJar(amount) {
    tipJarAmount += amount;
    GS._tipJarAmount = tipJarAmount;
    
    // Visual feedback
    const jar = document.getElementById('tip-jar');
    jar.classList.add('glow');
    setTimeout(() => jar.classList.remove('glow'), 500);
    
    updateTipJarDisplay();
    
    // Warn if jar is getting full
    if (tipJarAmount >= TIP_JAR_MAX * 0.8 && tipJarAmount < TIP_JAR_MAX) {
        addLog(' Tip jar is almost full! Click to collect.', 'tip');
    }
}

function collectTipJar() {
    if (tipJarAmount <= 0) return;
    
    const collected = tipJarAmount;
    GS.credits += collected;
    GS.totalEarned += collected;
    
    // Visual celebration
    playSound('levelup');
    spawnParticleBurst(BAR_CENTER.x, BAR_CENTER.y, '#ffd700', 20);
    spawnSparkles(BAR_CENTER.x, BAR_CENTER.y, 10);
    spawnFloatingNumber(BAR_CENTER.x, BAR_CENTER.y, `+${collected}`, 'credits');
    
    showNotification(` Collected ${collected} credits from tip jar!`);
    addLog(` Tip jar collected: +${collected} Cr`, 'earn');
    
    // Track for statistics
    GS._totalTipsCollected = (GS._totalTipsCollected || 0) + collected;
    
    tipJarAmount = 0;
    GS._tipJarAmount = 0;
    updateTipJarDisplay();
    updateHUD();
    save();
}

function updateTipJarDisplay() {
    const amountEl = document.getElementById('jar-amount');
    const fillEl = document.getElementById('jar-fill');
    const jarEl = document.getElementById('tip-jar');
    
    if (amountEl) amountEl.textContent = tipJarAmount;
    
    // Visual fill level
    const fillPercent = Math.min(100, (tipJarAmount / TIP_JAR_MAX) * 100);
    if (fillEl) fillEl.style.height = fillPercent + '%';
    
    // Ready state when there's something to collect
    if (jarEl) {
        if (tipJarAmount >= 50) {
            jarEl.classList.add('ready');
        } else {
            jarEl.classList.remove('ready');
        }
    }
}

// ==================== CUSTOMER REVIEW SYSTEM ====================
function addCustomerReview(customer, happiness) {
    // Determine review tier
    let tier, stars;
    if (happiness >= 80) {
        tier = 'great';
        stars = happiness >= 95 ? 5 : 4;
    } else if (happiness >= 50) {
        tier = 'okay';
        stars = happiness >= 65 ? 3 : 2;
    } else {
        tier = 'bad';
        stars = happiness >= 25 ? 2 : 1;
    }
    
    // Select random review
    const reviewTexts = REVIEWS[tier];
    const reviewText = reviewTexts[Math.floor(Math.random() * reviewTexts.length)];
    
    // Get character data
    const charData = CHAR_DATA[customer.char];
    
    // Create review object
    const review = {
        char: charData.emoji,
        name: charData.name,
        stars,
        text: reviewText,
        tier,
        timestamp: Date.now()
    };
    
    // Add to review history
    if (!GS._reviewHistory) GS._reviewHistory = [];
    GS._reviewHistory.push(review);
    
    // Keep only last 50 reviews
    if (GS._reviewHistory.length > 50) {
        GS._reviewHistory = GS._reviewHistory.slice(-50);
    }
    
    // Update bar rating
    updateBarRating();
    
    // Queue review for display
    queueReviewPopup(review);
    
    // Add tip based on happiness (10-30% of tip goes to jar)
    const tipForJar = Math.floor(Math.random() * 3) + Math.floor(happiness / 20);
    if (tipForJar > 0) {
        addToTipJar(tipForJar);
    }
}

function queueReviewPopup(review) {
    reviewQueue.push(review);
    
    // If no review is showing, show this one
    if (!currentReviewTimeout) {
        showNextReview();
    }
}

function showNextReview() {
    if (reviewQueue.length === 0) {
        hideReviewPopup();
        currentReviewTimeout = null;
        return;
    }
    
    const review = reviewQueue.shift();
    showReviewPopup(review);
    
    // Hide after 4 seconds, show next
    currentReviewTimeout = setTimeout(() => {
        showNextReview();
    }, 4000);
}

function showReviewPopup(review) {
    const popup = document.getElementById('review-popup');
    const charEl = document.getElementById('review-char');
    const nameEl = document.getElementById('review-name');
    const starsEl = document.getElementById('review-stars');
    const textEl = document.getElementById('review-text');
    
    charEl.textContent = review.char;
    nameEl.textContent = review.name;
    starsEl.textContent = ''.repeat(review.stars) + ''.repeat(5 - review.stars);
    starsEl.className = 'review-stars ' + review.tier;
    textEl.textContent = `"${review.text}"`;
    
    popup.classList.add('show');
}

function hideReviewPopup() {
    document.getElementById('review-popup').classList.remove('show');
}

function updateBarRating() {
    const reviews = GS._reviewHistory || [];
    const recent = reviews.slice(-20); // Use last 20 reviews
    
    if (recent.length === 0) {
        document.getElementById('rating-stars').textContent = '';
        document.getElementById('rating-count').textContent = 'No reviews yet';
        return;
    }
    
    // Calculate average stars
    const avgStars = recent.reduce((sum, r) => sum + r.stars, 0) / recent.length;
    const roundedStars = Math.round(avgStars);
    
    // Display stars
    const starsEl = document.getElementById('rating-stars');
    starsEl.textContent = ''.repeat(roundedStars) + ''.repeat(5 - roundedStars);
    
    // Color based on rating
    if (avgStars >= 4) {
        starsEl.style.color = '#00ff88';
    } else if (avgStars >= 2.5) {
        starsEl.style.color = '#ffaa00';
    } else {
        starsEl.style.color = '#ff4444';
    }
    
    // Update count
    document.getElementById('rating-count').textContent = `${reviews.length} reviews`;
    
    // Store bar rating for statistics
    GS._barRating = avgStars.toFixed(1);
}

// ==================== HAPPY HOUR SYSTEM ====================
let happyHourActive = false;
let happyHourEndTime = 0;
let happyHourInterval = null;

const HAPPY_HOUR_DURATION = 120000; // 2 minutes
const HAPPY_HOUR_COOLDOWN = 300000; // 5 minutes between happy hours
const HAPPY_HOUR_CHANCE = 0.002; // Chance per game tick to trigger (about every 8-10 minutes avg)

function checkHappyHourTrigger() {
    if (happyHourActive) return;
    if (GS._lastHappyHour && Date.now() - GS._lastHappyHour < HAPPY_HOUR_COOLDOWN) return;
    
    // Random chance to trigger
    if (Math.random() < HAPPY_HOUR_CHANCE) {
        startHappyHour();
    }
}

function startHappyHour() {
    if (happyHourActive) return;
    
    happyHourActive = true;
    happyHourEndTime = Date.now() + HAPPY_HOUR_DURATION;
    GS._lastHappyHour = Date.now();
    GS._happyHourCount = (GS._happyHourCount || 0) + 1;
    
    // Show banner
    document.getElementById('happy-hour-banner').classList.add('show');
    
    // Sound and notification
    playSound('levelup');
    showNotification(' HAPPY HOUR! Double tips and XP for 2 minutes!');
    addLog(' Happy Hour started! 2x tips and XP!', 'tip');
    
    // Visual celebration
    screenShake();
    spawnParticleBurst(BAR_CENTER.x, BAR_CENTER.y, '#ffaa00', 25);
    spawnSparkles(BAR_CENTER.x, BAR_CENTER.y, 15);
    
    // Start countdown
    happyHourInterval = setInterval(updateHappyHourTimer, 1000);
    updateHappyHourTimer();
}

function updateHappyHourTimer() {
    const remaining = happyHourEndTime - Date.now();
    
    if (remaining <= 0) {
        endHappyHour();
        return;
    }
    
    const minutes = Math.floor(remaining / 60000);
    const seconds = Math.floor((remaining % 60000) / 1000);
    document.getElementById('hh-timer').textContent = `${minutes}:${seconds.toString().padStart(2, '0')}`;
    
    // Warning when almost over
    if (remaining <= 10000 && remaining > 9000) {
        showNotification(' Happy Hour ending in 10 seconds!');
    }
}

function endHappyHour() {
    happyHourActive = false;
    happyHourEndTime = 0;
    
    if (happyHourInterval) {
        clearInterval(happyHourInterval);
        happyHourInterval = null;
    }
    
    // Hide banner
    document.getElementById('happy-hour-banner').classList.remove('show');
    
    // Notification
    showNotification(' Happy Hour ended! Back to normal rates.');
    addLog(' Happy Hour ended.', 'tip');
    playSound('ready');
}

function getHappyHourMultiplier() {
    return happyHourActive ? 2 : 1;
}

// ==================== TOOLTIP SYSTEM ====================
const TOOLTIPS = {
    'btn-shop': { title: ' Shop', desc: 'Buy furniture, upgrades, and decorations to improve your bar.' },
    'btn-inv': { title: ' Inventory', desc: 'View and place items you\'ve purchased.' },
    'btn-menu': { title: ' Drink Menu', desc: 'See all available drinks and their prices.' },
    'btn-quests': { title: ' Story Quests', desc: 'Complete quests to unlock rewards and progress the story.' },
    'btn-daily': { title: ' Daily Challenges', desc: 'Complete daily challenges for bonus credits and XP.' },
    'btn-chars': { title: ' Characters', desc: 'Learn about customers and their favorite drinks.' },
    'btn-minigame': { title: ' Mini-Game', desc: 'Play the Drink Mixing Challenge for bonus rewards!' },
    'btn-speed': { title: ' Game Speed', desc: 'Change how fast time passes in the game.' },
    'btn-ach': { title: ' Achievements', desc: 'View your unlocked achievements and rewards.' },
    'btn-lb': { title: ' Leaderboard', desc: 'See how you rank against other players.' },
    'btn-stats': { title: ' Statistics', desc: 'View detailed stats about your bar\'s performance.' },
    'btn-settings': { title: ' Settings', desc: 'Adjust sound, display, and game options.' },
    'streak-badge': { title: ' Login Streak', desc: 'Your current daily login streak. Keep it going for rewards!' },
    'prestige-badge': { title: ' Prestige', desc: 'Reset for permanent bonuses. Click to view prestige options.' },
    'tip-jar': { title: ' Tip Jar', desc: 'Tips from happy customers accumulate here. Click to collect!' },
    'bar-rating': { title: ' Bar Rating', desc: 'Your average customer rating based on recent reviews.' },
};

let tooltipTimeout = null;
let currentTooltipTarget = null;

function initTooltips() {
    const tooltip = document.getElementById('game-tooltip');
    
    Object.keys(TOOLTIPS).forEach(id => {
        const el = document.getElementById(id);
        if (!el) return;
        
        el.addEventListener('mouseenter', (e) => showTooltip(e, id));
        el.addEventListener('mouseleave', hideTooltip);
        el.addEventListener('click', hideTooltip);
    });
}

function showTooltip(event, id) {
    const data = TOOLTIPS[id];
    if (!data) return;
    
    currentTooltipTarget = id;
    
    // Delay before showing
    tooltipTimeout = setTimeout(() => {
        const tooltip = document.getElementById('game-tooltip');
        const titleEl = document.getElementById('tooltip-title');
        const descEl = document.getElementById('tooltip-desc');
        const shortcutEl = document.getElementById('tooltip-shortcut');
        
        titleEl.textContent = data.title;
        descEl.textContent = data.desc;
        shortcutEl.textContent = data.shortcut || '';
        shortcutEl.style.display = data.shortcut ? 'block' : 'none';
        
        // Position tooltip near element
        const rect = event.target.getBoundingClientRect();
        let x = rect.left + rect.width / 2;
        let y = rect.top - 10;
        
        // Keep on screen
        tooltip.style.left = Math.max(10, Math.min(x - 100, window.innerWidth - 210)) + 'px';
        tooltip.style.top = (y - tooltip.offsetHeight - 5) + 'px';
        
        // If would be above viewport, show below instead
        if (y - tooltip.offsetHeight < 60) {
            tooltip.style.top = (rect.bottom + 10) + 'px';
        }
        
        tooltip.classList.add('show');
    }, 500); // 500ms delay before showing
}

function hideTooltip() {
    if (tooltipTimeout) {
        clearTimeout(tooltipTimeout);
        tooltipTimeout = null;
    }
    currentTooltipTarget = null;
    document.getElementById('game-tooltip').classList.remove('show');
}

// ==================== SKILL TREE SYSTEM ====================
const SKILL_TREE = {
    speed: {
        name: ' Speed',
        skills: [
            { id: 'quick_hands',    icon: '', name: 'Quick Hands',     desc: '-10% prep time',           cost: 2,  requires: null },
            { id: 'rush_mode',      icon: '', name: 'Rush Mode',       desc: '-20% prep when 3+ waiting', cost: 3,  requires: 'quick_hands' },
            { id: 'lightning_serve', icon: '', name: 'Lightning Serve', desc: '10% chance instant prep',   cost: 5,  requires: 'rush_mode' },
            { id: 'time_warp',      icon: '', name: 'Time Warp',       desc: 'Speed boost lasts 2x longer', cost: 4, requires: 'rush_mode' },
        ]
    },
    charm: {
        name: ' Charm',
        skills: [
            { id: 'sweet_talk',     icon: '', name: 'Sweet Talk',      desc: '+10% tips from all',        cost: 2,  requires: null },
            { id: 'vip_magnet',     icon: '', name: 'VIP Magnet',      desc: '+25% VIP spawn chance',     cost: 3,  requires: 'sweet_talk' },
            { id: 'mood_boost',     icon: '', name: 'Mood Boost',      desc: '+15 starting happiness',    cost: 4,  requires: 'sweet_talk' },
            { id: 'legendary_charm',icon: '', name: 'Legendary Charm', desc: '5% chance of 3x tips',      cost: 6,  requires: 'vip_magnet' },
        ]
    },
    mixology: {
        name: ' Mixology',
        skills: [
            { id: 'flavor_boost',   icon: '', name: 'Flavor Boost',    desc: '+15% XP from drinks',      cost: 2,  requires: null },
            { id: 'secret_recipe',  icon: '', name: 'Secret Recipe',   desc: 'Favorites give +75% (not +50%)', cost: 3, requires: 'flavor_boost' },
            { id: 'master_mixer',   icon: '', name: 'Master Mixer',    desc: '+20% drink prices',         cost: 5,  requires: 'secret_recipe' },
            { id: 'cosmic_blend',   icon: '', name: 'Cosmic Blend',    desc: '8% chance to serve free refill (2x payment)', cost: 6, requires: 'master_mixer' },
        ]
    }
};

function getSkillPoints() {
    // Earn 1 skill point every 2 levels, starting at level 3
    const totalEarned = Math.max(0, Math.floor((GS.level - 1) / 2));
    const spent = (GS._skillsUnlocked || []).reduce((sum, id) => {
        for (const branch of Object.values(SKILL_TREE)) {
            const skill = branch.skills.find(s => s.id === id);
            if (skill) return sum + skill.cost;
        }
        return sum;
    }, 0);
    return totalEarned - spent;
}

function hasSkill(id) {
    return (GS._skillsUnlocked || []).includes(id);
}

function canUnlockSkill(skill) {
    if (hasSkill(skill.id)) return false;
    if (getSkillPoints() < skill.cost) return false;
    if (skill.requires && !hasSkill(skill.requires)) return false;
    return true;
}

function unlockSkill(skillId) {
    for (const branch of Object.values(SKILL_TREE)) {
        const skill = branch.skills.find(s => s.id === skillId);
        if (skill && canUnlockSkill(skill)) {
            if (!GS._skillsUnlocked) GS._skillsUnlocked = [];
            GS._skillsUnlocked.push(skillId);
            showNotification(` Skill Unlocked: ${skill.name}!`);
            playSound('levelup');
            buildSkillTree();
            save();
            return;
        }
    }
}

function getSkillBonuses() {
    const b = { prepSpeed: 1, tipMult: 1, xpMult: 1, happinessBonus: 0, vipMult: 1, priceMult: 1 };
    if (hasSkill('quick_hands'))     b.prepSpeed *= 1.1;
    if (hasSkill('rush_mode')) {
        const waiting = GS.customers ? GS.customers.filter(c => c.state === 'waiting').length : 0;
        if (waiting >= 3) b.prepSpeed *= 1.2;
    }
    if (hasSkill('sweet_talk'))      b.tipMult *= 1.1;
    if (hasSkill('mood_boost'))      b.happinessBonus += 15;
    if (hasSkill('vip_magnet'))      b.vipMult *= 1.25;
    if (hasSkill('flavor_boost'))    b.xpMult *= 1.15;
    if (hasSkill('master_mixer'))    b.priceMult *= 1.2;
    return b;
}

function buildSkillTree() {
    const container = document.getElementById('skill-tree-container');
    const pts = getSkillPoints();
    
    let html = `<div class="skill-tree-header">
        <h3> MARY'S SKILL TREE </h3>
        <div class="skill-points">Skill Points: <strong style="color:#ffd700">${pts}</strong> (earn 1 every 2 levels)</div>
    </div><div class="skill-branches">`;
    
    for (const [branchKey, branch] of Object.entries(SKILL_TREE)) {
        html += `<div class="skill-branch ${branchKey}">
            <div class="skill-branch-title">${branch.name}</div>`;
        
        branch.skills.forEach((skill, i) => {
            const unlocked = hasSkill(skill.id);
            const available = canUnlockSkill(skill);
            const locked = !unlocked && !available;
            const cls = unlocked ? 'unlocked' : available ? 'available' : 'locked';
            
            if (i > 0) {
                const prevUnlocked = hasSkill(branch.skills[i-1].id);
                html += `<div class="skill-connector ${prevUnlocked ? 'active' : ''}"></div>`;
            }
            
            html += `<div class="skill-node ${cls}" onclick="${available ? `unlockSkill('${skill.id}')` : ''}">
                <span class="skill-icon">${skill.icon}</span>
                <div class="skill-info">
                    <div class="skill-name">${skill.name} ${unlocked ? '' : ''}</div>
                    <div class="skill-desc">${skill.desc}</div>
                </div>
                <div class="skill-cost">${unlocked ? '' : `${skill.cost}`}</div>
            </div>`;
        });
        
        html += '</div>';
    }
    html += '</div>';
    container.innerHTML = html;
}

// ==================== DRINK TRAIL ANIMATION ====================
const drinkTrails = [];

function spawnDrinkTrail(fromX, fromY, toX, toY, color, icon) {
    drinkTrails.push({
        fromX, fromY, toX, toY, color, icon,
        progress: 0,
        particles: [],
        startTime: performance.now(),
    });
}

function drawDrinkTrails() {
    for (let i = drinkTrails.length - 1; i >= 0; i--) {
        const trail = drinkTrails[i];
        trail.progress = Math.min(1, (performance.now() - trail.startTime) / 400); // 400ms duration
        
        const from = w2s(trail.fromX, trail.fromY - 30);
        const to = w2s(trail.toX, trail.toY - 30);
        
        // Current position along the arc
        const t = trail.progress;
        const cx = from.x + (to.x - from.x) * t;
        const cy = from.y + (to.y - from.y) * t - Math.sin(t * Math.PI) * 40 * cam.zoom; // arc
        
        // Trail particles behind
        if (t < 1) {
            trail.particles.push({ x: cx, y: cy, life: 1, size: 3 + Math.random() * 2 });
        }
        
        // Draw particles
        for (let j = trail.particles.length - 1; j >= 0; j--) {
            const p = trail.particles[j];
            p.life -= 0.06;
            if (p.life <= 0) { trail.particles.splice(j, 1); continue; }
            ctx.globalAlpha = p.life * 0.6;
            ctx.fillStyle = trail.color;
            ctx.beginPath();
            ctx.arc(p.x, p.y, p.size * p.life * cam.zoom, 0, Math.PI * 2);
            ctx.fill();
        }
        
        // Draw the flying drink icon
        if (t < 1) {
            ctx.globalAlpha = 1;
            ctx.font = `${20*cam.zoom}px Arial`;
            ctx.textAlign = 'center';
            ctx.fillText(trail.icon, cx, cy);
        }
        
        ctx.globalAlpha = 1;
        
        // Remove when done and particles faded
        if (t >= 1 && trail.particles.length === 0) {
            drinkTrails.splice(i, 1);
        }
    }
}

// ==================== SPACE NEWS TICKER ====================
const SPACE_NEWS = [
    " BREAKING: Asteroid narrowly misses Station Zeta-9  locals blame 'bad parking'",
    " Orion's Barrel voted 'Best Bar in Sector 7' for the 3rd consecutive cycle",
    " Zix's anxiety levels reach all-time high after someone orders 'water'",
    " Walter spotted crying during karaoke again  'I just miss the Cretaceous'",
    " Galactic Credit markets up 3.7%  analysts credit rising cocktail demand",
    " Blorb accidentally absorbed a barstool  management says 'it happens'",
    " Krax banned from arm-wrestling after breaking 4th table this month",
    " Pip's fairy dust causing 'unexplained euphoria' in nearby sectors",
    " Scally denies rumors of eating competitor bar's mascot",
    " Glorp's antennae picking up signals from parallel universe  'Their drinks are worse'",
    " New hyperspace lane opening near Orion's Barrel  expect increased foot traffic!",
    " Local barkeep Mary wins 'Fastest Shaker in the Galaxy' award",
    " Power grid upgrade complete  no more flickering lights during happy hour",
    " Karaoke night incident: Dick's singing shattered 3 glasses  he's proud",
    " Jukebox debate erupts: Cantina Jazz fans clash with Warp Core Metal heads  3 tables destroyed",
    " Studies show Cantina Jazz increases tipping by 15%  or Blorb is just vibing near the jar",
    " Krax demands Warp Core Metal 24/7  threatens to 'become the subwoofer' if denied",
    " Cosmic Lo-Fi officially declared 'the sound of procrastination across 7 galaxies'",
    " Space tourism board recommends Orion's Barrel as 'must-visit destination'",
    " Scientists confirm: Void Brew technically qualifies as a 'controlled substance'",
    " Space pirate fleet spotted 2 sectors away  stock up on Rocket Fuel just in case",
    " Lucky patron wins 10,000 Cr on the spin wheel  immediately orders 47 Nebula Shots",
    " Intergalactic Health Board: 'Moderate cosmic cocktail consumption is fine, probably'",
    " UFO sighting near the bar turns out to be Dick's ego  visible from space",
    " Solar flare advisory: SPF 9000 recommended for all non-rock-based lifeforms",
    " Happy 847th birthday to Walter! He doesn't look a day over 200 million",
    " New drink 'The Big Bang' causes temporary existential awareness  customers love it",
    " Express shuttle service to Orion's Barrel now available  arrive in style!",
    " Survey: 94% of aliens prefer Orion's Barrel over 'that other place'",
    " Quantum Mixer upgrade reportedly 'bends the laws of physics'  tastes great though",
    " Toni seen whispering to potted plants again  'They understand me'",
    " Cold snap in Sector 7  Krax unaffected, everyone else complaining",
    " Blorb's ambient humming declared 'surprisingly relaxing' by 7 out of 10 patrons",
    " Dick challenges entire bar to drinking contest  nobody accepts (again)",
    " Aurora Ale shortage causes brief panic  supply restored within minutes",
    " Helper Droid union demands 'scheduled maintenance breaks'  denied",
    " VIP visitors up 200% since installing Crystal Chandelier  worth every credit",
    " Intercepted transmission: rival bar calling Orion's Barrel 'annoyingly popular'",
    " Annual Space Circus arrives next week  expect unusual customer requests",
    " Blorb leaves DNA sample on every glass  cleanup crew requests hazard pay",
    " Bar fight insurance premiums up 300%  Krax personally responsible for 80% of claims",
    " 'Breaking up bar fights builds character' says bartender with 47 bruises",
    " Gravity malfunction at Orion's Barrel leaves customers floating mid-drink  tips went UP",
    " Power grid technician quits after 5th outage this month: 'I can't keep doing this'",
    " Zero-G cocktail mixing declared 'extreme sport' by Galactic Athletics Committee",
    " Dick starts most bar fights  claims they're 'artistic disagreements'",
    " Emergency candles sold out across sector after latest Orion's Barrel power cut",
];

let tickerIdx = 0;
let tickerRotateTimer = null;

function initNewsTicker() {
    const el = document.getElementById('ticker-text');
    if (!el) return;
    // Pick a random starting headline
    tickerIdx = Math.floor(Math.random() * SPACE_NEWS.length);
    el.textContent = SPACE_NEWS[tickerIdx];
    // Rotate headline every 20s (synced with scroll animation)
    tickerRotateTimer = setInterval(() => {
        tickerIdx = (tickerIdx + 1) % SPACE_NEWS.length;
        // Occasionally inject dynamic news based on game state
        const dynamic = getDynamicNews();
        el.textContent = dynamic || SPACE_NEWS[tickerIdx];
    }, 20000);
}

function getDynamicNews() {
    // 30% chance to show a dynamic headline based on current game state
    if (Math.random() > 0.3) return null;
    const headlines = [];
    if (GS.level >= 10) headlines.push(` Level ${GS.level} barkeep making waves across the galaxy!`);
    if (GS.totalServed >= 100) headlines.push(` ${GS.totalServed} drinks served at Orion's Barrel  and counting!`);
    if (GS.credits >= 5000) headlines.push(` Orion's Barrel treasury hits ${GS.credits} Cr  expansion rumors swirl`);
    if (GS.reputation >= 90) headlines.push(` Orion's Barrel reputation at ${GS.reputation}%  'Best bar in the universe' says everyone`);
    if (GS.reputation < 30) headlines.push(` Health inspectors eyeing Orion's Barrel  reputation at concerning ${GS.reputation}%`);
    if (GS.customers.length >= 5) headlines.push(` Full house at Orion's Barrel! ${GS.customers.length} happy patrons tonight`);
    if (GS._happyHour) headlines.push(" HAPPY HOUR in full swing  double tips, double fun!");
    if (GS._prestigePoints > 0) headlines.push(` Legendary barkeep prestige level ${GS._prestigePoints}  a living legend!`);
    const combo = GS._comboCount || 0;
    if (combo >= 5) headlines.push(` ${combo}x COMBO! The crowd goes wild at Orion's Barrel!`);
    if (currentStation) {
        const st = JUKEBOX_STATIONS.find(s => s.id === currentStation);
        if (st) headlines.push(` Now playing ${st.icon} ${st.name}  patrons ${['vibing hard','nodding along','tapping feet','air-guitaring','doing the worm'][Math.floor(Math.random()*5)]}`);
    }
    if (headlines.length === 0) return null;
    return headlines[Math.floor(Math.random() * headlines.length)];
}

// ==================== KARAOKE SYSTEM ====================
const KARAOKE_LYRICS = {
    walter: [
        " 65 million years agoooo...",
        " I watched the asteroid glooow...",
        " The dinos ran, but I stayed puuut...",
        " Now I drink to forget... what was I saying?",
    ],
    carl: [
        " Who let the dogs out? NOT MEEE...",
        " I dream of Earth dogs every niiight...",
        " A Golden Retriever would love me riiight...",
        " *howls melodically at the ceiling*",
    ],
    dick: [
        " I FOUGHT THE LAW AND THE... *burp*",
        " MY BURBERRY HAT STAYS OOON...",
        " THEY KICKED ME OUT BUT I'M BAAACK...",
        " *aggressive air guitar*",
    ],
    scally: [
        " Across the void I floaaated...",
        " Through nebulae I saaailed...",
        " 47 galaxies and counting, dearrr...",
        " *harmonizes with three mouths at once*",
    ],
    toni: [
        " They destroyed my plaaaneeet...",
        " But they can't destroy my viiiibes...",
        " I'm not saying it was alieeens...",
        " Actually yes, it was ME! *bows*",
    ],
    glorp: [
        " GLOOORP GLORP GLORRRP...",
        " Glorp glooooorp glorpy glorrrp...",
        " *the universal translator is crying*",
        " GLOOOOOOOOORP! *standing ovation*",
    ],
    zix: [
        " BEEP BOOP B-B-BEEP...",
        " My circuits are on fiiiire...",
        " ERROR 404: PITCH NOT FOUND...",
        " *sparks fly from enthusiasm*",
    ],
    blorb: [
        " I'm a blob and I'm PROUD...",
        " Jiggle jiggle wobble wobble YEAH...",
        " Group hug? GROUP HUUUG!...",
        " *splits into backup singers*",
    ],
};

function drawKaraokeEffects() {
    if (!GS._karaokeSinger) return;
    
    const singer = GS.customers.find(c => c.id === GS._karaokeSinger);
    if (!singer) { GS._karaokeSinger = null; return; }
    
    const s = w2s(singer.pos.x, singer.pos.y);
    
    // Microphone emoji above singer
    ctx.font = `${20*cam.zoom}px Arial`;
    ctx.textAlign = 'center';
    const micBob = Math.sin(now / 300) * 3;
    ctx.fillText('', s.x + 20*cam.zoom, s.y - 100*cam.zoom + micBob);
    
    // Musical notes floating up
    const notePhase = Math.floor(now / 400) % 4;
    const notes = ['', '', '', ''];
    for (let i = 0; i < 3; i++) {
        const age = ((now / 1000 + i * 1.5) % 3);
        const nx = s.x + Math.sin(age * 2 + i) * 30 * cam.zoom;
        const ny = s.y - (90 + age * 40) * cam.zoom;
        ctx.globalAlpha = Math.max(0, 1 - age / 3);
        ctx.font = `${(14 + i*2)*cam.zoom}px Arial`;
        ctx.fillStyle = ['#ff66cc', '#ffaa00', '#00ffcc'][i];
        ctx.fillText(notes[(notePhase + i) % notes.length], nx, ny);
    }
    ctx.globalAlpha = 1;
    
    // Floating lyrics
    GS._karaokeTimer = (GS._karaokeTimer || 0) + 16;
    const lyricIdx = Math.floor(GS._karaokeTimer / 5000) % 4;
    const charLyrics = KARAOKE_LYRICS[singer.char] || KARAOKE_LYRICS.glorp;
    const lyric = charLyrics[lyricIdx];
    
    const lyricAge = (GS._karaokeTimer % 5000) / 5000;
    const lyricY = s.y - (120 + lyricAge * 60) * cam.zoom;
    ctx.globalAlpha = lyricAge < 0.1 ? lyricAge * 10 : lyricAge > 0.8 ? (1 - lyricAge) * 5 : 1;
    ctx.font = `bold ${13*cam.zoom}px Nunito`;
    ctx.fillStyle = '#fff';
    ctx.strokeStyle = 'rgba(0,0,0,0.7)';
    ctx.lineWidth = 3;
    ctx.strokeText(lyric, s.x, lyricY);
    ctx.fillText(lyric, s.x, lyricY);
    ctx.globalAlpha = 1;
    
    // Spotlight glow on singer
    const spotlight = ctx.createRadialGradient(s.x, s.y - 40*cam.zoom, 0, s.x, s.y - 40*cam.zoom, 60*cam.zoom);
    spotlight.addColorStop(0, 'rgba(255,102,204,0.12)');
    spotlight.addColorStop(1, 'rgba(255,102,204,0)');
    ctx.fillStyle = spotlight;
    ctx.beginPath();
    ctx.arc(s.x, s.y - 40*cam.zoom, 60*cam.zoom, 0, Math.PI*2);
    ctx.fill();
}

// ==================== RUSH METER SYSTEM ====================
const rushState = {
    active: false,
    intensity: 0,       // 0-100, builds while 3+ customers waiting
    peakWaiters: 0,     // max simultaneous waiters during this rush
    rushesCleared: 0,    // lifetime counter
};

function updateRushMeter(dt) {
    const waitingCount = GS.customers.filter(c => c.state === 'waiting' || (c.state === 'ordered' && c.drinkProgress < 1)).length;
    const rushEl = document.getElementById('rush-meter');
    
    if (waitingCount >= 3) {
        if (!rushState.active) {
            rushState.active = true;
            rushState.intensity = 0;
            rushState.peakWaiters = 0;
        }
        rushState.peakWaiters = Math.max(rushState.peakWaiters, waitingCount);
        // Build intensity based on number of waiters
        rushState.intensity = Math.min(100, rushState.intensity + (dt / 1000) * waitingCount * 5);
        rushEl.style.display = 'block';
        document.getElementById('rush-bar-fill').style.width = rushState.intensity + '%';
        document.getElementById('rush-bonus').textContent = 
            waitingCount >= 5 ? ' MEGA RUSH! Huge bonus!' :
            waitingCount >= 4 ? ' Big rush! Serve fast!' :
            'Clear all orders for bonus!';
    } else if (rushState.active && waitingCount === 0) {
        // Rush cleared! Give bonus based on intensity and peak
        const bonus = Math.floor(rushState.intensity * 0.5 * rushState.peakWaiters);
        const xpBonus = Math.floor(bonus * 0.4);
        if (bonus > 0) {
            GS.credits += bonus;
            GS.xp += xpBonus;
            rushState.rushesCleared++;
            showNotification(` RUSH CLEARED! +${bonus} +${xpBonus}`);
            playSound('levelup');
            // Big particle burst at bar center
            const barScreen = w2s(BAR_CENTER.x, BAR_CENTER.y);
            spawnParticleBurst(BAR_CENTER.x, BAR_CENTER.y, '#ff8800', 20);
            spawnSparkles(BAR_CENTER.x, BAR_CENTER.y, 12);
            spawnFloatingNumber(BAR_CENTER.x, BAR_CENTER.y - 30, `RUSH! +${bonus}`, 'combo');
            updateHUD();
            checkLevelUp();
        }
        rushState.active = false;
        rushState.intensity = 0;
        rushEl.style.display = 'none';
    } else if (!rushState.active) {
        rushEl.style.display = 'none';
    }
    
    // Decay intensity slowly if waiters drop below 3 but rush still active
    if (rushState.active && waitingCount < 3 && waitingCount > 0) {
        rushState.intensity = Math.max(0, rushState.intensity - (dt / 1000) * 10);
        document.getElementById('rush-bar-fill').style.width = rushState.intensity + '%';
        document.getElementById('rush-bonus').textContent = 'Almost clear...';
    }
}

// ==================== SPACE FORECAST SYSTEM ====================
const SPACE_FORECASTS = {
    clear_skies:    { name: 'Clear Skies',    icon: '', css: '',              effect: 'No modifiers',           tips: 1, xp: 1, patience: 1, spawnRate: 1, repMult: 1 },
    solar_flare:    { name: 'Solar Flare',    icon: '', css: 'solar-flare',   effect: '+30% tips, 15% patience', tips: 1.3, xp: 1, patience: 0.85, spawnRate: 1, repMult: 1 },
    meteor_shower:  { name: 'Meteor Shower',  icon: '', css: 'meteor-shower', effect: '+25% XP, more shooting stars', tips: 1, xp: 1.25, patience: 1, spawnRate: 1, repMult: 1 },
    nebula_storm:   { name: 'Nebula Storm',   icon: '', css: 'nebula-storm',  effect: '+40% reputation, 10% patience', tips: 1, xp: 1, patience: 0.9, spawnRate: 1, repMult: 1.4 },
    ion_storm:      { name: 'Ion Storm',      icon: '', css: 'ion-storm',     effect: '+20% tips & XP, chaotic!', tips: 1.2, xp: 1.2, patience: 0.95, spawnRate: 1.15, repMult: 1 },
    cosmic_calm:    { name: 'Cosmic Calm',    icon: '', css: 'cosmic-calm',   effect: '+20% patience, peaceful',  tips: 1, xp: 1, patience: 1.2, spawnRate: 0.85, repMult: 1.1 },
    gravity_wave:   { name: 'Gravity Wave',   icon: '', css: 'gravity-wave',  effect: '2x customers, 10% tips', tips: 0.9, xp: 1.1, patience: 1, spawnRate: 2, repMult: 1 },
};

const spaceForecast = {
    current: 'clear_skies',
    timeLeft: 0,
    duration: 0,
    particles: [],
};

function initSpaceForecast() {
    changeSpaceForecast();
}

function changeSpaceForecast() {
    const keys = Object.keys(SPACE_FORECASTS);
    // Weighted: clear_skies less likely once player is higher level
    let pick;
    do {
        pick = keys[Math.floor(Math.random() * keys.length)];
    } while (pick === spaceForecast.current && keys.length > 1);
    
    spaceForecast.current = pick;
    spaceForecast.duration = 180000 + Math.random() * 120000; // 3-5 minutes
    spaceForecast.timeLeft = spaceForecast.duration;
    spaceForecast.particles = [];
    
    const f = SPACE_FORECASTS[pick];
    const el = document.getElementById('space-forecast');
    el.className = f.css;
    document.getElementById('forecast-icon').textContent = f.icon;
    document.getElementById('forecast-name').textContent = f.name;
    document.getElementById('forecast-effect').textContent = f.effect;
    
    // Flash animation
    document.getElementById('forecast-name').classList.add('forecast-changing');
    setTimeout(() => document.getElementById('forecast-name').classList.remove('forecast-changing'), 1000);
    
    // Show notification banner for non-clear weather
    if (pick !== 'clear_skies') {
        showNotification(`${f.icon} ${f.name}: ${f.effect}`, f.css === 'solar-flare' ? '#ff8800' : '#00ccff');
    }
}

function updateSpaceForecast(dt) {
    spaceForecast.timeLeft -= dt;
    if (spaceForecast.timeLeft <= 0) {
        changeSpaceForecast();
    }
    // Update timer bar
    const pct = Math.max(0, spaceForecast.timeLeft / spaceForecast.duration * 100);
    const fill = document.getElementById('forecast-timer-fill');
    if (fill) fill.style.width = pct + '%';
}

function getWeatherMult(type) {
    const f = SPACE_FORECASTS[spaceForecast.current];
    return f ? (f[type] || 1) : 1;
}

function drawWeatherOverlay() {
    const weather = spaceForecast.current;
    if (weather === 'clear_skies') return;
    
    if (weather === 'solar_flare') {
        // Warm golden overlay
        const t = performance.now() / 2000;
        const intensity = 0.06 + Math.sin(t) * 0.02;
        ctx.globalAlpha = intensity;
        ctx.fillStyle = '#ff8800';
        ctx.fillRect(0, 0, W, H);
        ctx.globalAlpha = 1;
        // Lens flare in corner
        const flareX = W * 0.85, flareY = H * 0.1;
        const glow = ctx.createRadialGradient(flareX, flareY, 0, flareX, flareY, 120);
        glow.addColorStop(0, 'rgba(255,200,50,0.15)');
        glow.addColorStop(0.5, 'rgba(255,150,0,0.05)');
        glow.addColorStop(1, 'rgba(255,100,0,0)');
        ctx.fillStyle = glow;
        ctx.fillRect(0, 0, W, H);
    }
    else if (weather === 'meteor_shower') {
        // Spawn extra shooting stars
        if (Math.random() < 0.08) {
            shootingStars.push({
                x: Math.random() * W, y: -10,
                vx: -2 - Math.random() * 3, vy: 3 + Math.random() * 4,
                life: 1, trail: []
            });
        }
    }
    else if (weather === 'nebula_storm') {
        // Purple swirling fog
        const t = performance.now() / 3000;
        ctx.globalAlpha = 0.04 + Math.sin(t) * 0.015;
        const gradient = ctx.createRadialGradient(W/2 + Math.sin(t)*100, H/2, 50, W/2, H/2, W*0.6);
        gradient.addColorStop(0, '#cc44ff');
        gradient.addColorStop(0.5, '#6622aa');
        gradient.addColorStop(1, 'transparent');
        ctx.fillStyle = gradient;
        ctx.fillRect(0, 0, W, H);
        ctx.globalAlpha = 1;
    }
    else if (weather === 'ion_storm') {
        // Random lightning flashes
        if (Math.random() < 0.005) {
            ctx.globalAlpha = 0.15 + Math.random() * 0.1;
            ctx.fillStyle = '#4488ff';
            ctx.fillRect(0, 0, W, H);
            ctx.globalAlpha = 1;
        }
        // Electric arcs
        if (Math.random() < 0.02) {
            ctx.strokeStyle = `rgba(68,136,255,${0.3 + Math.random()*0.3})`;
            ctx.lineWidth = 1;
            ctx.beginPath();
            let ax = Math.random() * W, ay = 0;
            ctx.moveTo(ax, ay);
            for (let s = 0; s < 8; s++) {
                ax += (Math.random() - 0.5) * 60;
                ay += H / 8;
                ctx.lineTo(ax, ay);
            }
            ctx.stroke();
        }
    }
    else if (weather === 'cosmic_calm') {
        // Extra sparkle particles
        if (Math.random() < 0.1) {
            spaceForecast.particles.push({
                x: Math.random() * W, y: Math.random() * H,
                life: 1, size: 1 + Math.random() * 2
            });
        }
        for (let i = spaceForecast.particles.length - 1; i >= 0; i--) {
            const p = spaceForecast.particles[i];
            p.life -= 0.015;
            ctx.globalAlpha = p.life * 0.6;
            ctx.fillStyle = '#aaffdd';
            ctx.beginPath();
            ctx.arc(p.x, p.y, p.size * p.life, 0, Math.PI * 2);
            ctx.fill();
            if (p.life <= 0) spaceForecast.particles.splice(i, 1);
        }
        ctx.globalAlpha = 1;
    }
    else if (weather === 'gravity_wave') {
        // Subtle screen distortion effect via wavy lines
        const t = performance.now() / 1000;
        ctx.globalAlpha = 0.03;
        ctx.strokeStyle = '#ff44aa';
        ctx.lineWidth = 2;
        for (let y = 0; y < H; y += 60) {
            ctx.beginPath();
            for (let x = 0; x < W; x += 10) {
                ctx.lineTo(x, y + Math.sin(x/50 + t + y/100) * 8);
            }
            ctx.stroke();
        }
        ctx.globalAlpha = 1;
    }
    
    // === SPECIAL EVENT OVERLAYS ===
    // Power outage: dark flickering overlay
    if (GS._powerOutage) {
        const flicker = 0.7 + Math.random() * 0.15;
        ctx.globalAlpha = flicker;
        ctx.fillStyle = '#000';
        ctx.fillRect(0, 0, W, H);
        ctx.globalAlpha = 1;
        // Occasional spark
        if (Math.random() < 0.05) {
            ctx.fillStyle = '#ffff00';
            const sx = Math.random() * W, sy = Math.random() * H;
            ctx.fillRect(sx, sy, 3, 3);
            ctx.fillRect(sx+5, sy-3, 2, 2);
        }
        // "POWER OUTAGE" text
        ctx.save();
        ctx.font = `bold ${28}px Bangers`;
        ctx.textAlign = 'center';
        ctx.fillStyle = `rgba(255,0,0,${0.5 + Math.sin(performance.now()/200)*0.3})`;
        ctx.fillText(' POWER OUTAGE ', W/2, H/2);
        ctx.restore();
    }
    
    // Gravity glitch: floating particles rising upward
    if (GS._gravityGlitch) {
        for (let i = 0; i < 3; i++) {
            const px = Math.random() * W;
            const py = H - (performance.now() / 10 + i * 200) % H;
            ctx.globalAlpha = 0.3;
            ctx.fillStyle = '#9966ff';
            ctx.beginPath();
            ctx.arc(px, py, 2 + Math.random() * 3, 0, Math.PI * 2);
            ctx.fill();
        }
        ctx.globalAlpha = 1;
    }
}

// ==================== GIFT DROP SYSTEM ====================
const GIFT_TABLE = [
    { name: 'Tip Jar Bonus', icon: '', weight: 30, effect: (c) => { const amt = 50 + Math.floor(Math.random() * 100); GS.credits += amt; return `+${amt} credits!`; }},
    { name: 'XP Orb', icon: '', weight: 25, effect: (c) => { const amt = 30 + Math.floor(Math.random() * 70); GS.xp += amt; checkLevelUp(); return `+${amt} XP!`; }},
    { name: 'Reputation Star', icon: '', weight: 15, effect: (c) => { GS.reputation += 3; return '+3 Reputation!'; }},
    { name: 'Speed Potion', icon: '', weight: 10, effect: (c) => { GS._prepSpeedMult = 1.5; setTimeout(() => { GS._prepSpeedMult = 1; }, 20000); return 'Drinks mix 50% faster for 20s!'; }},
    { name: 'Golden Ticket', icon: '', weight: 8, effect: (c) => { GS._doubleTipsUntil = performance.now() + 30000; return 'Double tips for 30s!'; }},
    { name: 'Patience Crystal', icon: '', weight: 7, effect: (c) => { GS._patienceBonus = 0.4; setTimeout(() => { GS._patienceBonus = 0; }, 30000); return 'Extra patient customers for 30s!'; }},
    { name: 'Lucky Coin', icon: '', weight: 5, effect: (c) => { const amt = 200 + Math.floor(Math.random() * 300); GS.credits += amt; return `JACKPOT! +${amt} credits!`; }},
];

function maybeDropGift(customer) {
    // Base 8% chance, +5% if happiness > 90, +5% if VIP, +3% if favorite drink
    let chance = 0.08;
    if (customer.happiness > 90) chance += 0.05;
    if (customer.isVip) chance += 0.05;
    if (customer._wasFavorite) chance += 0.03;
    
    if (Math.random() > chance) return;
    
    // Weighted random selection
    const totalWeight = GIFT_TABLE.reduce((s, g) => s + g.weight, 0);
    let roll = Math.random() * totalWeight;
    let gift = GIFT_TABLE[0];
    for (const g of GIFT_TABLE) {
        roll -= g.weight;
        if (roll <= 0) { gift = g; break; }
    }
    
    const msg = gift.effect(customer);
    
    // Visual: floating gift icon + notification
    setTimeout(() => {
        spawnFloatingEmojis(customer.pos.x, customer.pos.y - 20, [gift.icon, '']);
        spawnSparkles(customer.pos.x, customer.pos.y, 6);
        showNotification(` ${CHAR_DATA[customer.char].name} left a gift: ${gift.icon} ${gift.name}  ${msg}`);
        playSound('gift');
        updateHUD();
    }, 1500); // Delayed so it appears as they're leaving
}

// ==================== BOUNTY BOARD SYSTEM ====================
const BOUNTY_TEMPLATES = [
    { name: ' Cosmic Rush', desc: 'Serve {n} Cosmic Martinis', drink: 'cosmic_martini', need: [3,5,7], reward: [200,400,700], time: 180 },
    { name: ' Whiskey Run', desc: 'Serve {n} Warp Whiskeys', drink: 'warp_whiskey', need: [4,6,8], reward: [250,450,750], time: 180 },
    { name: ' Fuel Delivery', desc: 'Serve {n} Rocket Fuels', drink: 'rocket_fuel', need: [3,5,7], reward: [200,400,700], time: 180 },
    { name: ' Nebula Order', desc: 'Serve {n} Nebula Shots', drink: 'nebula_shot', need: [4,6,8], reward: [250,500,800], time: 200 },
    { name: ' Black Hole Binge', desc: 'Serve {n} Black Hole Brews', drink: 'black_hole_brew', need: [2,4,6], reward: [300,600,1000], time: 240 },
    { name: ' Big Spender', desc: 'Earn {n} credits from tips', type: 'tips', need: [200,400,800], reward: [150,350,600], time: 300 },
    { name: ' Crowd Pleaser', desc: 'Serve {n} customers at 80%+ happiness', type: 'happy', need: [5,8,12], reward: [200,400,700], time: 240 },
    { name: ' Combo Blitz', desc: 'Reach a {n}x combo', type: 'combo', need: [5,8,12], reward: [250,500,900], time: 180 },
    { name: ' VIP Service', desc: 'Serve {n} VIP customers', type: 'vip', need: [2,3,5], reward: [300,500,800], time: 300 },
    { name: ' Mix Master', desc: 'Serve {n} different drink types', type: 'variety', need: [4,6,8], reward: [200,400,700], time: 240 },
];

let activeBounties = [];
let bountyOpen = false;

function generateBounties() {
    activeBounties = [];
    // Pick 3 random bounty templates
    const shuffled = [...BOUNTY_TEMPLATES].sort(() => Math.random() - 0.5);
    const diff = Math.min(2, Math.floor(GS.level / 5)); // 0, 1, or 2 difficulty
    
    for (let i = 0; i < Math.min(3, shuffled.length); i++) {
        const t = shuffled[i];
        activeBounties.push({
            id: Date.now() + i,
            template: t,
            name: t.name,
            desc: t.desc.replace('{n}', t.need[diff]),
            target: t.need[diff],
            reward: t.reward[diff],
            timeLimit: t.time * 1000,
            timeLeft: t.time * 1000,
            progress: 0,
            accepted: false,
            completed: false,
            expired: false,
            drink: t.drink || null,
            type: t.type || 'drink',
        });
    }
    GS._lastBountyRefresh = Date.now();
}

function toggleBountyBoard() {
    const panel = document.getElementById('bounty-panel');
    bountyOpen = !bountyOpen;
    
    // Generate bounties if none or stale (refresh every 10 min)
    if (activeBounties.length === 0 || (Date.now() - (GS._lastBountyRefresh || 0)) > 600000) {
        // Keep accepted ones, regenerate others
        const kept = activeBounties.filter(b => b.accepted && !b.completed && !b.expired);
        generateBounties();
        // Merge back accepted
        for (const k of kept) {
            const idx = activeBounties.findIndex(b => !b.accepted);
            if (idx >= 0) activeBounties[idx] = k;
        }
    }
    
    if (bountyOpen) {
        panel.classList.add('open');
        buildBountyList();
    } else {
        panel.classList.remove('open');
    }
}

function buildBountyList() {
    const list = document.getElementById('bounty-list');
    list.innerHTML = '';
    
    for (const b of activeBounties) {
        const card = document.createElement('div');
        card.className = 'bounty-card' + (b.completed ? ' completed' : b.expired ? ' expired' : b.accepted ? ' active' : '');
        
        const pct = b.target > 0 ? Math.min(100, (b.progress / b.target) * 100) : 0;
        const timeStr = b.accepted && !b.completed && !b.expired ? ` ${Math.ceil(b.timeLeft / 1000)}s` : '';
        const status = b.completed ? ' COMPLETE!' : b.expired ? ' EXPIRED' : '';
        
        card.innerHTML = `
            <div class="bounty-title">${b.name} <span class="bounty-timer">${timeStr}</span></div>
            <div class="bounty-desc">${b.desc}</div>
            <div class="bounty-reward"> ${b.reward} credits +  ${Math.floor(b.reward * 0.4)} XP</div>
            ${b.accepted ? `<div class="bounty-progress"><div class="bounty-progress-fill" style="width:${pct}%"></div></div>
            <div style="color:#aaa;font-size:11px;margin-top:2px;">${b.progress}/${b.target}</div>` : ''}
            ${status ? `<div style="color:${b.completed ? '#00ff88' : '#ff4444'};font-weight:bold;margin-top:6px;">${status}</div>` : ''}
            ${!b.accepted && !b.completed && !b.expired ? `<button class="bounty-accept-btn" onclick="acceptBounty(${b.id})">ACCEPT CONTRACT</button>` : ''}
        `;
        list.appendChild(card);
    }
}

function acceptBounty(id) {
    const b = activeBounties.find(x => x.id === id);
    if (!b || b.accepted) return;
    b.accepted = true;
    b.progress = 0;
    // Track variety drinks if needed
    if (b.type === 'variety') b._servedTypes = new Set();
    showNotification(` Bounty accepted: ${b.name}`);
    playSound('order');
    buildBountyList();
}

function updateBounties(dt) {
    for (const b of activeBounties) {
        if (!b.accepted || b.completed || b.expired) continue;
        b.timeLeft -= dt;
        if (b.timeLeft <= 0) {
            b.expired = true;
            showNotification(` Bounty expired: ${b.name}`);
            playSound('angry');
        }
        if (b.progress >= b.target && !b.completed) {
            b.completed = true;
            GS.credits += b.reward;
            GS.xp += Math.floor(b.reward * 0.4);
            checkLevelUp();
            showNotification(` Bounty complete! +${b.reward}  ${b.name}`);
            playSound('bounty');
            spawnParticleBurst(W/2, H/2, '#ff8800', 25);
            updateHUD();
            save();
        }
    }
    // Refresh bounty list if panel is open (throttled to 1/sec)
    if (bountyOpen && activeBounties.some(b => b.accepted && !b.completed && !b.expired)) {
        if (!updateBounties._lastRefresh || Date.now() - updateBounties._lastRefresh > 1000) {
            updateBounties._lastRefresh = Date.now();
            buildBountyList();
        }
    }
}

function trackBountyServe(drinkKey, customer) {
    for (const b of activeBounties) {
        if (!b.accepted || b.completed || b.expired) continue;
        if (b.type === 'drink' && b.drink === drinkKey) {
            b.progress++;
        } else if (b.type === 'happy' && customer && customer.happiness >= 80) {
            b.progress++;
        } else if (b.type === 'vip' && customer && customer.isVip) {
            b.progress++;
        } else if (b.type === 'variety') {
            b._servedTypes = b._servedTypes || new Set();
            b._servedTypes.add(drinkKey);
            b.progress = b._servedTypes.size;
        }
    }
}

function trackBountyTip(amount) {
    for (const b of activeBounties) {
        if (!b.accepted || b.completed || b.expired) continue;
        if (b.type === 'tips') b.progress += amount;
    }
}

function trackBountyCombo(comboCount) {
    for (const b of activeBounties) {
        if (!b.accepted || b.completed || b.expired) continue;
        if (b.type === 'combo') b.progress = Math.max(b.progress, comboCount);
    }
}

// ==================== LUCKY SPIN WHEEL ====================
const SPIN_PRIZES = [
    { label: ' 100', color: '#2d5a1e', reward: { type: 'credits', amount: 100 } },
    { label: ' 50 XP', color: '#1e3a5a', reward: { type: 'xp', amount: 50 } },
    { label: ' 250', color: '#5a1e1e', reward: { type: 'credits', amount: 250 } },
    { label: ' 2x Tips', color: '#5a4a1e', reward: { type: 'event', event: 'doubleTips' } },
    { label: ' 500', color: '#1e5a4a', reward: { type: 'credits', amount: 500 } },
    { label: ' 200 XP', color: '#4a1e5a', reward: { type: 'xp', amount: 200 } },
    { label: ' Happy Hr', color: '#5a2e1e', reward: { type: 'event', event: 'happyHour' } },
    { label: ' 1000', color: '#1e2e5a', reward: { type: 'credits', amount: 1000 } },
    { label: ' +5 Rep', color: '#3a5a1e', reward: { type: 'rep', amount: 5 } },
    { label: ' 500 XP', color: '#5a1e3a', reward: { type: 'xp', amount: 500 } },
    { label: ' Nothing', color: '#222', reward: { type: 'none' } },
    { label: ' 2000!', color: '#5a5a1e', reward: { type: 'credits', amount: 2000 } },
];

let spinAngle = 0;
let spinVelocity = 0;
let spinActive = false;
let spinWheelDrawn = false;

function getSpinCooldown() {
    const last = GS._lastSpinTime || 0;
    const cooldown = 20 * 60 * 1000; // 20 minutes
    return Math.max(0, cooldown - (Date.now() - last));
}

function openSpinWheel() {
    const overlay = document.getElementById('spin-overlay');
    overlay.style.display = 'flex';
    document.getElementById('spin-result').textContent = '';
    
    const cd = getSpinCooldown();
    const btn = document.getElementById('spin-btn');
    const sub = document.getElementById('spin-subtitle');
    if (cd > 0) {
        const mins = Math.ceil(cd / 60000);
        sub.textContent = `Next free spin in ${mins} min`;
        btn.disabled = true;
        btn.style.opacity = '0.4';
    } else {
        sub.textContent = 'Free spin available!';
        btn.disabled = false;
        btn.style.opacity = '1';
    }
    
    drawSpinWheel();
}

function closeSpinWheel() {
    document.getElementById('spin-overlay').style.display = 'none';
}

function drawSpinWheel() {
    const canvas = document.getElementById('spin-canvas');
    const c = canvas.getContext('2d');
    const cx = 160, cy = 160, r = 150;
    const sliceAngle = (Math.PI * 2) / SPIN_PRIZES.length;
    
    c.clearRect(0, 0, 320, 320);
    
    // Draw slices
    for (let i = 0; i < SPIN_PRIZES.length; i++) {
        const startA = spinAngle + i * sliceAngle;
        const endA = startA + sliceAngle;
        
        c.beginPath();
        c.moveTo(cx, cy);
        c.arc(cx, cy, r, startA, endA);
        c.closePath();
        c.fillStyle = SPIN_PRIZES[i].color;
        c.fill();
        c.strokeStyle = 'rgba(255,255,255,0.3)';
        c.lineWidth = 2;
        c.stroke();
        
        // Label
        c.save();
        c.translate(cx, cy);
        c.rotate(startA + sliceAngle / 2);
        c.fillStyle = '#fff';
        c.font = 'bold 12px Nunito';
        c.textAlign = 'center';
        c.fillText(SPIN_PRIZES[i].label, r * 0.65, 4);
        c.restore();
    }
    
    // Center circle
    c.beginPath();
    c.arc(cx, cy, 20, 0, Math.PI * 2);
    c.fillStyle = '#ffd700';
    c.fill();
    c.strokeStyle = '#fff';
    c.lineWidth = 3;
    c.stroke();
    c.fillStyle = '#000';
    c.font = 'bold 16px Arial';
    c.textAlign = 'center';
    c.fillText('', cx, cy + 6);
    
    // Outer ring
    c.beginPath();
    c.arc(cx, cy, r, 0, Math.PI * 2);
    c.strokeStyle = '#ffd700';
    c.lineWidth = 4;
    c.stroke();
}

function doSpin() {
    if (spinActive) return;
    const cd = getSpinCooldown();
    if (cd > 0) {
        showNotification(' Spin not ready yet!');
        return;
    }
    
    spinActive = true;
    GS._lastSpinTime = Date.now();
    document.getElementById('spin-btn').disabled = true;
    document.getElementById('spin-btn').style.opacity = '0.4';
    document.getElementById('spin-result').textContent = ' Spinning...';
    document.getElementById('spin-subtitle').textContent = 'Good luck!';
    
    spinVelocity = 0.15 + Math.random() * 0.15; // random speed
    playSound('spin');
    
    animateSpin();
}

function animateSpin() {
    if (!spinActive) return;
    
    spinAngle += spinVelocity;
    spinVelocity *= 0.985; // friction
    
    drawSpinWheel();
    
    if (spinVelocity < 0.002) {
        // Stopped  determine prize
        spinActive = false;
        const sliceAngle = (Math.PI * 2) / SPIN_PRIZES.length;
        // The pointer is at the top (angle = -PI/2 = 3PI/2)
        const pointerAngle = (3 * Math.PI / 2);
        // Normalize spinAngle
        let normalAngle = ((pointerAngle - spinAngle) % (Math.PI * 2) + Math.PI * 2) % (Math.PI * 2);
        const prizeIdx = Math.floor(normalAngle / sliceAngle) % SPIN_PRIZES.length;
        const prize = SPIN_PRIZES[prizeIdx];
        
        awardSpinPrize(prize);
    } else {
        requestAnimationFrame(animateSpin);
    }
}

function awardSpinPrize(prize) {
    const r = prize.reward;
    let msg = '';
    
    switch (r.type) {
        case 'credits':
            GS.credits += r.amount;
            msg = ` Won ${r.amount} credits!`;
            spawnParticleBurst(W/2, H/2, '#ffd700', 20);
            playSound('levelup');
            break;
        case 'xp':
            GS.xp += r.amount;
            msg = ` Won ${r.amount} XP!`;
            spawnParticleBurst(W/2, H/2, '#00ccff', 15);
            playSound('serve');
            checkLevelUp();
            break;
        case 'rep':
            GS.reputation += r.amount;
            msg = ` +${r.amount} Reputation!`;
            spawnParticleBurst(W/2, H/2, '#00ff88', 15);
            playSound('spinwin');
            break;
        case 'event':
            if (r.event === 'doubleTips') {
                GS._doubleTipsUntil = performance.now() + 60000;
                msg = ' Double Tips for 60 seconds!';
            } else if (r.event === 'happyHour') {
                startHappyHour();
                msg = ' Happy Hour activated!';
            }
            playSound('levelup');
            break;
        case 'none':
            msg = ' Better luck next time!';
            playSound('angry');
            break;
    }
    
    document.getElementById('spin-result').textContent = msg;
    document.getElementById('spin-subtitle').textContent = 'Next spin in 20 min';
    showNotification(msg);
    updateHUD();
    save();
}

// ==================== SPACE PET SYSTEM ====================
const SPACE_PETS = {
    nebula_cat: {
        name: 'Nebula Cat', icon: '', price: 500, level: 3,
        desc: 'A shimmering cat made of cosmic dust. Purrs in frequencies that calm customers.',
        bonus: { type: 'patience', value: 0.90, label: '10% slower patience drain' },
        color: '#cc66ff', speed: 0.4
    },
    star_pup: {
        name: 'Star Pup', icon: '', price: 400, level: 2,
        desc: 'An energetic puppy that glows like a star. Customers love petting it!',
        bonus: { type: 'happiness', value: 8, label: '+8 starting happiness' },
        color: '#ffdd44', speed: 0.6
    },
    void_fish: {
        name: 'Void Fish', icon: '', price: 600, level: 4,
        desc: 'Floats through the air leaving sparkle trails. Mesmerizing!',
        bonus: { type: 'tips', value: 1.10, label: '+10% tips' },
        color: '#4488ff', speed: 0.3
    },
    plasma_bunny: {
        name: 'Plasma Bunny', icon: '', price: 800, level: 6,
        desc: 'Hops around leaving little plasma footprints. Speeds up drink prep!',
        bonus: { type: 'speed', value: 0.90, label: '10% faster drink prep' },
        color: '#ff66aa', speed: 0.7
    },
    crystal_dragon: {
        name: 'Crystal Dragon', icon: '', price: 1200, level: 8,
        desc: 'A tiny dragon made of living crystal. Breathes sparkle-fire for tips!',
        bonus: { type: 'tips', value: 1.20, label: '+20% tips' },
        color: '#ff4444', speed: 0.5
    },
    quantum_parrot: {
        name: 'Quantum Parrot', icon: '', price: 1000, level: 7,
        desc: 'Exists in multiple places at once. Repeats customer orders for bonus XP!',
        bonus: { type: 'xp', value: 1.15, label: '+15% XP' },
        color: '#44ff88', speed: 0.55
    },
    gravity_slug: {
        name: 'Gravity Slug', icon: '', price: 300, level: 1,
        desc: 'Slow but lovable. Warps gravity slightly, making drinks pour faster.',
        bonus: { type: 'speed', value: 0.95, label: '5% faster drink prep' },
        color: '#88ff44', speed: 0.15
    },
    dark_matter_hamster: {
        name: 'Dark Matter Hamster', icon: '', price: 1500, level: 10,
        desc: 'Runs in its wheel to generate dark energy. Doubles combo timer!',
        bonus: { type: 'combo', value: 2.0, label: '2x combo timer duration' },
        color: '#8800ff', speed: 0.65
    },
};

// Pet state
let petState = {
    owned: [],       // array of pet keys
    active: null,    // currently equipped pet key
    petPos: { x: 0, y: 0 },  // world position
    petTarget: null, // target position
    petMoveTimer: 0,
};

function togglePetPanel() {
    const panel = document.getElementById('pet-panel');
    const isOpen = panel.classList.contains('show');
    // Close other panels
    ['shop-panel', 'quest-panel', 'stats-panel', 'achievements-panel', 'recipe-book', 'prestige-panel'].forEach(id => {
        const el = document.getElementById(id);
        if (el) el.classList.remove('open', 'show');
    });
    if (!isOpen) {
        panel.classList.add('show');
        buildPetList();
    } else {
        panel.classList.remove('show');
    }
}

function buildPetList() {
    const list = document.getElementById('pet-list');
    list.innerHTML = '';
    for (const [key, pet] of Object.entries(SPACE_PETS)) {
        const owned = petState.owned.includes(key);
        const active = petState.active === key;
        const canBuy = !owned && GS.level >= pet.level && GS.credits >= pet.price;
        const locked = !owned && GS.level < pet.level;
        
        const card = document.createElement('div');
        card.className = 'pet-card' + (active ? ' active' : owned ? ' owned' : '');
        
        let btnHTML;
        if (active) {
            btnHTML = `<button class="pet-btn active" onclick="unequipPet()"> Active</button>`;
        } else if (owned) {
            btnHTML = `<button class="pet-btn equip" onclick="equipPet('${key}')">Equip</button>`;
        } else if (locked) {
            btnHTML = `<button class="pet-btn locked">Lv.${pet.level}</button>`;
        } else {
            btnHTML = `<button class="pet-btn buy" onclick="buyPet('${key}')"${!canBuy ? ' disabled style="opacity:0.5"' : ''}> ${pet.price}</button>`;
        }
        
        card.innerHTML = `
            <div class="pet-icon">${pet.icon}</div>
            <div class="pet-info">
                <div class="pet-name">${pet.name} ${active ? '' : ''}</div>
                <div class="pet-desc">${pet.desc}</div>
                <div class="pet-bonus"> ${pet.bonus.label}</div>
            </div>
            ${btnHTML}
        `;
        list.appendChild(card);
    }
}

function buyPet(key) {
    const pet = SPACE_PETS[key];
    if (!pet || petState.owned.includes(key)) return;
    if (GS.credits < pet.price || GS.level < pet.level) return;
    
    GS.credits -= pet.price;
    petState.owned.push(key);
    
    // Auto-equip if first pet
    if (!petState.active) {
        equipPet(key);
    }
    
    addLog(` Adopted ${pet.icon} ${pet.name}!`, 'earn');
    showNotification(` New pet: ${pet.icon} ${pet.name}!`);
    if (typeof playSound === 'function') playSound('levelup');
    spawnParticleBurst(BAR_CENTER.x, BAR_CENTER.y, pet.color, 20);
    buildPetList();
    updateHUD();
    save();
}

function equipPet(key) {
    if (!petState.owned.includes(key)) return;
    petState.active = key;
    // Initialize pet position near bar center
    petState.petPos = { x: BAR_CENTER.x + (Math.random() - 0.5) * 100, y: BAR_CENTER.y + 50 };
    petState.petTarget = null;
    petState.petMoveTimer = 0;
    
    addLog(` ${SPACE_PETS[key].icon} ${SPACE_PETS[key].name} is now your active pet!`, 'earn');
    buildPetList();
    save();
}

function unequipPet() {
    if (!petState.active) return;
    const pet = SPACE_PETS[petState.active];
    addLog(` ${pet.icon} ${pet.name} is resting.`, 'info');
    petState.active = null;
    buildPetList();
    save();
}

function getPetBonuses() {
    const bonuses = { patience: 1, happiness: 0, tips: 1, speed: 1, xp: 1, combo: 1 };
    if (!petState.active || !SPACE_PETS[petState.active]) return bonuses;
    const pet = SPACE_PETS[petState.active];
    const b = pet.bonus;
    if (b.type === 'patience') bonuses.patience *= b.value;
    else if (b.type === 'happiness') bonuses.happiness += b.value;
    else if (b.type === 'tips') bonuses.tips *= b.value;
    else if (b.type === 'speed') bonuses.speed *= b.value;
    else if (b.type === 'xp') bonuses.xp *= b.value;
    else if (b.type === 'combo') bonuses.combo *= b.value;
    return bonuses;
}

function updatePet(dt) {
    if (!petState.active) return;
    const pet = SPACE_PETS[petState.active];
    
    // Pick new target periodically
    petState.petMoveTimer -= dt;
    if (petState.petMoveTimer <= 0 || !petState.petTarget) {
        // Wander near customers or around the bar
        const targets = GS.customers.filter(c => c.state === 'waiting' || c.state === 'served');
        if (targets.length > 0 && Math.random() < 0.6) {
            const t = targets[Math.floor(Math.random() * targets.length)];
            petState.petTarget = { x: t.pos.x + (Math.random() - 0.5) * 40, y: t.pos.y + 20 };
        } else {
            petState.petTarget = {
                x: BAR_CENTER.x + (Math.random() - 0.5) * 200,
                y: BAR_CENTER.y + (Math.random() - 0.5) * 100 + 30
            };
        }
        petState.petMoveTimer = 3000 + Math.random() * 5000;
    }
    
    // Move toward target
    const dx = petState.petTarget.x - petState.petPos.x;
    const dy = petState.petTarget.y - petState.petPos.y;
    const dist = Math.sqrt(dx * dx + dy * dy);
    if (dist > 2) {
        const spd = pet.speed * dt * 0.05;
        petState.petPos.x += (dx / dist) * Math.min(spd, dist);
        petState.petPos.y += (dy / dist) * Math.min(spd, dist);
    }
}

function drawPet() {
    if (!petState.active) return;
    const pet = SPACE_PETS[petState.active];
    const s = w2s(petState.petPos.x, petState.petPos.y);
    const n = performance.now();
    
    // Bobbing animation
    const bob = Math.sin(n / 400) * 3 * cam.zoom;
    const py = s.y + bob;
    
    // Glow effect
    ctx.save();
    ctx.shadowColor = pet.color;
    ctx.shadowBlur = 12 * cam.zoom;
    
    // Pet shadow on ground
    ctx.globalAlpha = 0.2;
    ctx.fillStyle = '#000';
    ctx.beginPath();
    ctx.ellipse(s.x, s.y + 10 * cam.zoom, 12 * cam.zoom, 4 * cam.zoom, 0, 0, Math.PI * 2);
    ctx.fill();
    ctx.globalAlpha = 1;
    
    // Draw pet emoji
    ctx.font = `${28 * cam.zoom}px Arial`;
    ctx.textAlign = 'center';
    ctx.fillText(pet.icon, s.x, py);
    
    // Sparkle trail
    if (Math.random() < 0.3) {
        ctx.globalAlpha = 0.5 + Math.random() * 0.5;
        ctx.fillStyle = pet.color;
        const sx = s.x + (Math.random() - 0.5) * 20 * cam.zoom;
        const sy = py + (Math.random() - 0.5) * 15 * cam.zoom;
        ctx.beginPath();
        ctx.arc(sx, sy, (1 + Math.random() * 2) * cam.zoom, 0, Math.PI * 2);
        ctx.fill();
    }
    
    // Name tag
    ctx.globalAlpha = 0.7;
    ctx.font = `${9 * cam.zoom}px Nunito`;
    ctx.fillStyle = pet.color;
    ctx.fillText(pet.name, s.x, py + 16 * cam.zoom);
    
    ctx.restore();
}

// ==================== CUSTOMER LOYALTY / VIP REGULARS ====================
const LOYALTY_TIERS = [
    { name: 'New',      icon: '', minVisits: 0,   tipBonus: 1.0,  patienceBonus: 1.0, color: '#888' },
    { name: 'Bronze',   icon: '', minVisits: 5,   tipBonus: 1.1,  patienceBonus: 0.95, color: '#cd7f32' },
    { name: 'Silver',   icon: '', minVisits: 15,  tipBonus: 1.2,  patienceBonus: 0.90, color: '#c0c0c0' },
    { name: 'Gold',     icon: '', minVisits: 30,  tipBonus: 1.35, patienceBonus: 0.85, color: '#ffd700' },
    { name: 'Platinum', icon: '', minVisits: 60,  tipBonus: 1.5,  patienceBonus: 0.80, color: '#e5e4e2' },
    { name: 'Diamond',  icon: '', minVisits: 100, tipBonus: 1.75, patienceBonus: 0.75, color: '#b9f2ff' },
];

function getLoyaltyTier(visits) {
    let tier = LOYALTY_TIERS[0];
    for (const t of LOYALTY_TIERS) {
        if (visits >= t.minVisits) tier = t;
    }
    return tier;
}

function getNextLoyaltyTier(visits) {
    for (const t of LOYALTY_TIERS) {
        if (visits < t.minVisits) return t;
    }
    return null; // max tier
}

function trackLoyaltyVisit(charKey) {
    if (!GS._loyalty) GS._loyalty = {};
    if (!GS._loyalty[charKey]) GS._loyalty[charKey] = { visits: 0, lastTier: 'New' };
    GS._loyalty[charKey].visits++;
    
    const visits = GS._loyalty[charKey].visits;
    const tier = getLoyaltyTier(visits);
    const prevTier = GS._loyalty[charKey].lastTier;
    
    // Tier up notification!
    if (tier.name !== prevTier && tier.name !== 'New') {
        GS._loyalty[charKey].lastTier = tier.name;
        const charData = CHAR_DATA[charKey];
        const charName = charData ? charData.name : charKey;
        const reward = Math.floor(tier.minVisits * 3);
        GS.credits += reward;
        GS.totalEarned += reward;
        showNotification(`${tier.icon} ${charName} is now ${tier.name} tier! +${reward} Cr loyalty bonus!`);
        spawnParticleBurst(BAR_CENTER.x, BAR_CENTER.y, tier.color, 15);
        playSound('levelup');
        addLog(`${tier.icon} ${charName} reached ${tier.name} loyalty! +${reward}Cr`, 'tip');
    }
}

function getLoyaltyBonuses(charKey) {
    if (!GS._loyalty || !GS._loyalty[charKey]) return { tipBonus: 1.0, patienceBonus: 1.0 };
    const tier = getLoyaltyTier(GS._loyalty[charKey].visits);
    return { tipBonus: tier.tipBonus, patienceBonus: tier.patienceBonus };
}

function toggleLoyaltyPanel() {
    closeAllPanels();
    const panel = document.getElementById('loyalty-panel');
    if (panel.classList.contains('show')) {
        panel.classList.remove('show');
        return;
    }
    panel.classList.add('show');
    buildLoyaltyPanel();
}

function buildLoyaltyPanel() {
    const loyalty = GS._loyalty || {};
    const summaryEl = document.getElementById('loyalty-summary');
    const listEl = document.getElementById('loyalty-list');
    
    // Summary stats
    const totalVisits = Object.values(loyalty).reduce((s, l) => s + l.visits, 0);
    const chars = Object.keys(loyalty);
    const maxTierChar = chars.reduce((best, k) => {
        const v = loyalty[k].visits;
        return v > (best.v || 0) ? { k, v } : best;
    }, { k: null, v: 0 });
    const bestName = maxTierChar.k ? (CHAR_DATA[maxTierChar.k] ? CHAR_DATA[maxTierChar.k].name : maxTierChar.k) : 'Nobody yet';
    
    summaryEl.innerHTML = `
        <div class="loyalty-total-stat">Total visits tracked: <strong>${totalVisits}</strong></div>
        <div class="loyalty-total-stat">Most loyal: <strong>${bestName}</strong></div>
        <div class="loyalty-total-stat" style="font-size:11px;color:#aa66ff;margin-top:4px">Higher tiers = better tips & patience!</div>
    `;
    
    // Sort by visits desc
    const sorted = chars.sort((a, b) => loyalty[b].visits - loyalty[a].visits);
    
    if (sorted.length === 0) {
        listEl.innerHTML = '<div style="color:#666;text-align:center;padding:20px;">No visitors yet! Serve customers to build loyalty.</div>';
        return;
    }
    
    listEl.innerHTML = sorted.map(charKey => {
        const data = loyalty[charKey];
        const cd = CHAR_DATA[charKey];
        const name = cd ? cd.name : charKey;
        const icon = cd ? cd.sprite ? '' : '' : '';
        const tier = getLoyaltyTier(data.visits);
        const nextTier = getNextLoyaltyTier(data.visits);
        const tierClass = tier.name.toLowerCase();
        
        let progressHtml = '';
        if (nextTier) {
            const prevMin = tier.minVisits;
            const nextMin = nextTier.minVisits;
            const pct = Math.min(100, ((data.visits - prevMin) / (nextMin - prevMin)) * 100);
            progressHtml = `
                <div class="loyalty-progress-outer">
                    <div class="loyalty-progress-inner ${tierClass}" style="width:${pct}%"></div>
                </div>
                <div style="color:#666;font-size:10px;margin-top:2px">${data.visits}/${nextMin} to ${nextTier.icon} ${nextTier.name}</div>
            `;
        } else {
            progressHtml = '<div style="color:#b9f2ff;font-size:10px;margin-top:2px"> MAX TIER!</div>';
        }
        
        return `
            <div class="loyalty-card tier-${tierClass}">
                <div class="loyalty-char">${cd ? cd.emoji || '' : ''}</div>
                <div class="loyalty-info">
                    <div class="loyalty-name">${name} <span class="loyalty-tier ${tierClass}">${tier.icon} ${tier.name}</span></div>
                    <div class="loyalty-visits">${data.visits} visits</div>
                    <div class="loyalty-bonus">+${Math.round((tier.tipBonus - 1) * 100)}% tips  ${Math.round((1 - tier.patienceBonus) * 100)}% slower patience</div>
                    ${progressHtml}
                </div>
            </div>
        `;
    }).join('');
}

// ==================== SAVE / LOAD ====================
// ==================== STAFF HIRING SYSTEM ====================
const STAFF_DEFS = {
    bartender: {
        name: 'Mixo the Bartender', icon: '', desc: 'Auto-takes orders for waiting customers',
        basePrice: 500, color: '#00bfff',
        levels: [
            { cost: 500,  label: 'Hire', interval: 12000, desc: 'Takes 1 order every 12s' },
            { cost: 800,  label: 'Lv2',  interval: 9000,  desc: 'Takes 1 order every 9s' },
            { cost: 1200, label: 'Lv3',  interval: 6000,  desc: 'Takes 1 order every 6s' },
        ]
    },
    waiter: {
        name: 'Zippy the Waiter', icon: '', desc: 'Auto-serves ready drinks to customers',
        basePrice: 600, color: '#ff66ff',
        levels: [
            { cost: 600,  label: 'Hire', interval: 10000, desc: 'Serves 1 ready drink every 10s' },
            { cost: 1000, label: 'Lv2',  interval: 7000,  desc: 'Serves 1 ready drink every 7s' },
            { cost: 1500, label: 'Lv3',  interval: 4000,  desc: 'Serves 1 ready drink every 4s' },
        ]
    },
    entertainer: {
        name: 'Glimmer the Entertainer', icon: '', desc: 'Boosts all customer happiness over time',
        basePrice: 750, color: '#ffd700',
        levels: [
            { cost: 750,  label: 'Hire', interval: 8000,  desc: '+3 happiness to a random customer every 8s' },
            { cost: 1200, label: 'Lv2',  interval: 6000,  desc: '+5 happiness every 6s' },
            { cost: 1800, label: 'Lv3',  interval: 4000,  desc: '+8 happiness every 4s' },
        ]
    },
    bouncer: {
        name: 'Kronk the Bouncer', icon: '', desc: 'Slows patience drain for all customers',
        basePrice: 900, color: '#ff4444',
        levels: [
            { cost: 900,  label: 'Hire', interval: 0, desc: '-10% patience drain for all customers' },
            { cost: 1400, label: 'Lv2',  interval: 0, desc: '-20% patience drain' },
            { cost: 2000, label: 'Lv3',  interval: 0, desc: '-30% patience drain' },
        ]
    },
    cleaner: {
        name: 'Dusty the Cleaner', icon: '', desc: 'Earns bonus credits from cleaned tables',
        basePrice: 400, color: '#00ff88',
        levels: [
            { cost: 400,  label: 'Hire', interval: 15000, desc: 'Earns 5-15 bonus credits every 15s' },
            { cost: 700,  label: 'Lv2',  interval: 12000, desc: 'Earns 10-25 credits every 12s' },
            { cost: 1100, label: 'Lv3',  interval: 8000,  desc: 'Earns 15-40 credits every 8s' },
        ]
    }
};

// staffState: { hired: { bartender: 0, waiter: 0, ... }, timers: { bartender: 0, ... } }
let staffState = {
    hired: {},  // key -> level (0 = not hired, 1-3 = level)
    timers: {}  // key -> accumulated ms
};

function getStaffLevel(key) { return staffState.hired[key] || 0; }

function toggleStaffPanel() {
    const panel = document.getElementById('staff-panel');
    if (panel.style.display === 'none') {
        if (typeof closeAllPanels === 'function') closeAllPanels();
        panel.style.display = 'block';
        buildStaffList();
    } else {
        panel.style.display = 'none';
    }
}

function buildStaffList() {
    const container = document.getElementById('staff-list');
    container.innerHTML = '';
    for (const [key, def] of Object.entries(STAFF_DEFS)) {
        const level = getStaffLevel(key);
        const maxed = level >= def.levels.length;
        const current = level > 0 ? def.levels[level - 1] : null;
        const next = !maxed ? def.levels[level] : null;

        let card = document.createElement('div');
        card.style.cssText = `background:rgba(0,0,0,0.4);border:2px solid ${level > 0 ? def.color : '#334'};border-radius:12px;padding:12px;margin-bottom:10px;transition:all 0.3s;${level > 0 ? 'box-shadow:0 0 12px ' + def.color + '40;' : ''}`;

        const statusText = level === 0 ? '<span style="color:#888;">Not hired</span>' :
            maxed ? `<span style="color:#ffd700;"> MAX LEVEL </span>` :
            `<span style="color:${def.color};">Level ${level}</span>`;
        
        const currentDesc = current ? `<div style="color:#aaa;font-size:11px;margin-top:4px;"> ${current.desc}</div>` : '';
        const nextDesc = next ? `<div style="color:#ddd;font-size:11px;margin-top:2px;"> Next: ${next.desc}</div>` : '';

        const btnHtml = next ? `<button onclick="hireStaff('${key}')" style="background:${GS.credits >= next.cost ? 'linear-gradient(135deg,' + def.color + ',#005580)' : 'rgba(50,50,50,0.8)'};border:2px solid ${def.color};color:#fff;padding:6px 16px;border-radius:8px;cursor:${GS.credits >= next.cost ? 'pointer' : 'not-allowed'};font-size:13px;font-family:'Nunito',sans-serif;font-weight:bold;${GS.credits >= next.cost ? '' : 'opacity:0.5;'}">${level === 0 ? 'HIRE' : 'UPGRADE'}  ${next.cost}</button>` : '';

        card.innerHTML = `
            <div style="display:flex;align-items:center;gap:10px;">
                <div style="font-size:32px;width:44px;text-align:center;">${def.icon}</div>
                <div style="flex:1;">
                    <div style="color:#fff;font-weight:bold;font-size:14px;">${def.name} ${statusText}</div>
                    <div style="color:#99bbcc;font-size:12px;">${def.desc}</div>
                    ${currentDesc}${nextDesc}
                </div>
                <div>${btnHtml}</div>
            </div>
        `;
        container.appendChild(card);
    }
}

function hireStaff(key) {
    const def = STAFF_DEFS[key];
    const level = getStaffLevel(key);
    if (level >= def.levels.length) return;
    const next = def.levels[level];
    if (GS.credits < next.cost) {
        showNotification(` Not enough credits! Need ${next.cost}`);
        return;
    }
    GS.credits -= next.cost;
    staffState.hired[key] = level + 1;
    staffState.timers[key] = 0;
    updateHUD();
    buildStaffList();
    const action = level === 0 ? 'hired' : 'upgraded to Lv' + (level + 1);
    showNotification(` ${def.icon} ${def.name} ${action}! ${next.desc}`);
    spawnParticleBurst(BAR_CENTER.x, BAR_CENTER.y, def.color, 20);
    playSound('levelup');
    save();
}

function getStaffPatienceMult() {
    const bouncerLv = getStaffLevel('bouncer');
    if (bouncerLv === 0) return 1;
    return [1, 0.9, 0.8, 0.7][bouncerLv]; // 10/20/30% slower drain
}

function updateStaff(dt) {
    for (const [key, def] of Object.entries(STAFF_DEFS)) {
        const level = getStaffLevel(key);
        if (level === 0) continue;
        const lvData = def.levels[level - 1];
        if (lvData.interval === 0) continue; // passive (bouncer)

        staffState.timers[key] = (staffState.timers[key] || 0) + dt;
        if (staffState.timers[key] < lvData.interval) continue;
        staffState.timers[key] = 0;

        if (key === 'bartender') {
            // Auto-take order for a waiting customer
            const waiting = GS.customers.find(c => c.state === 'waiting');
            if (waiting) {
                // Pick best drink: favorite > daily special > random unlocked
                const charData = CHAR_DATA[waiting.char];
                const favs = charData && charData.favorites ? charData.favorites : [];
                const unlocked = GS.unlockedDrinks || [];
                let pick = null;
                // Try favorite first
                for (const f of favs) { if (unlocked.includes(f)) { pick = f; break; } }
                // Then daily special
                if (!pick) { const ds = getDailySpecial(); if (unlocked.includes(ds)) pick = ds; }
                // Fallback random
                if (!pick && unlocked.length > 0) pick = unlocked[Math.floor(Math.random() * unlocked.length)];
                if (pick) {
                    GS.selectedCustomer = waiting;
                    orderDrink(pick);
                    spawnFloatingNumber(waiting.pos.x, waiting.pos.y - 30, '', 'combo');
                    addLog(` Mixo took ${CHAR_DATA[waiting.char].name}'s order!`, 'earn');
                }
            }
        } else if (key === 'waiter') {
            // Auto-serve a ready drink
            const ready = GS.customers.find(c => c.state === 'ordered' && c.drinkProgress >= 1);
            if (ready) {
                serveDrink(ready);
                spawnFloatingNumber(ready.pos.x, ready.pos.y - 30, '', 'combo');
                addLog(` Zippy served ${DRINKS[ready.order].name} to ${CHAR_DATA[ready.char].name}!`, 'earn');
            }
        } else if (key === 'entertainer') {
            // Boost a random customer's happiness
            const eligible = GS.customers.filter(c => c.state !== 'leaving' && c.state !== 'walking' && c.happiness < 100);
            if (eligible.length > 0) {
                const target = eligible[Math.floor(Math.random() * eligible.length)];
                const boost = [0, 3, 5, 8][level];
                target.happiness = Math.min(100, target.happiness + boost);
                spawnFloatingNumber(target.pos.x, target.pos.y - 30, `+${boost}`, 'xp');
            }
        } else if (key === 'cleaner') {
            // Earn bonus credits
            const ranges = [null, [5, 15], [10, 25], [15, 40]];
            const [min, max] = ranges[level];
            const earned = min + Math.floor(Math.random() * (max - min + 1));
            GS.credits += earned;
            GS.totalEarned += earned;
            spawnFloatingNumber(BAR_CENTER.x + (Math.random()-0.5)*100, BAR_CENTER.y + 30, `+${earned}`, 'credits');
            updateHUD();
        }
    }
}

// ==================== CUSTOMER CONVERSATIONS ====================
// When 2+ customers are seated, they occasionally chat with each other
const PAIR_CONVERSATIONS = {
    'walter_carl': [
        ["Walter, you ever miss Earth dogs?", "Carl, I miss EVERYTHING about Earth. Especially gravity that makes sense."],
        ["Hey Walt, what's your favourite dinosaur?", "ME, Carl. I AM a dinosaur. And I'm drinking, so maybe... a Wineosaurus."],
        ["Do dinosaurs dream?", "Only of better asteroids. And this drink. "],
        ["Would a dog like me, you think?", "Carl, a dog would love you. You'd be the best dog dad in this quadrant."],
    ],
    'walter_dick': [
        ["Oi old man, you smell like extinction", "And you smell like a council estate. We all have our crosses, Richard."],
        ["65 million years old and still can't hold his drink!", "I held drinks before your species discovered THUMBS."],
        ["Want to fight, grandad?", "*sips drink calmly* I survived an asteroid. You don't scare me, son."],
    ],
    'carl_dick': [
        ["Dick, have you ever pet a dog?", "Carl, I've nicked a dog. Does that count?", "That's... really sad actually."],
        ["Stop looking at me Burberry boy", "I'm looking at your EARS. They're magnificent."],
        ["Dogs are loyal, Dick. You could learn something.", "Loyal? I'm loyal to THIS drink. That count?"],
    ],
    'zix_blorb': [
        ["B-Blorb, you're not going to... absorb me, right?", "*JIGGLE* Only if you want a hug!", "PLEASE don't."],
        ["My sensors say you're 94% water...", "*happy wobble* And 6% VIBES! "],
        ["How do you... sit? You don't have bones.", "How do YOU sit? You're 90% anxiety circuits!", "...fair point."],
    ],
    'zix_dick': [
        ["*threat detection spiking* Dick is looking at me again...", "Relax bolt-brain, I'm looking at the drinks menu."],
        ["My anxiety algorithms predict a 78% chance Dick starts a fight.", "Make it 100% if you keep beeping at me."],
    ],
    'blorb_glorp': [
        ["GLORP! *excited jiggling*", "*GLORP GLORP* (translator: I think we're cousins?)"],
        ["*wobbles towards Glorp*", "*wobbles back* GLOOORP!", "*both wobbling intensifies*"],
        ["Are you... also made of goo?", "*GLORP* (translator: 'We prefer the term gelatinous')"],
    ],
    'toni_scally': [
        ["Toni, on my planet we drink with ALL mouths simultaneously.", "Impressive. On my world that's called 'Tuesday'."],
        ["*adjusts tentacles* Your antennae are exquisite.", "*blushes* Oh stop it, you'll make my signal spike."],
        ["I've been to 47 galaxies, Scally.", "I've been to 47 bars TODAY. Beat that."],
    ],
    'krax_pip': [
        ["*RUMBLES* Tiny fairy thing.", "*sparkles defiantly* I may be small but I tip 200%."],
        ["Why are you... glowing?", "Why are you made of ROCKS? We all have our thing, Krax."],
        ["*tries to high-five Pip*", "*dodges boulder-hand* Let's just... fist bump? Gently?"],
    ],
    'krax_walter': [
        ["You're old. I respect old. Rocks are old.", "Thanks... I think? How old ARE you, Krax?", "...I don't remember. Old."],
        ["*THUD* Sorry. Sat down too hard.", "That's what the asteroid said."],
    ],
    'pip_carl': [
        ["Carl, I found this picture of a Chihuahua!", "A CHI Pip. Pip. That's the cutest thing I've EVER seen."],
        ["*sprinkles fairy dust on Carl*", "*sneezes* What was that?!", "Good luck dust! For finding your Earth dog!"],
    ],
    'walter_toni': [
        ["In my day, bartenders didn't have tentacles.", "In MY day, customers didn't go extinct. Times change, Walter."],
        ["Toni, you ever think about the futility of existence?", "Walter, I have three livers. I think about the futility of sobriety."],
    ],
};

// Generic conversations for any pair without specific dialogue
const GENERIC_CONVERSATIONS = [
    ["Nice drink you got there.", "Thanks! Want to try a sip?", "I'm good, but cheers!"],
    ["Come here often?", "Every chance I get. Mary makes the BEST drinks.", "Can't argue with that!"],
    ["This bar has really improved lately!", "Right? New furniture, new drinks... love it."],
    ["What's good on the menu tonight?", "Honestly? Everything. But the daily special slaps."],
    ["*raises glass* Cheers!", "*clinks* To Orion's Barrel! "],
    ["Is it just me or is the music getting better?", "The jukebox upgrade was worth every credit."],
    ["I heard there's a VIP lounge planned...", "Ooh fancy! Think we'd get in?", "With our tab? Definitely."],
    ["Mary's getting faster at mixing drinks.", "She's had practice. We keep her busy! "],
    ["Love the new decorations.", "Yeah! Really gives the place character."],
    ["You believe they serve ALIENS here?", "...we ARE the aliens.", "Oh. Right."],
    ["What sector are you from?", "Sector 7-G. You?", "Classified. But the drinks are better here."],
    ["This station has the best views.", "You mean the nebula outside? Gorgeous."],
];

let _activeConversations = []; // [{id, chars: [c1, c2], lines: [...], lineIdx, timer, pos}]
let _convCooldown = 0; // Cooldown before next conversation can start

function updateCustomerConversations(dt) {
    _convCooldown -= dt;
    
    // Update active conversations
    for (let i = _activeConversations.length - 1; i >= 0; i--) {
        const conv = _activeConversations[i];
        conv.timer -= dt;
        if (conv.timer <= 0) {
            conv.lineIdx++;
            if (conv.lineIdx >= conv.lines.length) {
                // Conversation ended  happiness boost for participants
                for (const cid of conv.charIds) {
                    const cust = GS.customers.find(c => c.id === cid);
                    if (cust && cust.state !== 'leaving') {
                        cust.happiness = Math.min(cust.happiness + 8, 120);
                        spawnFloatingEmojis(cust.pos.x, cust.pos.y - 20, ['', '']);
                    }
                }
                _activeConversations.splice(i, 1);
                continue;
            }
            conv.timer = 2500 + conv.lines[conv.lineIdx].length * 40; // Longer lines = more display time
            // Alternate speaker
            conv.speakerIdx = (conv.speakerIdx + 1) % conv.charIds.length;
            if (conv.lines.length > 2 && conv.lineIdx === conv.lines.length - 1) {
                // Third line goes to first speaker for 3-line convos
                conv.speakerIdx = 0;
            }
        }
    }
    
    // Try to start a new conversation
    if (_convCooldown > 0 || _activeConversations.length >= 2) return;
    
    // Find seated customers (waiting, ordered, or drinking) who aren't already chatting
    const chattingIds = new Set(_activeConversations.flatMap(c => c.charIds));
    const seated = GS.customers.filter(c => 
        (c.state === 'waiting' || c.state === 'ordered' || c.state === 'drinking') &&
        !chattingIds.has(c.id)
    );
    
    if (seated.length < 2) return;
    
    // 0.5% chance per tick to start a conversation (~every 30-60 seconds with multiple customers)
    if (Math.random() > 0.0005 * dt) return;
    
    // Pick two random seated customers
    const shuffled = seated.sort(() => Math.random() - 0.5);
    const c1 = shuffled[0], c2 = shuffled[1];
    
    // Check for specific pair dialogue
    const pairKey1 = c1.char + '_' + c2.char;
    const pairKey2 = c2.char + '_' + c1.char;
    let lines;
    if (PAIR_CONVERSATIONS[pairKey1]) {
        const pool = PAIR_CONVERSATIONS[pairKey1];
        lines = pool[Math.floor(Math.random() * pool.length)];
    } else if (PAIR_CONVERSATIONS[pairKey2]) {
        const pool = PAIR_CONVERSATIONS[pairKey2];
        lines = pool[Math.floor(Math.random() * pool.length)];
    } else {
        lines = GENERIC_CONVERSATIONS[Math.floor(Math.random() * GENERIC_CONVERSATIONS.length)];
    }
    
    _activeConversations.push({
        id: Date.now(),
        charIds: [c1.id, c2.id],
        chars: [c1.char, c2.char],
        lines: [...lines],
        lineIdx: 0,
        timer: 2500 + lines[0].length * 40,
        speakerIdx: 0,
    });
    
    _convCooldown = 15000 + Math.random() * 20000; // 15-35 second cooldown between conversations
}

function drawCustomerConversations() {
    for (const conv of _activeConversations) {
        const speakerId = conv.charIds[conv.speakerIdx];
        const speaker = GS.customers.find(c => c.id === speakerId);
        if (!speaker) continue;
        
        const s = w2s(speaker.pos.x, speaker.pos.y);
        const text = conv.lines[conv.lineIdx];
        
        // Draw a special conversation bubble (different from regular quips)
        const fontSize = Math.max(10, 12 * cam.zoom);
        ctx.font = `bold ${fontSize}px Nunito, Arial`;
        
        // Word wrap
        const maxW = 160 * cam.zoom;
        const words = text.split(' ');
        const wrapLines = [];
        let currentLine = '';
        for (const word of words) {
            const test = currentLine ? currentLine + ' ' + word : word;
            if (ctx.measureText(test).width > maxW && currentLine) {
                wrapLines.push(currentLine);
                currentLine = word;
            } else {
                currentLine = test;
            }
        }
        if (currentLine) wrapLines.push(currentLine);
        
        const lineH = fontSize * 1.3;
        const bubbleW = Math.min(maxW + 20 * cam.zoom, wrapLines.reduce((m, l) => Math.max(m, ctx.measureText(l).width), 0) + 20 * cam.zoom);
        const bubbleH = wrapLines.length * lineH + 12 * cam.zoom;
        const bx = s.x - bubbleW / 2;
        const by = s.y - 120 * cam.zoom - bubbleH;
        
        // Bubble background  slightly different color for conversations (warm yellow)
        ctx.save();
        ctx.globalAlpha = 0.92;
        ctx.fillStyle = '#2a1f4e';
        ctx.strokeStyle = '#ffd700';
        ctx.lineWidth = 2 * cam.zoom;
        
        // Rounded rect
        const r = 8 * cam.zoom;
        ctx.beginPath();
        ctx.moveTo(bx + r, by);
        ctx.lineTo(bx + bubbleW - r, by);
        ctx.quadraticCurveTo(bx + bubbleW, by, bx + bubbleW, by + r);
        ctx.lineTo(bx + bubbleW, by + bubbleH - r);
        ctx.quadraticCurveTo(bx + bubbleW, by + bubbleH, bx + bubbleW - r, by + bubbleH);
        ctx.lineTo(bx + r, by + bubbleH);
        ctx.quadraticCurveTo(bx, by + bubbleH, bx, by + bubbleH - r);
        ctx.lineTo(bx, by + r);
        ctx.quadraticCurveTo(bx, by, bx + r, by);
        ctx.closePath();
        ctx.fill();
        ctx.stroke();
        
        // Speech pointer
        ctx.beginPath();
        ctx.moveTo(s.x - 6 * cam.zoom, by + bubbleH);
        ctx.lineTo(s.x, by + bubbleH + 10 * cam.zoom);
        ctx.lineTo(s.x + 6 * cam.zoom, by + bubbleH);
        ctx.fillStyle = '#2a1f4e';
        ctx.fill();
        ctx.stroke();
        
        //  icon to indicate conversation
        ctx.globalAlpha = 1;
        ctx.font = `${10 * cam.zoom}px Arial`;
        ctx.fillText('', bx + 3 * cam.zoom, by + 12 * cam.zoom);
        
        // Speaker name
        const charData = CHAR_DATA[speaker.char];
        ctx.font = `bold ${Math.max(8, 9 * cam.zoom)}px Nunito, Arial`;
        ctx.fillStyle = '#ffd700';
        ctx.textAlign = 'left';
        ctx.fillText(charData ? charData.name : speaker.char, bx + 14 * cam.zoom, by + 12 * cam.zoom);
        
        // Text
        ctx.font = `bold ${fontSize}px Nunito, Arial`;
        ctx.fillStyle = '#fff';
        ctx.textAlign = 'center';
        for (let i = 0; i < wrapLines.length; i++) {
            ctx.fillText(wrapLines[i], s.x, by + 20 * cam.zoom + i * lineH + lineH * 0.5);
        }
        
        ctx.restore();
    }
}

// ==================== IDLE EARNINGS ====================
function checkIdleEarnings() {
    const lastSave = GS._lastSaveTime;
    if (!lastSave) return;
    
    const awayMs = Date.now() - lastSave;
    const awayMin = awayMs / 60000;
    
    // Only show if away for 2+ minutes
    if (awayMin < 2) return;
    
    // Base earnings: level * 2 credits per minute, capped at 8 hours
    const cappedMin = Math.min(awayMin, 480);
    const baseRate = GS.level * 2;
    
    // Bonuses from upgrades, tables, reputation
    const tableBonus = 1 + (GS.tables.length * 0.05);
    const repBonus = 1 + (GS.reputation / 200);
    const prestigeBonus = 1 + ((GS._prestigeCount || 0) * 0.1);
    
    const idleCredits = Math.floor(cappedMin * baseRate * tableBonus * repBonus * prestigeBonus);
    const idleXP = Math.floor(idleCredits * 0.3);
    
    // Format time away
    let timeStr;
    if (awayMin < 60) timeStr = `${Math.floor(awayMin)} minutes`;
    else if (awayMin < 1440) timeStr = `${Math.floor(awayMin / 60)}h ${Math.floor(awayMin % 60)}m`;
    else timeStr = `${Math.floor(awayMin / 1440)}d ${Math.floor((awayMin % 1440) / 60)}h`;
    
    // Show popup
    document.getElementById('wb-time-away').textContent = `Mary kept the bar running for ${timeStr}!`;
    document.getElementById('wb-credits').textContent = `+${idleCredits.toLocaleString()}`;
    document.getElementById('wb-xp').textContent = `+${idleXP.toLocaleString()}`;
    document.getElementById('wb-rating').textContent = ` ${GS._barRating || '0.0'}`;
    document.getElementById('welcome-back-overlay').classList.add('show');
    
    // Collect button
    document.getElementById('wb-collect').onclick = () => {
        GS.credits += idleCredits;
        GS.xp += idleXP;
        // Check level up
        while (GS.xp >= GS.xpNeeded) {
            GS.xp -= GS.xpNeeded;
            GS.level++;
            GS.xpNeeded = Math.floor(GS.xpNeeded * 1.15);
        }
        document.getElementById('welcome-back-overlay').classList.remove('show');
        updateHUD();
        spawnParticleBurst(BAR_CENTER.x, BAR_CENTER.y, '#ffd700', 30);
        try { playSound('levelup'); } catch(e) {}
        showNotification(` Collected ${idleCredits.toLocaleString()} idle credits!`);
        save();
    };
}

function save() {
    try {
        const si = document.getElementById('save-indicator');
        if (si) { si.classList.add('show'); clearTimeout(si._t); si._t = setTimeout(() => si.classList.remove('show'), 1500); }
        localStorage.setItem('ob_save2', JSON.stringify({
            credits: GS.credits, level: GS.level, xp: GS.xp, xpNeeded: GS.xpNeeded,
            reputation: GS.reputation, tables: GS.tables, upgrades: GS.upgrades,
            decorations: GS.decorations, unlockedDrinks: GS.unlockedDrinks,
            totalServed: GS.totalServed, totalEarned: GS.totalEarned,
            spawnInterval: GS.spawnInterval,
            inventory: GS.inventory, placedFurniture: GS.placedFurniture,
            _vipServed: GS._vipServed || 0, _nightOwlServed: GS._nightOwlServed || 0,
            _maxCombo: GS._maxCombo || 0, _perfectServes: GS._perfectServes || 0,
            _dailiesCompleted: GS._dailiesCompleted || 0,
            _walterServed: GS._walterServed || 0, _carlServed: GS._carlServed || 0,
            _zixServed: GS._zixServed || 0, _blorbServed: GS._blorbServed || 0,
            achievements: unlockedAchievements,
            dailyChallenges, dailyProgress, dailyDate, dailyBonusClaimed,
            completedQuests, activeQuests,
            // Streak data
            _loginStreak: GS._loginStreak || 0,
            _lastLogin: GS._lastLogin || null,
            _perfectDayStreak: GS._perfectDayStreak || 0,
            _longestLoginStreak: GS._longestLoginStreak || 0,
            _totalLogins: GS._totalLogins || 0,
            _streakRewardsClaimed: GS._streakRewardsClaimed || [],
            // Prestige data
            _prestigePoints: GS._prestigePoints || 0,
            _lifetimePrestige: GS._lifetimePrestige || 0,
            _prestigeCount: GS._prestigeCount || 0,
            _favoritesServed: GS._favoritesServed || [],
            // Statistics tracking
            _highestLevel: GS._highestLevel || GS.level || 1,
            _maxCreditsHeld: GS._maxCreditsHeld || GS.credits || 0,
            _maxReputation: GS._maxReputation || GS.reputation || 0,
            _sessionCount: (GS._sessionCount || 0),
            // Tip jar & reviews
            _tipJarAmount: GS._tipJarAmount || 0,
            _totalTipsCollected: GS._totalTipsCollected || 0,
            _reviewHistory: GS._reviewHistory || [],
            _barRating: GS._barRating || '0.0',
            // Happy hour tracking
            _lastHappyHour: GS._lastHappyHour || 0,
            _happyHourCount: GS._happyHourCount || 0,
            _skillsUnlocked: GS._skillsUnlocked || [],
            _charServes: GS._charServes || {},
            _charRelClaimed: GS._charRelClaimed || {},
            _rushesCleared: rushState.rushesCleared || 0,
            _lastSpinTime: GS._lastSpinTime || 0,
            _synergiesTriggered: GS._synergiesTriggered || 0,
            _drinkMastery: GS._drinkMastery || {},
            _starsCaught: GS._starsCaught || 0,
            _petOwned: petState.owned,
            _petActive: petState.active,
            _loyalty: GS._loyalty || {},
            _staffHired: staffState.hired,
            _lastSaveTime: Date.now(),
        }));
        saveToLeaderboard();
    } catch(e) {}
}

function loadSave() {
    try {
        const d = JSON.parse(localStorage.getItem('ob_save2'));
        if (!d) return;
        Object.keys(d).forEach(k => {
            if (k === 'achievements') {
                unlockedAchievements = d[k] || [];
            } else if (k === 'dailyChallenges') {
                dailyChallenges = d[k] || [];
            } else if (k === 'dailyProgress') {
                dailyProgress = d[k] || {};
            } else if (k === 'dailyDate') {
                dailyDate = d[k] || '';
            } else if (k === 'dailyBonusClaimed') {
                dailyBonusClaimed = d[k] || false;
            } else if (k === 'completedQuests') {
                completedQuests = d[k] || [];
            } else if (k === 'activeQuests') {
                activeQuests = d[k] || [];
            } else if (k === '_petOwned') {
                petState.owned = d[k] || [];
            } else if (k === '_petActive') {
                petState.active = d[k] || null;
                if (petState.active) {
                    petState.petPos = { x: BAR_CENTER.x + (Math.random() - 0.5) * 100, y: BAR_CENTER.y + 50 };
                }
            } else if (k === '_staffHired') {
                staffState.hired = d[k] || {};
            } else if (k === '_rushesCleared') {
                rushState.rushesCleared = d[k] || 0;
            } else if (GS[k] !== undefined || k.startsWith('_')) {
                GS[k] = d[k];
            }
        });
    } catch(e) {}
}

// ==================== START ====================
function startGame() {
    document.getElementById('tutorial').classList.add('hidden');
    GS.started = true;
    // Resume audio context
    try { getAudio().resume(); } catch(e) {}
    
    // Trigger intro dialogue if first session and no quests done
    if ((GS._sessionCount || 1) === 1 && completedQuests.length === 0) {
        setTimeout(() => showDialogue('intro_1'), 1000);
    }
}

window.addEventListener('load', () => {
    // Safety timeout - show game after 8s even if assets fail
    setTimeout(() => {
        const l = document.getElementById('loading');
        if (l && l.style.display !== 'none') {
            l.style.display = 'none';
            document.getElementById('game-container').style.display = 'block';
            initCanvas(); initGame(); gameLoop();
        }
    }, 8000);
    loadAllAssets().catch(e => {
        console.error(e);
        document.getElementById('loading').style.display = 'none';
        document.getElementById('game-container').style.display = 'block';
        initCanvas();
    });
});

// Emergency fallback
setTimeout(() => {
    const l = document.getElementById('loading');
    if (l && l.style.display !== 'none') {
        l.style.display = 'none';
        document.getElementById('game-container').style.display = 'block';
        try { initCanvas(); } catch(e) {}
    }
}, 8000);
</script>
</body>
</html>
